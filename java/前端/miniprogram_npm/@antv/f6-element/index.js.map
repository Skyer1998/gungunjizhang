{"version":3,"sources":["index.js","nodes/index.js","nodes/circle.js","nodes/rect.js","nodes/ellipse.js","nodes/diamond.js","nodes/triangle.js","nodes/modelRect.js","nodes/star.js","nodes/donut.js","edges/index.js","edges/polyline.js","edges/polyline-util.js","edges/router.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA;ADIA,AGTA,ADGA,AHSA,AENA,AGTA;AJaA,AGTA,ADGA,AHSA,AENA,AGTA;AJaA,AGTA,ADGA,ADGA,AGTA;AJaA,AGTA,ADGA,AGTA,AJYA,AGTA;AJaA,AGTA,ADGA,AGTA,AJYA,AGTA;AJaA,AGTA,ADGA,AGTA,AJYA,AGTA;AJaA,AGTA,ADGA,AGTA,AJYA,AKfA,AFMA;AJaA,AGTA,ADGA,AGTA,AJYA,AKfA,AFMA;AJaA,AGTA,ADGA,AGTA,AJYA,AKfA,AFMA;AJaA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AJaA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AJaA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AIXA,ARwBA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AIXA,ARwBA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AIXA,ARwBA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AKdA,AT2BA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AKdA,AT2BA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AKdA,AT2BA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AT2BA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AT2BA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AT2BA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,AJYA,AKfA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,AIZA,ALeA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,AXiCA,AGTA,ADGA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ADGA,AENA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ACHA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ACHA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ACHA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ACHA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ACHA,ARwBA,ADGA,AGTA,ACHA,AFMA;AMjBA,ACHA,ARwBA,AENA,ACHA,AFMA;AMjBA,ACHA,ARwBA,AENA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ACHA,AFMA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ACHA,ANkBA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA,ADGA;AMjBA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nrequire(\"./nodes\");\n\nrequire(\"./edges\");","\n\nrequire(\"./circle\");\n\nrequire(\"./rect\");\n\nrequire(\"./ellipse\");\n\nrequire(\"./diamond\");\n\nrequire(\"./triangle\");\n\nrequire(\"./modelRect\");\n\nrequire(\"./star\");\n\nrequire(\"./donut\");","\n\nvar _tslib = require(\"tslib\");\n\nvar _f6Core = require(\"@antv/f6-core\");\n\nvar _util = require(\"@antv/util\");\n\n// 带有图标的圆，可用于拓扑图中\n(0, _f6Core.registerNode)('circle', {\n  // 自定义节点时的配置\n  options: {\n    size: _f6Core.BaseGlobal.defaultNode.size,\n    style: {\n      x: 0,\n      y: 0,\n      stroke: _f6Core.BaseGlobal.defaultNode.style.stroke,\n      fill: _f6Core.BaseGlobal.defaultNode.style.fill,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.style.lineWidth\n    },\n    labelCfg: {\n      style: {\n        fill: _f6Core.BaseGlobal.nodeLabel.style.fill,\n        fontSize: _f6Core.BaseGlobal.nodeLabel.style.fontSize\n      }\n    },\n    // 节点上左右上下四个方向上的链接circle配置\n    linkPoints: {\n      top: false,\n      right: false,\n      bottom: false,\n      left: false,\n      // circle的大小\n      size: _f6Core.BaseGlobal.defaultNode.linkPoints.size,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.linkPoints.lineWidth,\n      fill: _f6Core.BaseGlobal.defaultNode.linkPoints.fill,\n      stroke: _f6Core.BaseGlobal.defaultNode.linkPoints.stroke\n    },\n    // 节点中icon配置\n    icon: {\n      // 是否显示icon，值为 false 则不渲染icon\n      show: false,\n      // icon的地址，字符串类型\n      img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',\n      width: 20,\n      height: 20\n    },\n    stateStyles: (0, _tslib.__assign)({}, _f6Core.BaseGlobal.nodeStateStyles)\n  },\n  shapeType: 'circle',\n  // 文本位置\n  labelPosition: 'center',\n  drawShape: function drawShape(cfg, group) {\n    var _a = this.getOptions(cfg).icon,\n        defaultIcon = _a === void 0 ? {} : _a;\n    var style = this.getShapeStyle(cfg);\n    var icon = (0, _util.deepMix)({}, defaultIcon, cfg.icon);\n    var keyShape = group.addShape('circle', {\n      attrs: style,\n      className: this.type + \"-keyShape\",\n      draggable: true\n    });\n    var width = icon.width,\n        height = icon.height,\n        show = icon.show,\n        text = icon.text;\n\n    if (show) {\n      if (text) {\n        group.addShape('text', {\n          attrs: (0, _tslib.__assign)({\n            x: 0,\n            y: 0,\n            fontSize: 12,\n            fill: '#000',\n            stroke: '#000',\n            textBaseline: 'middle',\n            textAlign: 'center'\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      } else {\n        group.addShape('image', {\n          attrs: (0, _tslib.__assign)({\n            x: -width / 2,\n            y: -height / 2\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      }\n    }\n\n    this.drawLinkPoints(cfg, group);\n    return keyShape;\n  },\n\n  /**\n   * 绘制节点上的LinkPoints\n   * @param {Object} cfg data数据配置项\n   * @param {Group} group Group实例\n   */\n  drawLinkPoints: function drawLinkPoints(cfg, group) {\n    var _a = this.getOptions(cfg).linkPoints,\n        linkPoints = _a === void 0 ? {} : _a;\n    var top = linkPoints.top,\n        left = linkPoints.left,\n        right = linkPoints.right,\n        bottom = linkPoints.bottom,\n        markSize = linkPoints.size,\n        markR = linkPoints.r,\n        markStyle = (0, _tslib.__rest)(linkPoints, [\"top\", \"left\", \"right\", \"bottom\", \"size\", \"r\"]);\n    var size = this.getSize(cfg);\n    var r = size[0] / 2;\n\n    if (left) {\n      // left circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: -r,\n          y: 0,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-left',\n        name: 'link-point-left',\n        isAnchorPoint: true\n      });\n    }\n\n    if (right) {\n      // right circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: r,\n          y: 0,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-right',\n        name: 'link-point-right',\n        isAnchorPoint: true\n      });\n    }\n\n    if (top) {\n      // top circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: 0,\n          y: -r,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-top',\n        name: 'link-point-top',\n        isAnchorPoint: true\n      });\n    }\n\n    if (bottom) {\n      // bottom circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: 0,\n          y: r,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-bottom',\n        name: 'link-point-bottom',\n        isAnchorPoint: true\n      });\n    }\n  },\n\n  /**\n   * 获取节点的样式，供基于该节点自定义时使用\n   * @param {Object} cfg 节点数据模型\n   * @return {Object} 节点的样式\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.getOptions(cfg).style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = (0, _util.deepMix)({}, defaultStyle, strokeStyle);\n    var size = this.getSize(cfg);\n    var r = size[0] / 2;\n    var styles = (0, _tslib.__assign)({\n      x: 0,\n      y: 0,\n      r: r\n    }, style);\n    return styles;\n  },\n  update: function update(cfg, item) {\n    var group = item.getContainer();\n    var size = this.getSize(cfg); // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\n\n    var strokeStyle = {\n      stroke: cfg.color,\n      r: size[0] / 2\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\n\n    var keyShape = item.get('keyShape');\n    var style = (0, _util.deepMix)({}, keyShape.attr(), strokeStyle, cfg.style);\n    this.updateShape(cfg, item, style, true);\n    this.updateLinkPoints(cfg, group);\n  }\n}, 'single-node');","\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _f6Core = require(\"@antv/f6-core\");\n\n(0, _f6Core.registerNode)('rect', {\n  // 自定义节点时的配置\n  options: {\n    size: [100, 30],\n    style: {\n      radius: 0,\n      stroke: _f6Core.BaseGlobal.defaultNode.style.stroke,\n      fill: _f6Core.BaseGlobal.defaultNode.style.fill,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.style.lineWidth\n    },\n    // 文本样式配置\n    labelCfg: {\n      style: {\n        fill: _f6Core.BaseGlobal.nodeLabel.style.fill,\n        fontSize: _f6Core.BaseGlobal.nodeLabel.style.fontSize\n      }\n    },\n    // 节点上左右上下四个方向上的链接circle配置\n    linkPoints: {\n      top: false,\n      right: false,\n      bottom: false,\n      left: false,\n      // circle的大小\n      size: _f6Core.BaseGlobal.defaultNode.linkPoints.size,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.linkPoints.lineWidth,\n      fill: _f6Core.BaseGlobal.defaultNode.linkPoints.fill,\n      stroke: _f6Core.BaseGlobal.defaultNode.linkPoints.stroke\n    },\n    // 节点中icon配置\n    icon: {\n      // 是否显示icon，值为 false 则不渲染icon\n      show: false,\n      // icon的地址，字符串类型\n      img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',\n      width: 20,\n      height: 20\n    },\n    // 连接点，默认为左右\n    // anchorPoints: [{ x: 0, y: 0.5 }, { x: 1, y: 0.5 }]\n    anchorPoints: [[0, 0.5], [1, 0.5]],\n    stateStyles: (0, _tslib.__assign)({}, _f6Core.BaseGlobal.nodeStateStyles)\n  },\n  shapeType: 'rect',\n  labelPosition: 'center',\n  drawShape: function drawShape(cfg, group) {\n    var style = this.getShapeStyle(cfg);\n    var keyShape = group.addShape('rect', {\n      attrs: style,\n      className: this.type + \"-keyShape\",\n      name: this.type + \"-keyShape\",\n      draggable: true\n    });\n    this.drawLinkPoints(cfg, group);\n    return keyShape;\n  },\n\n  /**\n   * 绘制节点上的LinkPoints\n   * @param {Object} cfg data数据配置项\n   * @param {Group} group Group实例\n   */\n  drawLinkPoints: function drawLinkPoints(cfg, group) {\n    var _a = this.getOptions(cfg).linkPoints,\n        linkPoints = _a === void 0 ? {} : _a;\n    var top = linkPoints.top,\n        left = linkPoints.left,\n        right = linkPoints.right,\n        bottom = linkPoints.bottom,\n        markSize = linkPoints.size,\n        markR = linkPoints.r,\n        markStyle = (0, _tslib.__rest)(linkPoints, [\"top\", \"left\", \"right\", \"bottom\", \"size\", \"r\"]);\n    var size = this.getSize(cfg);\n    var width = size[0];\n    var height = size[1];\n\n    if (left) {\n      // left circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: -width / 2,\n          y: 0,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-left',\n        name: 'link-point-left',\n        isAnchorPoint: true\n      });\n    }\n\n    if (right) {\n      // right circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: width / 2,\n          y: 0,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-right',\n        name: 'link-point-right',\n        isAnchorPoint: true\n      });\n    }\n\n    if (top) {\n      // top circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: 0,\n          y: -height / 2,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-top',\n        name: 'link-point-top',\n        isAnchorPoint: true\n      });\n    }\n\n    if (bottom) {\n      // bottom circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: 0,\n          y: height / 2,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-bottom',\n        name: 'link-point-bottom',\n        isAnchorPoint: true\n      });\n    }\n  },\n\n  /**\n   * 获取节点的样式，供基于该节点自定义时使用\n   * @param {Object} cfg 节点数据模型\n   * @return {Object} 节点的样式\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.getOptions(cfg).style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle);\n    var size = this.getSize(cfg);\n    var width = style.width || size[0];\n    var height = style.height || size[1];\n    var styles = (0, _tslib.__assign)({\n      x: -width / 2,\n      y: -height / 2,\n      width: width,\n      height: height\n    }, style);\n    return styles;\n  },\n  update: function update(cfg, item) {\n    var group = item.getContainer(); // 这里不传 cfg 参数是因为 cfg.style 需要最后覆盖样式\n\n    var defaultStyle = this.getOptions({}).style;\n    var size = this.getSize(cfg);\n    var keyShape = item.get('keyShape');\n\n    if (!cfg.size) {\n      size[0] = keyShape.attr('width') || defaultStyle.width;\n      size[1] = keyShape.attr('height') || defaultStyle.height;\n    } // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\n\n\n    var strokeStyle = {\n      stroke: cfg.color,\n      x: -size[0] / 2,\n      y: -size[1] / 2,\n      width: size[0],\n      height: size[1]\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\n\n    var style = (0, _util.mix)({}, defaultStyle, keyShape.attr(), strokeStyle);\n    style = (0, _util.mix)(style, cfg.style);\n    this.updateShape(cfg, item, style, false);\n    this.updateLinkPoints(cfg, group);\n  }\n}, 'single-node');","\n\nvar _tslib = require(\"tslib\");\n\nvar _f6Core = require(\"@antv/f6-core\");\n\nvar _util = require(\"@antv/util\");\n\n/**\n * 基本的椭圆，可以添加文本，默认文本居中\n */\n(0, _f6Core.registerNode)('ellipse', {\n  // 自定义节点时的配置\n  options: {\n    size: [80, 40],\n    style: {\n      x: 0,\n      y: 0,\n      stroke: _f6Core.BaseGlobal.defaultNode.style.stroke,\n      fill: _f6Core.BaseGlobal.defaultNode.style.fill,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.style.lineWidth\n    },\n    // 文本样式配置\n    labelCfg: {\n      style: {\n        fill: _f6Core.BaseGlobal.nodeLabel.style.fill,\n        fontSize: _f6Core.BaseGlobal.nodeLabel.style.fontSize\n      }\n    },\n    // 节点上左右上下四个方向上的链接circle配置\n    linkPoints: {\n      top: false,\n      right: false,\n      bottom: false,\n      left: false,\n      // circle的大小\n      size: _f6Core.BaseGlobal.defaultNode.linkPoints.size,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.linkPoints.lineWidth,\n      fill: _f6Core.BaseGlobal.defaultNode.linkPoints.fill,\n      stroke: _f6Core.BaseGlobal.defaultNode.linkPoints.stroke\n    },\n    // 节点中icon配置\n    icon: {\n      // 是否显示icon，值为 false 则不渲染icon\n      show: false,\n      // icon的地址，字符串类型\n      img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',\n      width: 20,\n      height: 20\n    },\n    stateStyles: (0, _tslib.__assign)({}, _f6Core.BaseGlobal.nodeStateStyles)\n  },\n  shapeType: 'ellipse',\n  // 文本位置\n  labelPosition: 'center',\n  drawShape: function drawShape(cfg, group) {\n    var _a = this.getOptions(cfg).icon,\n        icon = _a === void 0 ? {} : _a;\n    var style = this.getShapeStyle(cfg);\n    var keyShape = group.addShape('ellipse', {\n      attrs: style,\n      className: 'ellipse-keyShape',\n      name: 'ellipse-keyShape',\n      draggable: true\n    });\n    var width = icon.width,\n        height = icon.height,\n        show = icon.show,\n        text = icon.text;\n\n    if (show) {\n      if (text) {\n        group.addShape('text', {\n          attrs: (0, _tslib.__assign)({\n            x: 0,\n            y: 0,\n            fontSize: 12,\n            fill: '#000',\n            stroke: '#000',\n            textBaseline: 'middle',\n            textAlign: 'center'\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      } else {\n        group.addShape('image', {\n          attrs: (0, _tslib.__assign)({\n            x: -width / 2,\n            y: -height / 2\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      }\n    }\n\n    this.drawLinkPoints(cfg, group);\n    return keyShape;\n  },\n\n  /**\n   * 绘制节点上的LinkPoints\n   * @param {Object} cfg data数据配置项\n   * @param {Group} group Group实例\n   */\n  drawLinkPoints: function drawLinkPoints(cfg, group) {\n    var _a = this.getOptions(cfg).linkPoints,\n        linkPoints = _a === void 0 ? {} : _a;\n    var top = linkPoints.top,\n        left = linkPoints.left,\n        right = linkPoints.right,\n        bottom = linkPoints.bottom,\n        markSize = linkPoints.size,\n        markR = linkPoints.r,\n        markStyle = (0, _tslib.__rest)(linkPoints, [\"top\", \"left\", \"right\", \"bottom\", \"size\", \"r\"]);\n    var size = this.getSize(cfg);\n    var rx = size[0] / 2;\n    var ry = size[1] / 2;\n\n    if (left) {\n      // left circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: -rx,\n          y: 0,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-left',\n        name: 'link-point-left',\n        isAnchorPoint: true\n      });\n    }\n\n    if (right) {\n      // right circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: rx,\n          y: 0,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-right',\n        name: 'link-point-right',\n        isAnchorPoint: true\n      });\n    }\n\n    if (top) {\n      // top circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: 0,\n          y: -ry,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-top',\n        name: 'link-point-top',\n        isAnchorPoint: true\n      });\n    }\n\n    if (bottom) {\n      // bottom circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: 0,\n          y: ry,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-bottom',\n        name: 'link-point-bottom',\n        isAnchorPoint: true\n      });\n    }\n  },\n\n  /**\n   * 获取节点的样式，供基于该节点自定义时使用\n   * @param {Object} cfg 节点数据模型\n   * @return {Object} 节点的样式\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.getOptions(cfg).style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle);\n    var size = this.getSize(cfg);\n    var rx = size[0] / 2;\n    var ry = size[1] / 2;\n    var styles = (0, _tslib.__assign)({\n      x: 0,\n      y: 0,\n      rx: rx,\n      ry: ry\n    }, style);\n    return styles;\n  },\n  update: function update(cfg, item) {\n    var group = item.getContainer(); // 这里不传 cfg 参数是因为 cfg.style 需要最后覆盖样式\n\n    var defaultStyle = this.getOptions({}).style;\n    var size = this.getSize(cfg);\n    var strokeStyle = {\n      stroke: cfg.color,\n      rx: size[0] / 2,\n      ry: size[1] / 2\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\n\n    var keyShape = item.get('keyShape');\n    var style = (0, _util.mix)({}, defaultStyle, keyShape.attr(), strokeStyle);\n    style = (0, _util.mix)(style, cfg.style);\n    this.updateShape(cfg, item, style, true);\n    this.updateLinkPoints(cfg, group);\n  }\n}, 'single-node');","\n\nvar _tslib = require(\"tslib\");\n\nvar _f6Core = require(\"@antv/f6-core\");\n\nvar _util = require(\"@antv/util\");\n\n// 菱形shape\n(0, _f6Core.registerNode)('diamond', {\n  // 自定义节点时的配置\n  options: {\n    size: [80, 80],\n    style: {\n      stroke: _f6Core.BaseGlobal.defaultNode.style.stroke,\n      fill: _f6Core.BaseGlobal.defaultNode.style.fill,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.style.lineWidth\n    },\n    // 文本样式配置\n    labelCfg: {\n      style: {\n        fill: _f6Core.BaseGlobal.nodeLabel.style.fill,\n        fontSize: _f6Core.BaseGlobal.nodeLabel.style.fontSize\n      }\n    },\n    // 节点上左右上下四个方向上的链接circle配置\n    linkPoints: {\n      top: false,\n      right: false,\n      bottom: false,\n      left: false,\n      // circle的大小\n      size: _f6Core.BaseGlobal.defaultNode.linkPoints.size,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.linkPoints.lineWidth,\n      fill: _f6Core.BaseGlobal.defaultNode.linkPoints.fill,\n      stroke: _f6Core.BaseGlobal.defaultNode.linkPoints.stroke\n    },\n    // 节点中icon配置\n    icon: {\n      // 是否显示icon，值为 false 则不渲染icon\n      show: false,\n      // icon的地址，字符串类型\n      img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',\n      width: 20,\n      height: 20\n    },\n    stateStyles: (0, _tslib.__assign)({}, _f6Core.BaseGlobal.nodeStateStyles)\n  },\n  shapeType: 'diamond',\n  // 文本位置\n  labelPosition: 'center',\n  drawShape: function drawShape(cfg, group) {\n    var _a = this.getOptions(cfg).icon,\n        icon = _a === void 0 ? {} : _a;\n    var style = this.getShapeStyle(cfg);\n    var keyShape = group.addShape('path', {\n      attrs: style,\n      className: this.type + \"-keyShape\",\n      name: this.type + \"-keyShape\",\n      draggable: true\n    });\n    var w = icon.width,\n        h = icon.height,\n        show = icon.show,\n        text = icon.text;\n\n    if (show) {\n      if (text) {\n        group.addShape('text', {\n          attrs: (0, _tslib.__assign)({\n            x: 0,\n            y: 0,\n            fontSize: 12,\n            fill: '#000',\n            stroke: '#000',\n            textBaseline: 'middle',\n            textAlign: 'center'\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      } else {\n        group.addShape('image', {\n          attrs: (0, _tslib.__assign)({\n            x: -w / 2,\n            y: -h / 2\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      }\n    }\n\n    this.drawLinkPoints(cfg, group);\n    return keyShape;\n  },\n\n  /**\n   * 绘制节点上的LinkPoints\n   * @param {Object} cfg data数据配置项\n   * @param {Group} group Group实例\n   */\n  drawLinkPoints: function drawLinkPoints(cfg, group) {\n    var _a = this.getOptions(cfg).linkPoints,\n        linkPoints = _a === void 0 ? {} : _a;\n    var top = linkPoints.top,\n        left = linkPoints.left,\n        right = linkPoints.right,\n        bottom = linkPoints.bottom,\n        markSize = linkPoints.size,\n        markR = linkPoints.r,\n        markStyle = (0, _tslib.__rest)(linkPoints, [\"top\", \"left\", \"right\", \"bottom\", \"size\", \"r\"]);\n    var size = this.getSize(cfg);\n    var width = size[0];\n    var height = size[1];\n\n    if (left) {\n      // left circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: -width / 2,\n          y: 0,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-left',\n        name: 'link-point-left',\n        isAnchorPoint: true\n      });\n    }\n\n    if (right) {\n      // right circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: width / 2,\n          y: 0,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-right',\n        name: 'link-point-right',\n        isAnchorPoint: true\n      });\n    }\n\n    if (top) {\n      // top circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: 0,\n          y: -height / 2,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-top',\n        name: 'link-point-top',\n        isAnchorPoint: true\n      });\n    }\n\n    if (bottom) {\n      // bottom circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: 0,\n          y: height / 2,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-bottom',\n        name: 'link-point-bottom',\n        isAnchorPoint: true\n      });\n    }\n  },\n  getPath: function getPath(cfg) {\n    var size = this.getSize(cfg);\n    var width = size[0];\n    var height = size[1];\n    var path = [['M', 0, -height / 2], ['L', width / 2, 0], ['L', 0, height / 2], ['L', -width / 2, 0], ['Z'] // 封闭\n    ];\n    return path;\n  },\n\n  /**\n   * 获取节点的样式，供基于该节点自定义时使用\n   * @param {Object} cfg 节点数据模型\n   * @return {Object} 节点的样式\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.getOptions(cfg).style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle);\n    var path = this.getPath(cfg);\n    var styles = (0, _tslib.__assign)({\n      path: path\n    }, style);\n    return styles;\n  },\n  update: function update(cfg, item) {\n    var group = item.getContainer(); // 这里不传 cfg 参数是因为 cfg.style 需要最后覆盖样式\n\n    var defaultStyle = this.getOptions({}).style;\n    var path = this.getPath(cfg); // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\n\n    var strokeStyle = {\n      stroke: cfg.color,\n      path: path\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\n\n    var keyShape = item.get('keyShape');\n    var style = (0, _util.mix)({}, defaultStyle, keyShape.attr(), strokeStyle);\n    style = (0, _util.mix)(style, cfg.style);\n    this.updateShape(cfg, item, style, true);\n    this.updateLinkPoints(cfg, group);\n  }\n}, 'single-node');","\n\nvar _tslib = require(\"tslib\");\n\nvar _f6Core = require(\"@antv/f6-core\");\n\nvar _util = require(\"@antv/util\");\n\n// 三角形\n(0, _f6Core.registerNode)('triangle', {\n  // 自定义节点时的配置\n  options: {\n    size: 40,\n    direction: 'up',\n    style: {\n      stroke: _f6Core.BaseGlobal.defaultNode.style.stroke,\n      fill: _f6Core.BaseGlobal.defaultNode.style.fill,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.style.lineWidth\n    },\n    labelCfg: {\n      style: {\n        fill: _f6Core.BaseGlobal.nodeLabel.style.fill,\n        fontSize: _f6Core.BaseGlobal.nodeLabel.style.fontSize\n      },\n      offset: 15\n    },\n    // 节点上左右上下四个方向上的链接circle配置\n    linkPoints: {\n      top: false,\n      right: false,\n      bottom: false,\n      left: false,\n      // circle的大小\n      size: _f6Core.BaseGlobal.defaultNode.linkPoints.size,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.linkPoints.lineWidth,\n      fill: _f6Core.BaseGlobal.defaultNode.linkPoints.fill,\n      stroke: _f6Core.BaseGlobal.defaultNode.linkPoints.stroke\n    },\n    // 节点中icon配置\n    icon: {\n      // 是否显示icon，值为 false 则不渲染icon\n      show: false,\n      // icon的地址，字符串类型\n      img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',\n      width: 20,\n      height: 20,\n      offset: 6\n    },\n    stateStyles: (0, _tslib.__assign)({}, _f6Core.BaseGlobal.nodeStateStyles)\n  },\n  shapeType: 'triangle',\n  // 文本位置\n  labelPosition: 'bottom',\n  drawShape: function drawShape(cfg, group) {\n    var _a = this.getOptions(cfg),\n        _b = _a.icon,\n        icon = _b === void 0 ? {} : _b,\n        defaultDirection = _a.direction;\n\n    var style = this.getShapeStyle(cfg);\n    var direction = cfg.direction || defaultDirection;\n    var keyShape = group.addShape('path', {\n      attrs: style,\n      className: this.type + \"-keyShape\",\n      name: this.type + \"-keyShape\",\n      draggable: true\n    });\n    var w = icon.width,\n        h = icon.height,\n        show = icon.show,\n        offset = icon.offset,\n        text = icon.text;\n\n    if (show) {\n      if (text) {\n        group.addShape('text', {\n          attrs: (0, _tslib.__assign)({\n            x: 0,\n            y: 0,\n            fontSize: 12,\n            fill: '#000',\n            stroke: '#000',\n            textBaseline: 'middle',\n            textAlign: 'center'\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      } else {\n        var iconW = -w / 2;\n        var iconH = -h / 2;\n\n        if (direction === 'up' || direction === 'down') {\n          iconH += offset;\n        }\n\n        if (direction === 'left' || direction === 'right') {\n          iconW += offset;\n        }\n\n        group.addShape('image', {\n          attrs: (0, _tslib.__assign)({\n            x: iconW,\n            y: iconH\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      }\n    }\n\n    this.drawLinkPoints(cfg, group);\n    return keyShape;\n  },\n\n  /**\n   * 绘制节点上的LinkPoints\n   * @param {Object} cfg data数据配置项\n   * @param {Group} group Group实例\n   */\n  drawLinkPoints: function drawLinkPoints(cfg, group) {\n    var _a = this.getOptions(cfg),\n        _b = _a.linkPoints,\n        linkPoints = _b === void 0 ? {} : _b,\n        defaultDirection = _a.direction;\n\n    var direction = cfg.direction || defaultDirection;\n    var top = linkPoints.top,\n        left = linkPoints.left,\n        right = linkPoints.right,\n        bottom = linkPoints.bottom,\n        markSize = linkPoints.size,\n        markR = linkPoints.r,\n        markStyle = (0, _tslib.__rest)(linkPoints, [\"top\", \"left\", \"right\", \"bottom\", \"size\", \"r\"]);\n    var size = this.getSize(cfg);\n    var len = size[0];\n\n    if (left) {\n      // up down left right 四个方向的坐标均不相同\n      var leftPos = null;\n      var diffY = len * Math.sin(1 / 3 * Math.PI);\n      var r = len * Math.sin(1 / 3 * Math.PI);\n\n      if (direction === 'up') {\n        leftPos = [-r, diffY];\n      } else if (direction === 'down') {\n        leftPos = [-r, -diffY];\n      } else if (direction === 'left') {\n        leftPos = [-r, r - diffY];\n      }\n\n      if (leftPos) {\n        // left circle\n        group.addShape('circle', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n            x: leftPos[0],\n            y: leftPos[1],\n            r: markSize / 2 || markR || 5\n          }),\n          className: 'link-point-left',\n          name: 'link-point-left'\n        });\n      }\n    }\n\n    if (right) {\n      // right circle\n      // up down left right 四个方向的坐标均不相同\n      var rightPos = null;\n      var diffY = len * Math.sin(1 / 3 * Math.PI);\n      var r = len * Math.sin(1 / 3 * Math.PI);\n\n      if (direction === 'up') {\n        rightPos = [r, diffY];\n      } else if (direction === 'down') {\n        rightPos = [r, -diffY];\n      } else if (direction === 'right') {\n        rightPos = [r, r - diffY];\n      }\n\n      if (rightPos) {\n        group.addShape('circle', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n            x: rightPos[0],\n            y: rightPos[1],\n            r: markSize / 2 || markR || 5\n          }),\n          className: 'link-point-right',\n          name: 'link-point-right'\n        });\n      }\n    }\n\n    if (top) {\n      // up down left right 四个方向的坐标均不相同\n      var topPos = null;\n      var diffY = len * Math.sin(1 / 3 * Math.PI);\n      var r = len * Math.sin(1 / 3 * Math.PI);\n\n      if (direction === 'up') {\n        topPos = [r - diffY, -diffY];\n      } else if (direction === 'left') {\n        topPos = [r, -diffY];\n      } else if (direction === 'right') {\n        topPos = [-r, -diffY];\n      }\n\n      if (topPos) {\n        // top circle\n        group.addShape('circle', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n            x: topPos[0],\n            y: topPos[1],\n            r: markSize / 2 || markR || 5\n          }),\n          className: 'link-point-top',\n          name: 'link-point-top'\n        });\n      }\n    }\n\n    if (bottom) {\n      // up down left right 四个方向的坐标均不相同\n      var bottomPos = null;\n      var diffY = len * Math.sin(1 / 3 * Math.PI);\n      var r = len * Math.sin(1 / 3 * Math.PI);\n\n      if (direction === 'down') {\n        bottomPos = [-r + diffY, diffY];\n      } else if (direction === 'left') {\n        bottomPos = [r, diffY];\n      } else if (direction === 'right') {\n        bottomPos = [-r, diffY];\n      }\n\n      if (bottomPos) {\n        // bottom circle\n        group.addShape('circle', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n            x: bottomPos[0],\n            y: bottomPos[1],\n            r: markSize / 2 || markR || 5\n          }),\n          className: 'link-point-bottom',\n          name: 'link-point-bottom'\n        });\n      }\n    }\n  },\n  getPath: function getPath(cfg) {\n    var defaultDirection = this.getOptions(cfg).direction;\n    var direction = cfg.direction || defaultDirection;\n    var size = this.getSize(cfg);\n    var len = size[0];\n    var diffY = len * Math.sin(1 / 3 * Math.PI);\n    var r = len * Math.sin(1 / 3 * Math.PI);\n    var path = [['M', -r, diffY], ['L', 0, -diffY], ['L', r, diffY], ['Z'] // 封闭\n    ];\n\n    if (direction === 'down') {\n      path = [['M', -r, -diffY], ['L', r, -diffY], ['L', 0, diffY], ['Z'] // 封闭\n      ];\n    } else if (direction === 'left') {\n      path = [['M', -r, r - diffY], ['L', r, -r], ['L', r, r], ['Z'] // 封闭\n      ];\n    } else if (direction === 'right') {\n      path = [['M', r, r - diffY], ['L', -r, r], ['L', -r, -r], ['Z'] // 封闭\n      ];\n    }\n\n    return path;\n  },\n\n  /**\n   * 获取节点的样式，供基于该节点自定义时使用\n   * @param {Object} cfg 节点数据模型\n   * @return {Object} 节点的样式\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.getOptions(cfg).style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle);\n    var path = this.getPath(cfg);\n    var styles = (0, _tslib.__assign)({\n      path: path\n    }, style);\n    return styles;\n  },\n  update: function update(cfg, item) {\n    var group = item.getContainer(); // 这里不传 cfg 参数是因为 cfg.style 需要最后覆盖样式\n\n    var defaultStyle = this.getOptions({}).style;\n    var path = this.getPath(cfg); // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\n\n    var strokeStyle = {\n      stroke: cfg.color,\n      path: path\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\n\n    var keyShape = item.get('keyShape');\n    var style = (0, _util.mix)({}, defaultStyle, keyShape.attr(), strokeStyle);\n    style = (0, _util.mix)(style, cfg.style);\n    this.updateShape(cfg, item, style, true);\n    this.updateLinkPoints(cfg, group);\n  },\n\n  /**\n   * 更新linkPoints\n   * @param {Object} cfg 节点数据配置项\n   * @param {Group} group Item所在的group\n   */\n  updateLinkPoints: function updateLinkPoints(cfg, group) {\n    var _a = this.getOptions({}),\n        defaultLinkPoints = _a.linkPoints,\n        defaultDirection = _a.direction;\n\n    var direction = cfg.direction || defaultDirection;\n    var markLeft = group.find(function (element) {\n      return element.get('className') === 'link-point-left';\n    });\n    var markRight = group.find(function (element) {\n      return element.get('className') === 'link-point-right';\n    });\n    var markTop = group.find(function (element) {\n      return element.get('className') === 'link-point-top';\n    });\n    var markBottom = group.find(function (element) {\n      return element.get('className') === 'link-point-bottom';\n    });\n    var currentLinkPoints = defaultLinkPoints;\n    var existLinkPoint = markLeft || markRight || markTop || markBottom;\n\n    if (existLinkPoint) {\n      currentLinkPoints = existLinkPoint.attr();\n    }\n\n    var linkPoints = (0, _util.mix)({}, currentLinkPoints, cfg.linkPoints);\n    var markFill = linkPoints.fill,\n        markStroke = linkPoints.stroke,\n        borderWidth = linkPoints.lineWidth;\n    var markSize = linkPoints.size / 2;\n    if (!markSize) markSize = linkPoints.r;\n\n    var _b = cfg.linkPoints ? cfg.linkPoints : {\n      left: undefined,\n      right: undefined,\n      top: undefined,\n      bottom: undefined\n    },\n        left = _b.left,\n        right = _b.right,\n        top = _b.top,\n        bottom = _b.bottom;\n\n    var size = this.getSize(cfg);\n    var len = size[0];\n    var styles = {\n      r: markSize,\n      fill: markFill,\n      stroke: markStroke,\n      lineWidth: borderWidth\n    };\n    var leftPos = null;\n    var diffY = len * Math.sin(1 / 3 * Math.PI);\n    var r = len * Math.sin(1 / 3 * Math.PI);\n\n    if (direction === 'up') {\n      leftPos = [-r, diffY];\n    } else if (direction === 'down') {\n      leftPos = [-r, -diffY];\n    } else if (direction === 'left') {\n      leftPos = [-r, r - diffY];\n    }\n\n    if (leftPos) {\n      if (markLeft) {\n        if (!left && left !== undefined) {\n          markLeft.remove();\n        } else {\n          markLeft.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n            x: leftPos[0],\n            y: leftPos[1]\n          }));\n        }\n      } else if (left) {\n        group.addShape('circle', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n            x: leftPos[0],\n            y: leftPos[1]\n          }),\n          className: 'link-point-left',\n          name: 'link-point-left',\n          isAnchorPoint: true\n        });\n      }\n    }\n\n    var rightPos = null;\n\n    if (direction === 'up') {\n      rightPos = [r, diffY];\n    } else if (direction === 'down') {\n      rightPos = [r, -diffY];\n    } else if (direction === 'right') {\n      rightPos = [r, r - diffY];\n    }\n\n    if (rightPos) {\n      if (markRight) {\n        if (!right && right !== undefined) {\n          markRight.remove();\n        } else {\n          markRight.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n            x: rightPos[0],\n            y: rightPos[1]\n          }));\n        }\n      } else if (right) {\n        group.addShape('circle', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n            x: rightPos[0],\n            y: rightPos[1]\n          }),\n          className: 'link-point-right',\n          name: 'link-point-right',\n          isAnchorPoint: true\n        });\n      }\n    }\n\n    var topPos = null;\n\n    if (direction === 'up') {\n      topPos = [r - diffY, -diffY];\n    } else if (direction === 'left') {\n      topPos = [r, -diffY];\n    } else if (direction === 'right') {\n      topPos = [-r, -diffY];\n    }\n\n    if (topPos) {\n      if (markTop) {\n        if (!top && top !== undefined) {\n          markTop.remove();\n        } else {\n          // top circle\n          markTop.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n            x: topPos[0],\n            y: topPos[1]\n          }));\n        }\n      } else if (top) {\n        group.addShape('circle', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n            x: topPos[0],\n            y: topPos[1]\n          }),\n          className: 'link-point-top',\n          name: 'link-point-top',\n          isAnchorPoint: true\n        });\n      }\n    }\n\n    var bottomPos = null;\n\n    if (direction === 'down') {\n      bottomPos = [-r + diffY, diffY];\n    } else if (direction === 'left') {\n      bottomPos = [r, diffY];\n    } else if (direction === 'right') {\n      bottomPos = [-r, diffY];\n    }\n\n    if (bottomPos) {\n      if (markBottom) {\n        if (!bottom && bottom !== undefined) {\n          markBottom.remove();\n        } else {\n          markBottom.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n            x: bottomPos[0],\n            y: bottomPos[1]\n          }));\n        }\n      } else if (bottom) {\n        group.addShape('circle', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n            x: bottomPos[0],\n            y: bottomPos[1]\n          }),\n          className: 'link-point-bottom',\n          name: 'link-point-bottom',\n          isAnchorPoint: true\n        });\n      }\n    }\n  }\n}, 'single-node');","\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _f6Core = require(\"@antv/f6-core\");\n\n(0, _f6Core.registerNode)('modelRect', {\n  // 自定义节点时的配置\n  options: {\n    size: [185, 70],\n    style: {\n      radius: 5,\n      stroke: '#69c0ff',\n      fill: '#ffffff',\n      lineWidth: _f6Core.BaseGlobal.defaultNode.style.lineWidth,\n      fillOpacity: 1\n    },\n    // 文本样式配置\n    labelCfg: {\n      style: {\n        fill: '#595959',\n        fontSize: 14\n      },\n      offset: 30 // 距离左侧的 offset，没有设置 y 轴上移动的配置\n\n    },\n    descriptionCfg: {\n      style: {\n        fontSize: 12,\n        fill: '#bfbfbf'\n      },\n      paddingTop: 0\n    },\n    preRect: {\n      show: true,\n      width: 4,\n      fill: '#40a9ff',\n      radius: 2\n    },\n    // 节点上左右上下四个方向上的链接circle配置\n    linkPoints: {\n      top: false,\n      right: false,\n      bottom: false,\n      left: false,\n      // circle的大小\n      size: 10,\n      lineWidth: 1,\n      fill: '#72CC4A',\n      stroke: '#72CC4A'\n    },\n    // 节点中icon配置\n    logoIcon: {\n      // 是否显示icon，值为 false 则不渲染icon\n      show: true,\n      x: 0,\n      y: 0,\n      // icon的地址，字符串类型\n      img: 'https://gw.alipayobjects.com/zos/basement_prod/4f81893c-1806-4de4-aff3-9a6b266bc8a2.svg',\n      width: 16,\n      height: 16,\n      // 用于调整图标的左右位置\n      offset: 0\n    },\n    // 节点中表示状态的icon配置\n    stateIcon: {\n      // 是否显示icon，值为 false 则不渲染icon\n      show: true,\n      x: 0,\n      y: 0,\n      // icon的地址，字符串类型\n      img: 'https://gw.alipayobjects.com/zos/basement_prod/300a2523-67e0-4cbf-9d4a-67c077b40395.svg',\n      width: 16,\n      height: 16,\n      // 用于调整图标的左右位置\n      offset: -5\n    },\n    // 连接点，默认为左右\n    // anchorPoints: [{ x: 0, y: 0.5 }, { x: 1, y: 0.5 }]\n    anchorPoints: [[0, 0.5], [1, 0.5]]\n  },\n  shapeType: 'modelRect',\n  drawShape: function drawShape(cfg, group) {\n    var _a = this.getOptions(cfg).preRect,\n        preRect = _a === void 0 ? {} : _a;\n    var style = this.getShapeStyle(cfg);\n    var size = this.getSize(cfg);\n    var width = size[0];\n    var height = size[1];\n    var keyShape = group.addShape('rect', {\n      attrs: style,\n      className: this.type + \"-keyShape\",\n      name: this.type + \"-keyShape\",\n      draggable: true\n    });\n    var preRectShow = preRect.show,\n        preRectStyle = (0, _tslib.__rest)(preRect, [\"show\"]);\n\n    if (preRectShow) {\n      group.addShape('rect', {\n        attrs: (0, _tslib.__assign)({\n          x: -width / 2,\n          y: -height / 2,\n          height: height\n        }, preRectStyle),\n        className: 'pre-rect',\n        name: 'pre-rect',\n        draggable: true\n      });\n    }\n\n    this.drawLogoIcon(cfg, group);\n    this.drawStateIcon(cfg, group);\n    this.drawLinkPoints(cfg, group);\n    return keyShape;\n  },\n\n  /**\n   * 绘制模型矩形左边的logo图标\n   * @param {Object} cfg 数据配置项\n   * @param {Group} group Group实例\n   */\n  drawLogoIcon: function drawLogoIcon(cfg, group) {\n    var _a = this.getOptions(cfg).logoIcon,\n        logoIcon = _a === void 0 ? {} : _a;\n    var size = this.getSize(cfg);\n    var width = size[0];\n\n    if (logoIcon.show) {\n      var w = logoIcon.width,\n          h = logoIcon.height,\n          x = logoIcon.x,\n          y = logoIcon.y,\n          offset = logoIcon.offset,\n          text = logoIcon.text,\n          logoIconStyle = (0, _tslib.__rest)(logoIcon, [\"width\", \"height\", \"x\", \"y\", \"offset\", \"text\"]);\n\n      if (text) {\n        group.addShape('text', {\n          attrs: (0, _tslib.__assign)({\n            x: 0,\n            y: 0,\n            fontSize: 12,\n            fill: '#000',\n            stroke: '#000',\n            textBaseline: 'middle',\n            textAlign: 'center'\n          }, logoIconStyle),\n          className: 'rect-logo-icon',\n          name: 'rect-logo-icon',\n          draggable: true\n        });\n      } else {\n        group.addShape('image', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, logoIconStyle), {\n            x: x || -width / 2 + w + offset,\n            y: y || -h / 2,\n            width: w,\n            height: h\n          }),\n          className: 'rect-logo-icon',\n          name: 'rect-logo-icon',\n          draggable: true\n        });\n      }\n    }\n  },\n\n  /**\n   * 绘制模型矩形右边的状态图标\n   * @param {Object} cfg 数据配置项\n   * @param {Group} group Group实例\n   */\n  drawStateIcon: function drawStateIcon(cfg, group) {\n    var _a = this.getOptions(cfg).stateIcon,\n        stateIcon = _a === void 0 ? {} : _a;\n    var size = this.getSize(cfg);\n    var width = size[0];\n\n    if (stateIcon.show) {\n      var w = stateIcon.width,\n          h = stateIcon.height,\n          x = stateIcon.x,\n          y = stateIcon.y,\n          offset = stateIcon.offset,\n          text = stateIcon.text,\n          iconStyle = (0, _tslib.__rest)(stateIcon, [\"width\", \"height\", \"x\", \"y\", \"offset\", \"text\"]);\n\n      if (text) {\n        group.addShape('text', {\n          attrs: (0, _tslib.__assign)({\n            x: 0,\n            y: 0,\n            fontSize: 12,\n            fill: '#000',\n            stroke: '#000',\n            textBaseline: 'middle',\n            textAlign: 'center'\n          }, iconStyle),\n          className: 'rect-state-icon',\n          name: 'rect-state-icon',\n          draggable: true\n        });\n      } else {\n        group.addShape('image', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, iconStyle), {\n            x: x || width / 2 - w + offset,\n            y: y || -h / 2,\n            width: w,\n            height: h\n          }),\n          className: 'rect-state-icon',\n          name: 'rect-state-icon',\n          draggable: true\n        });\n      }\n    }\n  },\n\n  /**\n   * 绘制节点上的LinkPoints\n   * @param {Object} cfg data数据配置项\n   * @param {Group} group Group实例\n   */\n  drawLinkPoints: function drawLinkPoints(cfg, group) {\n    var _a = this.getOptions(cfg).linkPoints,\n        linkPoints = _a === void 0 ? {} : _a;\n    var top = linkPoints.top,\n        left = linkPoints.left,\n        right = linkPoints.right,\n        bottom = linkPoints.bottom,\n        markSize = linkPoints.size,\n        markR = linkPoints.r,\n        markStyle = (0, _tslib.__rest)(linkPoints, [\"top\", \"left\", \"right\", \"bottom\", \"size\", \"r\"]);\n    var size = this.getSize(cfg);\n    var width = size[0];\n    var height = size[1];\n\n    if (left) {\n      // left circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: -width / 2,\n          y: 0,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-left',\n        name: 'link-point-left',\n        isAnchorPoint: true\n      });\n    }\n\n    if (right) {\n      // right circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: width / 2,\n          y: 0,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-right',\n        name: 'link-point-right',\n        isAnchorPoint: true\n      });\n    }\n\n    if (top) {\n      // top circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: 0,\n          y: -height / 2,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-top',\n        name: 'link-point-top',\n        isAnchorPoint: true\n      });\n    }\n\n    if (bottom) {\n      // bottom circle\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: 0,\n          y: height / 2,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-bottom',\n        name: 'link-point-bottom',\n        isAnchorPoint: true\n      });\n    }\n  },\n  drawLabel: function drawLabel(cfg, group) {\n    var _a = this.getOptions(cfg),\n        _b = _a.labelCfg,\n        labelCfg = _b === void 0 ? {} : _b,\n        _c = _a.logoIcon,\n        logoIcon = _c === void 0 ? {} : _c,\n        _d = _a.descriptionCfg,\n        descriptionCfg = _d === void 0 ? {} : _d;\n\n    var size = this.getSize(cfg);\n    var width = size[0];\n    var label = null;\n    var show = logoIcon.show,\n        w = logoIcon.width;\n    var offsetX = -width / 2 + labelCfg.offset;\n\n    if (show) {\n      offsetX = -width / 2 + w + labelCfg.offset;\n    }\n\n    var fontStyle = labelCfg.style;\n    var descriptionStyle = descriptionCfg.style,\n        descriptionPaddingTop = descriptionCfg.paddingTop;\n\n    if ((0, _util.isString)(cfg.description)) {\n      label = group.addShape('text', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, fontStyle), {\n          x: offsetX,\n          y: -5,\n          text: cfg.label\n        }),\n        className: 'text-shape',\n        name: 'text-shape',\n        draggable: true\n      });\n      group.addShape('text', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, descriptionStyle), {\n          x: offsetX,\n          y: 17 + (descriptionPaddingTop || 0),\n          text: cfg.description\n        }),\n        className: 'rect-description',\n        name: 'rect-description',\n        draggable: true\n      });\n    } else {\n      label = group.addShape('text', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, fontStyle), {\n          x: offsetX,\n          y: 7,\n          text: cfg.label\n        }),\n        className: 'text-shape',\n        name: 'text-shape',\n        draggable: true\n      });\n    }\n\n    return label;\n  },\n\n  /**\n   * 获取节点的样式，供基于该节点自定义时使用\n   * @param {Object} cfg 节点数据模型\n   * @return {Object} 节点的样式\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.getOptions(cfg).style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle);\n    var size = this.getSize(cfg);\n    var width = style.width || size[0];\n    var height = style.height || size[1];\n    var styles = (0, _tslib.__assign)({\n      x: -width / 2,\n      y: -height / 2,\n      width: width,\n      height: height\n    }, style);\n    return styles;\n  },\n  update: function update(cfg, item) {\n    var _a = this.getOptions(cfg),\n        _b = _a.style,\n        style = _b === void 0 ? {} : _b,\n        _c = _a.labelCfg,\n        labelCfg = _c === void 0 ? {} : _c,\n        _d = _a.descriptionCfg,\n        descriptionCfg = _d === void 0 ? {} : _d;\n\n    var size = this.getSize(cfg);\n    var width = size[0];\n    var height = size[1];\n    var keyShape = item.get('keyShape');\n    keyShape.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, style), {\n      x: -width / 2,\n      y: -height / 2,\n      width: width,\n      height: height\n    }));\n    var group = item.getContainer();\n    var logoIconShape = group.find(function (element) {\n      return element.get('className') === 'rect-logo-icon';\n    });\n    var currentLogoIconAttr = logoIconShape ? logoIconShape.attr() : {};\n    var logoIcon = (0, _util.mix)({}, currentLogoIconAttr, cfg.logoIcon);\n    var w = logoIcon.width;\n\n    if (w === undefined) {\n      w = this.options.logoIcon.width;\n    }\n\n    var show = cfg.logoIcon ? cfg.logoIcon.show : undefined;\n    var offset = labelCfg.offset;\n    var offsetX = -width / 2 + w + offset;\n\n    if (!show && show !== undefined) {\n      offsetX = -width / 2 + offset;\n    }\n\n    var label = group.find(function (element) {\n      return element.get('className') === 'node-label';\n    });\n    var description = group.find(function (element) {\n      return element.get('className') === 'rect-description';\n    });\n\n    if (cfg.label) {\n      if (!label) {\n        group.addShape('text', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, labelCfg.style), {\n            x: offsetX,\n            y: cfg.description ? -5 : 7,\n            text: cfg.label\n          }),\n          className: 'node-label',\n          name: 'node-label',\n          draggable: true\n        });\n      } else {\n        var cfgStyle = cfg.labelCfg ? cfg.labelCfg.style : {};\n        var labelStyle = (0, _util.mix)({}, label.attr(), cfgStyle);\n        if (cfg.label) labelStyle.text = cfg.label;\n        labelStyle.x = offsetX;\n        if ((0, _util.isString)(cfg.description)) labelStyle.y = -5;\n\n        if (description) {\n          description.resetMatrix();\n          description.attr({\n            x: offsetX\n          });\n        }\n\n        label.resetMatrix();\n        label.attr(labelStyle);\n      }\n    }\n\n    if ((0, _util.isString)(cfg.description)) {\n      var paddingTop = descriptionCfg.paddingTop;\n\n      if (!description) {\n        group.addShape('text', {\n          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, descriptionCfg.style), {\n            x: offsetX,\n            y: 17 + (paddingTop || 0),\n            text: cfg.description\n          }),\n          className: 'rect-description',\n          name: 'rect-description',\n          draggable: true\n        });\n      } else {\n        var cfgStyle = cfg.descriptionCfg ? cfg.descriptionCfg.style : {};\n        var descriptionStyle = (0, _util.mix)({}, description.attr(), cfgStyle);\n        if ((0, _util.isString)(cfg.description)) descriptionStyle.text = cfg.description;\n        descriptionStyle.x = offsetX;\n        description.resetMatrix();\n        description.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, descriptionStyle), {\n          y: 17 + (paddingTop || 0)\n        }));\n      }\n    }\n\n    var preRectShape = group.find(function (element) {\n      return element.get('className') === 'pre-rect';\n    });\n\n    if (preRectShape) {\n      var preRect = (0, _util.mix)({}, preRectShape.attr(), cfg.preRect);\n      preRectShape.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, preRect), {\n        x: -width / 2,\n        y: -height / 2,\n        height: height\n      }));\n    }\n\n    if (logoIconShape) {\n      if (!show && show !== undefined) {\n        logoIconShape.remove();\n      } else {\n        var logoW = logoIcon.width,\n            h = logoIcon.height,\n            x = logoIcon.x,\n            y = logoIcon.y,\n            logoOffset = logoIcon.offset,\n            logoIconStyle = (0, _tslib.__rest)(logoIcon, [\"width\", \"height\", \"x\", \"y\", \"offset\"]);\n        logoIconShape.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, logoIconStyle), {\n          x: x || -width / 2 + logoW + logoOffset,\n          y: y || -h / 2,\n          width: logoW,\n          height: h\n        }));\n      }\n    } else if (show) {\n      this.drawLogoIcon(cfg, group);\n    }\n\n    var stateIconShape = group.find(function (element) {\n      return element.get('className') === 'rect-state-icon';\n    });\n    var currentStateIconAttr = stateIconShape ? stateIconShape.attr() : {};\n    var stateIcon = (0, _util.mix)({}, currentStateIconAttr, cfg.stateIcon);\n\n    if (stateIconShape) {\n      if (!stateIcon.show && stateIcon.show !== undefined) {\n        stateIconShape.remove();\n      }\n\n      var stateW = stateIcon.width,\n          h = stateIcon.height,\n          x = stateIcon.x,\n          y = stateIcon.y,\n          stateOffset = stateIcon.offset,\n          stateIconStyle = (0, _tslib.__rest)(stateIcon, [\"width\", \"height\", \"x\", \"y\", \"offset\"]);\n      stateIconShape.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, stateIconStyle), {\n        x: x || width / 2 - stateW + stateOffset,\n        y: y || -h / 2,\n        width: stateW,\n        height: h\n      }));\n    } else if (stateIcon.show) {\n      this.drawStateIcon(cfg, group);\n    }\n\n    this.updateLinkPoints(cfg, group);\n  }\n}, 'single-node');","\n\nvar _tslib = require(\"tslib\");\n\nvar _f6Core = require(\"@antv/f6-core\");\n\nvar _util = require(\"@antv/util\");\n\n// 五角星shape\n(0, _f6Core.registerNode)('star', {\n  // 自定义节点时的配置\n  options: {\n    size: 60,\n    style: {\n      stroke: _f6Core.BaseGlobal.defaultNode.style.stroke,\n      fill: _f6Core.BaseGlobal.defaultNode.style.fill,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.style.lineWidth\n    },\n    labelCfg: {\n      style: {\n        fill: _f6Core.BaseGlobal.nodeLabel.style.fill,\n        fontSize: _f6Core.BaseGlobal.nodeLabel.style.fontSize\n      }\n    },\n    // 节点上左右上下四个方向上的链接circle配置\n    linkPoints: {\n      top: false,\n      right: false,\n      bottom: false,\n      left: false,\n      // circle的大小\n      size: _f6Core.BaseGlobal.defaultNode.linkPoints.size,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.linkPoints.lineWidth,\n      fill: _f6Core.BaseGlobal.defaultNode.linkPoints.fill,\n      stroke: _f6Core.BaseGlobal.defaultNode.linkPoints.stroke\n    },\n    // 节点中icon配置\n    icon: {\n      // 是否显示icon，值为 false 则不渲染icon\n      show: false,\n      // icon的地址，字符串类型\n      img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',\n      width: 20,\n      height: 20\n    },\n    stateStyles: (0, _tslib.__assign)({}, _f6Core.BaseGlobal.nodeStateStyles)\n  },\n  shapeType: 'star',\n  // 文本位置\n  labelPosition: 'center',\n  drawShape: function drawShape(cfg, group) {\n    var _a = this.getOptions(cfg).icon,\n        icon = _a === void 0 ? {} : _a;\n    var style = this.getShapeStyle(cfg);\n    var keyShape = group.addShape('path', {\n      attrs: style,\n      className: this.type + \"-keyShape\",\n      name: this.type + \"-keyShape\",\n      draggable: true\n    });\n    var w = icon.width,\n        h = icon.height,\n        show = icon.show,\n        text = icon.text;\n\n    if (show) {\n      if (text) {\n        group.addShape('text', {\n          attrs: (0, _tslib.__assign)({\n            x: 0,\n            y: 0,\n            fontSize: 12,\n            fill: '#000',\n            stroke: '#000',\n            textBaseline: 'middle',\n            textAlign: 'center'\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      } else {\n        group.addShape('image', {\n          attrs: (0, _tslib.__assign)({\n            x: -w / 2,\n            y: -h / 2\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      }\n    }\n\n    this.drawLinkPoints(cfg, group);\n    return keyShape;\n  },\n\n  /**\n   * 绘制节点上的LinkPoints\n   * @param {Object} cfg data数据配置项\n   * @param {Group} group Group实例\n   */\n  drawLinkPoints: function drawLinkPoints(cfg, group) {\n    var _a = this.getOptions(cfg).linkPoints,\n        linkPoints = _a === void 0 ? {} : _a;\n    var top = linkPoints.top,\n        left = linkPoints.left,\n        right = linkPoints.right,\n        leftBottom = linkPoints.leftBottom,\n        rightBottom = linkPoints.rightBottom,\n        markSize = linkPoints.size,\n        markR = linkPoints.r,\n        markStyle = (0, _tslib.__rest)(linkPoints, [\"top\", \"left\", \"right\", \"leftBottom\", \"rightBottom\", \"size\", \"r\"]);\n    var size = this.getSize(cfg);\n    var outerR = size[0];\n\n    if (right) {\n      // right circle\n      // up down left right 四个方向的坐标均不相同\n      var x1 = Math.cos((18 + 72 * 0) / 180 * Math.PI) * outerR;\n      var y1 = Math.sin((18 + 72 * 0) / 180 * Math.PI) * outerR;\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: x1,\n          y: -y1,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-right',\n        name: 'link-point-right'\n      });\n    }\n\n    if (top) {\n      // up down left right 四个方向的坐标均不相同\n      var x1 = Math.cos((18 + 72 * 1) / 180 * Math.PI) * outerR;\n      var y1 = Math.sin((18 + 72 * 1) / 180 * Math.PI) * outerR; // top circle\n\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: x1,\n          y: -y1,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-top',\n        name: 'link-point-top'\n      });\n    }\n\n    if (left) {\n      // up down left right 四个方向的坐标均不相同\n      var x1 = Math.cos((18 + 72 * 2) / 180 * Math.PI) * outerR;\n      var y1 = Math.sin((18 + 72 * 2) / 180 * Math.PI) * outerR; // left circle\n\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: x1,\n          y: -y1,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-left',\n        name: 'link-point-left'\n      });\n    }\n\n    if (leftBottom) {\n      // up down left right 四个方向的坐标均不相同\n      var x1 = Math.cos((18 + 72 * 3) / 180 * Math.PI) * outerR;\n      var y1 = Math.sin((18 + 72 * 3) / 180 * Math.PI) * outerR; // left bottom circle\n\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: x1,\n          y: -y1,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-left-bottom',\n        name: 'link-point-left-bottom'\n      });\n    }\n\n    if (rightBottom) {\n      // up down left right 四个方向的坐标均不相同\n      var x1 = Math.cos((18 + 72 * 4) / 180 * Math.PI) * outerR;\n      var y1 = Math.sin((18 + 72 * 4) / 180 * Math.PI) * outerR; // left bottom circle\n\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, markStyle), {\n          x: x1,\n          y: -y1,\n          r: markSize / 2 || markR || 5\n        }),\n        className: 'link-point-right-bottom',\n        name: 'link-point-right-bottom'\n      });\n    }\n  },\n  getPath: function getPath(cfg) {\n    var size = this.getSize(cfg);\n    var outerR = size[0];\n    var defaultInnerR = outerR * 3 / 8;\n    var innerR = cfg.innerR || defaultInnerR;\n    var path = [];\n\n    for (var i = 0; i < 5; i++) {\n      var x1 = Math.cos((18 + 72 * i) / 180 * Math.PI) * outerR;\n      var y1 = Math.sin((18 + 72 * i) / 180 * Math.PI) * outerR;\n      var x2 = Math.cos((54 + 72 * i) / 180 * Math.PI) * innerR;\n      var y2 = Math.sin((54 + 72 * i) / 180 * Math.PI) * innerR;\n\n      if (i === 0) {\n        path.push(['M', x1, -y1]);\n      } else {\n        path.push(['L', x1, -y1]);\n      }\n\n      path.push(['L', x2, -y2]);\n    }\n\n    path.push(['Z']);\n    return path;\n  },\n\n  /**\n   * 获取节点的样式，供基于该节点自定义时使用\n   * @param {Object} cfg 节点数据模型\n   * @return {Object} 节点的样式\n   */\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.getOptions(cfg).style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖原来默认的 stroke 属性。但 cfg 中但 stroke 属性优先级更高\n\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle);\n    var path = this.getPath(cfg);\n    var styles = (0, _tslib.__assign)({\n      path: path\n    }, style);\n    return styles;\n  },\n  update: function update(cfg, item) {\n    var group = item.getContainer(); // 这里不传 cfg 参数是因为 cfg.style 需要最后覆盖样式\n\n    var defaultStyle = this.getOptions({}).style;\n    var path = this.getPath(cfg); // 下面这些属性需要覆盖默认样式与目前样式，但若在 cfg 中有指定则应该被 cfg 的相应配置覆盖。\n\n    var strokeStyle = {\n      stroke: cfg.color,\n      path: path\n    }; // 与 getShapeStyle 不同在于，update 时需要获取到当前的 style 进行融合。即新传入的配置项中没有涉及的属性，保留当前的配置。\n\n    var keyShape = item.get('keyShape');\n    var style = (0, _util.mix)({}, defaultStyle, keyShape.attr(), strokeStyle);\n    style = (0, _util.mix)(style, cfg.style);\n    this.updateShape(cfg, item, style, true);\n    this.updateLinkPoints(cfg, group);\n  },\n\n  /**\n   * 更新linkPoints\n   * @param {Object} cfg 节点数据配置项\n   * @param {Group} group Item所在的group\n   */\n  updateLinkPoints: function updateLinkPoints(cfg, group) {\n    var defaultLinkPoints = this.getOptions({}).linkPoints;\n    var markLeft = group.find(function (element) {\n      return element.get('className') === 'link-point-left';\n    });\n    var markRight = group.find(function (element) {\n      return element.get('className') === 'link-point-right';\n    });\n    var markTop = group.find(function (element) {\n      return element.get('className') === 'link-point-top';\n    });\n    var markLeftBottom = group.find(function (element) {\n      return element.get('className') === 'link-point-left-bottom';\n    });\n    var markRightBottom = group.find(function (element) {\n      return element.get('className') === 'link-point-right-bottom';\n    });\n    var currentLinkPoints = defaultLinkPoints;\n    var existLinkPoint = markLeft || markRight || markTop || markLeftBottom || markRightBottom;\n\n    if (existLinkPoint) {\n      currentLinkPoints = existLinkPoint.attr();\n    }\n\n    var linkPoints = (0, _util.mix)({}, currentLinkPoints, cfg.linkPoints);\n    var markFill = linkPoints.fill,\n        markStroke = linkPoints.stroke,\n        borderWidth = linkPoints.lineWidth;\n    var markSize = linkPoints.size / 2;\n    if (!markSize) markSize = linkPoints.r;\n\n    var _a = cfg.linkPoints ? cfg.linkPoints : {\n      left: undefined,\n      right: undefined,\n      top: undefined,\n      leftBottom: undefined,\n      rightBottom: undefined\n    },\n        left = _a.left,\n        right = _a.right,\n        top = _a.top,\n        leftBottom = _a.leftBottom,\n        rightBottom = _a.rightBottom;\n\n    var size = this.getSize(cfg);\n    var outerR = size[0];\n    var styles = {\n      r: markSize,\n      fill: markFill,\n      stroke: markStroke,\n      lineWidth: borderWidth\n    };\n    var x = Math.cos((18 + 72 * 0) / 180 * Math.PI) * outerR;\n    var y = Math.sin((18 + 72 * 0) / 180 * Math.PI) * outerR;\n\n    if (markRight) {\n      if (!right && right !== undefined) {\n        markRight.remove();\n      } else {\n        markRight.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: x,\n          y: -y\n        }));\n      }\n    } else if (right) {\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: x,\n          y: -y\n        }),\n        className: 'link-point-right',\n        name: 'link-point-right',\n        isAnchorPoint: true\n      });\n    }\n\n    x = Math.cos((18 + 72 * 1) / 180 * Math.PI) * outerR;\n    y = Math.sin((18 + 72 * 1) / 180 * Math.PI) * outerR;\n\n    if (markTop) {\n      if (!top && top !== undefined) {\n        markTop.remove();\n      } else {\n        markTop.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: x,\n          y: -y\n        }));\n      }\n    } else if (top) {\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: x,\n          y: -y\n        }),\n        className: 'link-point-top',\n        name: 'link-point-top',\n        isAnchorPoint: true\n      });\n    }\n\n    x = Math.cos((18 + 72 * 2) / 180 * Math.PI) * outerR;\n    y = Math.sin((18 + 72 * 2) / 180 * Math.PI) * outerR;\n\n    if (markLeft) {\n      if (!left && left !== undefined) {\n        markLeft.remove();\n      } else {\n        markLeft.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: x,\n          y: -y\n        }));\n      }\n    } else if (left) {\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: x,\n          y: -y\n        }),\n        className: 'link-point-left',\n        name: 'link-point-left',\n        isAnchorPoint: true\n      });\n    }\n\n    x = Math.cos((18 + 72 * 3) / 180 * Math.PI) * outerR;\n    y = Math.sin((18 + 72 * 3) / 180 * Math.PI) * outerR;\n\n    if (markLeftBottom) {\n      if (!leftBottom && leftBottom !== undefined) {\n        markLeftBottom.remove();\n      } else {\n        markLeftBottom.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: x,\n          y: -y\n        }));\n      }\n    } else if (leftBottom) {\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: x,\n          y: -y\n        }),\n        className: 'link-point-left-bottom',\n        name: 'link-point-left-bottom',\n        isAnchorPoint: true\n      });\n    }\n\n    x = Math.cos((18 + 72 * 4) / 180 * Math.PI) * outerR;\n    y = Math.sin((18 + 72 * 4) / 180 * Math.PI) * outerR;\n\n    if (markRightBottom) {\n      if (!rightBottom && rightBottom !== undefined) {\n        markLeftBottom.remove();\n      } else {\n        markRightBottom.attr((0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: x,\n          y: -y\n        }));\n      }\n    } else if (rightBottom) {\n      group.addShape('circle', {\n        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, styles), {\n          x: x,\n          y: -y\n        }),\n        className: 'link-point-right-bottom',\n        name: 'link-point-right-bottom',\n        isAnchorPoint: true\n      });\n    }\n  }\n}, 'single-node');","\n\nvar _tslib = require(\"tslib\");\n\nvar _f6Core = require(\"@antv/f6-core\");\n\nvar _util = require(\"@antv/util\");\n\nvar defaultSubjectColors = _f6Core.Util.defaultSubjectColors; // 饼图节点\n\n(0, _f6Core.registerNode)('donut', {\n  // 自定义节点时的配置\n  options: {\n    size: _f6Core.BaseGlobal.defaultNode.size,\n    style: {\n      x: 0,\n      y: 0,\n      stroke: _f6Core.BaseGlobal.defaultNode.style.stroke,\n      fill: _f6Core.BaseGlobal.defaultNode.style.fill,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.style.lineWidth\n    },\n    labelCfg: {\n      style: {\n        fill: _f6Core.BaseGlobal.nodeLabel.style.fill,\n        fontSize: _f6Core.BaseGlobal.nodeLabel.style.fontSize\n      }\n    },\n    // 节点上左右上下四个方向上的链接circle配置\n    linkPoints: {\n      top: false,\n      right: false,\n      bottom: false,\n      left: false,\n      // circle的大小\n      size: _f6Core.BaseGlobal.defaultNode.linkPoints.size,\n      lineWidth: _f6Core.BaseGlobal.defaultNode.linkPoints.lineWidth,\n      fill: _f6Core.BaseGlobal.defaultNode.linkPoints.fill,\n      stroke: _f6Core.BaseGlobal.defaultNode.linkPoints.stroke\n    },\n    // 节点中icon配置\n    icon: {\n      // 是否显示icon，值为 false 则不渲染icon\n      show: false,\n      // icon的地址，字符串类型\n      img: 'https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg',\n      width: 20,\n      height: 20\n    },\n    stateStyles: (0, _tslib.__assign)({}, _f6Core.BaseGlobal.nodeStateStyles)\n  },\n  shapeType: 'circle',\n  // 文本位置\n  labelPosition: 'center',\n  drawShape: function drawShape(cfg, group) {\n    var _a = this.getOptions(cfg).icon,\n        defaultIcon = _a === void 0 ? {} : _a;\n    var style = this.getShapeStyle(cfg);\n    var icon = (0, _util.deepMix)({}, defaultIcon, cfg.icon);\n    var keyShape = group.addShape('circle', {\n      attrs: style,\n      className: this.type + \"-keyShape\",\n      draggable: true,\n      name: this.type + \"-keyShape\"\n    });\n    var width = icon.width,\n        height = icon.height,\n        show = icon.show,\n        text = icon.text;\n\n    if (show) {\n      if (text) {\n        group.addShape('text', {\n          attrs: (0, _tslib.__assign)({\n            x: 0,\n            y: 0,\n            fontSize: 12,\n            fill: '#000',\n            stroke: '#000',\n            textBaseline: 'middle',\n            textAlign: 'center'\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      } else {\n        group.addShape('image', {\n          attrs: (0, _tslib.__assign)({\n            x: -width / 2,\n            y: -height / 2\n          }, icon),\n          className: this.type + \"-icon\",\n          name: this.type + \"-icon\",\n          draggable: true\n        });\n      }\n    }\n\n    var donutR = keyShape.attr('r');\n    var innerR = 0.6 * donutR; // 甜甜圈的内环半径\n\n    var arcR = (donutR + innerR) / 2; // 内环半径与外环半径的平均值\n\n    var _b = cfg,\n        _c = _b.donutAttrs,\n        donutAttrs = _c === void 0 ? {} : _c,\n        _d = _b.donutColorMap,\n        donutColorMap = _d === void 0 ? {} : _d;\n    var attrNum = Object.keys(donutAttrs).length;\n\n    if (donutAttrs && attrNum > 1) {\n      var attrs_1 = [];\n      var totalValue_1 = 0;\n      Object.keys(donutAttrs).forEach(function (name) {\n        var value = donutAttrs[name] || 0;\n        if (!(0, _util.isNumber)(value)) return;\n        attrs_1.push({\n          key: name,\n          value: value,\n          color: donutColorMap[name]\n        });\n        totalValue_1 += value;\n      });\n\n      if (totalValue_1) {\n        var lineWidth_1 = donutR - innerR;\n\n        if (attrNum === 1) {\n          group.addShape('circle', {\n            attrs: {\n              r: arcR,\n              x: 0,\n              y: 0,\n              stroke: attrs_1[0].color || defaultSubjectColors[0],\n              lineWidth: lineWidth_1\n            },\n            name: \"fan-shape-0\"\n          });\n          return;\n        }\n\n        var arcBegin_1 = [arcR, 0];\n        var beginAngle_1 = 0;\n        attrs_1.forEach(function (attr, i) {\n          var percent = attr.value / totalValue_1;\n          if (percent < 0.001) return;\n          if (percent > 0.999) percent = 1;\n\n          if (percent === 1) {\n            group.addShape('circle', {\n              attrs: {\n                r: arcR,\n                x: 0,\n                y: 0,\n                stroke: attr.color || defaultSubjectColors[i % defaultSubjectColors.length],\n                lineWidth: lineWidth_1\n              },\n              name: \"fan-shape-\" + i\n            });\n            return;\n          }\n\n          attr.percent = percent;\n          attr.angle = percent * Math.PI * 2;\n          attr.beginAgnle = beginAngle_1;\n          beginAngle_1 += attr.angle;\n          attr.endAngle = beginAngle_1;\n          attr.arcBegin = arcBegin_1;\n          attr.arcEnd = [arcR * Math.cos(attr.endAngle), -arcR * Math.sin(attr.endAngle)];\n          var isBig = attr.angle > Math.PI ? 1 : 0;\n          var path = [['M', attr.arcBegin[0], attr.arcBegin[1]], ['A', arcR, arcR, 0, isBig, 0, attr.arcEnd[0], attr.arcEnd[1]], ['L', attr.arcEnd[0], attr.arcEnd[1]]];\n          group.addShape('path', {\n            attrs: {\n              path: path,\n              lineWidth: lineWidth_1,\n              stroke: attr.color || defaultSubjectColors[i % defaultSubjectColors.length]\n            },\n            name: \"fan-shape-\" + i\n          });\n          arcBegin_1 = attr.arcEnd;\n        });\n      }\n    }\n\n    this.drawLinkPoints(cfg, group);\n    return keyShape;\n  },\n  update: undefined\n}, 'circle');","\n\nrequire(\"./polyline\");","\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _f6Core = require(\"@antv/f6-core\");\n\nvar _polylineUtil = require(\"./polyline-util\");\n\nvar _router = require(\"./router\");\n\n// 折线\n(0, _f6Core.registerEdge)('polyline', {\n  options: {\n    color: _f6Core.BaseGlobal.defaultEdge.color,\n    size: _f6Core.BaseGlobal.defaultEdge.size,\n    style: {\n      radius: 0,\n      offset: 15,\n      x: 0,\n      y: 0,\n      stroke: _f6Core.BaseGlobal.defaultEdge.style.stroke,\n      lineAppendWidth: _f6Core.BaseGlobal.defaultEdge.style.lineAppendWidth\n    },\n    // 文本样式配置\n    labelCfg: {\n      style: {\n        fill: _f6Core.BaseGlobal.edgeLabel.style.fill,\n        fontSize: _f6Core.BaseGlobal.edgeLabel.style.fontSize\n      }\n    },\n    routeCfg: {\n      obstacles: [],\n      maxAllowedDirectionChange: Math.PI,\n      maximumLoops: 500,\n      gridSize: 10 // 指定精度\n\n    },\n    stateStyles: (0, _tslib.__assign)({}, _f6Core.BaseGlobal.edgeStateStyles)\n  },\n  shapeType: 'polyline',\n  // 文本位置\n  labelPosition: 'center',\n  drawShape: function drawShape(cfg, group) {\n    var shapeStyle = this.getShapeStyle(cfg);\n    if (shapeStyle.radius === 0) delete shapeStyle.radius;\n    var keyShape = group.addShape('path', {\n      className: 'edge-shape',\n      name: 'edge-shape',\n      attrs: shapeStyle\n    });\n    return keyShape;\n  },\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.options.style;\n    var strokeStyle = {\n      stroke: cfg.color\n    };\n    var style = (0, _util.mix)({}, defaultStyle, strokeStyle, cfg.style);\n    cfg = this.getPathPoints(cfg);\n    this.radius = style.radius;\n    this.offset = style.offset;\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg);\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var source = cfg.sourceNode;\n    var target = cfg.targetNode;\n    var radius = style.radius;\n    var defaultRouteCfg = this.options.routeCfg;\n    var routeCfg = (0, _util.mix)({}, defaultRouteCfg, cfg.routeCfg);\n    routeCfg.offset = style.offset;\n    var path = this.getPath(points, source, target, radius, routeCfg);\n\n    if ((0, _util.isArray)(path) && path.length <= 1 || (0, _util.isString)(path) && path.indexOf('L') === -1) {\n      path = 'M0 0, L0 0';\n    }\n\n    if (isNaN(startPoint.x) || isNaN(startPoint.y) || isNaN(endPoint.x) || isNaN(endPoint.y)) {\n      path = 'M0 0, L0 0';\n    }\n\n    var attrs = (0, _util.mix)({}, _f6Core.BaseGlobal.defaultEdge.style, style, {\n      lineWidth: cfg.size,\n      path: path\n    });\n    return attrs;\n  },\n  updateShapeStyle: function updateShapeStyle(cfg, item) {\n    var group = item.getContainer();\n    if (!item.isVisible()) return;\n    var strokeStyle = {\n      stroke: cfg.color\n    };\n    var shape = group.find(function (element) {\n      return element.get('className') === 'edge-shape';\n    }) || item.getKeyShape();\n    var size = cfg.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg); // || cfg.controlPoints;\n\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var currentAttr = shape.attr();\n    var previousStyle = (0, _util.mix)({}, strokeStyle, currentAttr, cfg.style);\n    var source = cfg.sourceNode;\n    var target = cfg.targetNode;\n    var radius = previousStyle.radius;\n    var defaultRouteCfg = this.options.routeCfg;\n    var routeCfg = (0, _util.mix)({}, defaultRouteCfg, cfg.routeCfg);\n    routeCfg.offset = previousStyle.offset;\n    var path = this.getPath(points, source, target, radius, routeCfg);\n\n    if ((0, _util.isArray)(path) && path.length <= 1 || (0, _util.isString)(path) && path.indexOf('L') === -1) {\n      path = 'M0 0, L0 0';\n    }\n\n    if (isNaN(startPoint.x) || isNaN(startPoint.y) || isNaN(endPoint.x) || isNaN(endPoint.y)) {\n      path = 'M0 0, L0 0';\n    }\n\n    if (currentAttr.endArrow && previousStyle.endArrow === false) {\n      cfg.style.endArrow = {\n        path: ''\n      };\n    }\n\n    if (currentAttr.startArrow && previousStyle.startArrow === false) {\n      cfg.style.startArrow = {\n        path: ''\n      };\n    }\n\n    var style = (0, _util.mix)(strokeStyle, shape.attr(), {\n      lineWidth: size,\n      path: path\n    }, cfg.style);\n\n    if (shape) {\n      shape.attr(style);\n    }\n  },\n  getPath: function getPath(points, source, target, radius, routeCfg) {\n    var offset = routeCfg.offset,\n        simple = routeCfg.simple; // 指定了控制点\n\n    if (!offset || points.length > 2) {\n      if (radius) {\n        return (0, _polylineUtil.getPathWithBorderRadiusByPolyline)(points, radius);\n      }\n\n      var pathArray_1 = [];\n      (0, _util.each)(points, function (point, index) {\n        if (index === 0) {\n          pathArray_1.push(['M', point.x, point.y]);\n        } else {\n          pathArray_1.push(['L', point.x, point.y]);\n        }\n      });\n      return pathArray_1;\n    } // 未指定控制点\n\n\n    var polylinePoints = simple ? (0, _polylineUtil.getPolylinePoints)(points[points.length - 1], points[0], target, source, offset) : (0, _router.pathFinder)(points[0], points[points.length - 1], source, target, routeCfg);\n    if (!polylinePoints || !polylinePoints.length) return 'M0 0, L0 0';\n\n    if (radius) {\n      var res_1 = (0, _polylineUtil.getPathWithBorderRadiusByPolyline)(polylinePoints, radius);\n      return res_1;\n    }\n\n    var res = _f6Core.Util.pointsToPolygon(polylinePoints);\n\n    return res;\n  }\n}, 'single-edge');","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPolylinePoints = exports.getPathWithBorderRadiusByPolyline = exports.getBorderRadiusPoints = exports.isBending = exports.pathFinder = exports.getNeighborPoints = exports.isSegmentCrossingBBox = exports.isSegmentsIntersected = exports.removeFrom = exports.reconstructPath = exports.heuristicCostEstimate = exports._costByPoints = exports.distance = exports.getBBoxCrossPointsByPoint = exports.getBBoxYCrossPoints = exports.getBBoxXCrossPoints = exports.isPointOutsideBBox = exports.getPointsFromBBox = exports.mergeBBox = exports.getExpandedBBoxPoint = exports.isHorizontalPort = exports.getExpandedBBox = exports.getSimplePolyline = exports.simplifyPolyline = exports.filterConnectPoints = exports.isBBoxesOverlapping = exports.getBBoxFromPoints = exports.getBBoxFromPoint = void 0;\n\nvar getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n      y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\n\nexports.getBBoxFromPoint = getBBoxFromPoint;\n\nvar getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\n\nexports.getBBoxFromPoints = getBBoxFromPoints;\n\nvar isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\n\nexports.isBBoxesOverlapping = isBBoxesOverlapping;\n\nvar filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var pointsMap = {};\n  var pointsLength = points.length;\n\n  for (var i = pointsLength - 1; i >= 0; i--) {\n    var p = points[i];\n    p.id = p.x + \"|||\" + p.y;\n    pointsMap[p.id] = p;\n    result.push(p);\n  }\n\n  return result;\n};\n\nexports.filterConnectPoints = filterConnectPoints;\n\nvar simplifyPolyline = function simplifyPolyline(points) {\n  return filterConnectPoints(points);\n};\n\nexports.simplifyPolyline = simplifyPolyline;\n\nvar getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\n\nexports.getSimplePolyline = getSimplePolyline;\n\nvar getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width || bbox.height) {\n    return {\n      centerX: bbox.centerX,\n      centerY: bbox.centerY,\n      minX: bbox.minX - offset,\n      minY: bbox.minY - offset,\n      maxX: bbox.maxX + offset,\n      maxY: bbox.maxY + offset,\n      height: bbox.height + 2 * offset,\n      width: bbox.width + 2 * offset\n    };\n  } // when it is a point\n\n\n  return bbox;\n};\n\nexports.getExpandedBBox = getExpandedBBox;\n\nvar isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  if (dx === 0 && dy === 0) return 0;\n  return dx / bbox.width > dy / bbox.height;\n};\n\nexports.isHorizontalPort = isHorizontalPort;\n\nvar getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox, // 将原来节点 bbox 扩展了 offset 后的 bbox，且被 gridSize 格式化\npoint, // 被 gridSize 格式化后的位置（anchorPoint）\nanotherPoint) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n\n  if (isHorizontal === 0) {\n    // 说明锚点是节点中心，linkCenter: true。需要根据两个节点的相对关系决定方向\n    var x = bbox.centerX;\n    var y = bbox.centerY;\n\n    if (anotherPoint.y < point.y) {\n      // 另一端在左上/右上方时，总是从上方走\n      y = bbox.minY;\n    } else if (anotherPoint.x > point.x) {\n      // 另一端在右下方，往右边走\n      x = bbox.maxX;\n    } else if (anotherPoint.x < point.x) {\n      // 另一端在左下方，往左边走\n      x = bbox.minX;\n    } else if (anotherPoint.x === point.x) {\n      // 另一段在正下方，往下走\n      y = bbox.maxY;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\n\n\nexports.getExpandedBBoxPoint = getExpandedBBoxPoint;\n\nvar mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\n\nexports.mergeBBox = mergeBBox;\n\nvar getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  // const { minX, minY, maxX, maxY } = bbox;\n  return [{\n    x: bbox.minX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.minY\n  }, {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }, {\n    x: bbox.minX,\n    y: bbox.maxY\n  }];\n};\n\nexports.getPointsFromBBox = getPointsFromBBox;\n\nvar isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n      y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\n\nexports.isPointOutsideBBox = isPointOutsideBBox;\n\nvar getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\n\nexports.getBBoxXCrossPoints = getBBoxXCrossPoints;\n\nvar getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\n\nexports.getBBoxYCrossPoints = getBBoxYCrossPoints;\n\nvar getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\n\n\nexports.getBBoxCrossPointsByPoint = getBBoxCrossPointsByPoint;\n\nvar distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nexports.distance = distance;\n\nvar _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\n\n\nexports._costByPoints = _costByPoints;\n\nvar heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\n\nexports.heuristicCostEstimate = heuristicCostEstimate;\n\nvar reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n\n  pathPoints.unshift(pointById[currentId]);\n\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\n\n\nexports.reconstructPath = reconstructPath;\n\nvar removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\n\nexports.removeFrom = removeFrom;\n\nvar isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var v1x = p2.x - p0.x;\n  var v1y = p2.y - p0.y;\n  var v2x = p3.x - p0.x;\n  var v2y = p3.y - p0.y;\n  var v3x = p2.x - p1.x;\n  var v3y = p2.y - p1.y;\n  var v4x = p3.x - p1.x;\n  var v4y = p3.y - p1.y;\n  var pd1 = v1x * v2y - v1y * v2x;\n  var pd2 = v3x * v4y - v3y * v4x;\n  var pd3 = v1x * v3y - v1y * v3x;\n  var pd4 = v2x * v4y - v2y * v4x;\n  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;\n};\n\nexports.isSegmentsIntersected = isSegmentsIntersected;\n\nvar isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width || bbox.height) {\n    var _a = getPointsFromBBox(bbox),\n        pa = _a[0],\n        pb = _a[1],\n        pc = _a[2],\n        pd = _a[3];\n\n    return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n  }\n\n  return false;\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\n\n\nexports.isSegmentCrossingBBox = isSegmentCrossingBBox;\n\nvar getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p === point) return;\n\n    if (p.x === point.x || p.y === point.y) {\n      if (isSegmentCrossingBBox(p, point, bbox1) || isSegmentCrossingBBox(p, point, bbox2)) return;\n      neighbors.push(p);\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\n\nexports.getNeighborPoints = getNeighborPoints;\n\nvar pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = [start];\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n\n  var fScore = {}; // all default values are Infinity\n\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n  var current, lowestFScore;\n\n  while (openSet.length) {\n    current = undefined;\n    lowestFScore = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    openSet.forEach(function (p) {\n      if (fScore[p.id] <= lowestFScore) {\n        lowestFScore = fScore[p.id];\n        current = p;\n      }\n    }); // 若 openSet 中 fScore 最小的点就是终点\n\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return pathPoints;\n    }\n\n    removeFrom(openSet, current);\n    closedSet.push(current);\n    getNeighborPoints(points, current, sBBox, tBBox).forEach(function (neighbor) {\n      if (closedSet.indexOf(neighbor) !== -1) {\n        return;\n      }\n\n      if (openSet.indexOf(neighbor) === -1) {\n        openSet.push(neighbor);\n      }\n\n      var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n\n      if (gScore[neighbor.id] && tentativeGScore >= gScore[neighbor.id]) {\n        return;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = tentativeGScore;\n      fScore[neighbor.id] = gScore[neighbor.id] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n    });\n  } // throw new Error('Cannot find path');\n\n\n  return [start, goal];\n};\n\nexports.pathFinder = pathFinder;\n\nvar isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\n\nexports.isBending = isBending;\n\nvar getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n\n  if (d0 < r) {\n    r = d0;\n  }\n\n  if (d1 < r) {\n    r = d1;\n  }\n\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\n\nexports.getBorderRadiusPoints = getBorderRadiusPoints;\n\nvar getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\" + startPoint.x + \" \" + startPoint.y);\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n            ps = _a[0],\n            pt = _a[1];\n\n        pathSegments.push(\"L\" + ps.x + \" \" + ps.y);\n        pathSegments.push(\"Q\" + p1.x + \" \" + p1.y + \" \" + pt.x + \" \" + pt.y);\n        pathSegments.push(\"L\" + pt.x + \" \" + pt.y);\n      } else {\n        pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n    }\n  });\n  return pathSegments.join('');\n};\n\nexports.getPathWithBorderRadiusByPolyline = getPathWithBorderRadiusByPolyline;\n\nvar getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sNodeKeyShape = sNode.getKeyShape();\n    sBBox = sNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(start);\n    sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n    sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n  } else {\n    sBBox = sNode.getBBox();\n  }\n\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tKeyShapeBBox = tNode.getKeyShape().getBBox();\n\n    if (tKeyShapeBBox) {\n      var _a = tNode.getModel(),\n          tx = _a.x,\n          ty = _a.y;\n\n      tBBox = {\n        x: tx,\n        y: ty,\n        width: tKeyShapeBBox.width,\n        height: tKeyShapeBBox.height,\n        minX: tKeyShapeBBox.minX + tx,\n        maxX: tKeyShapeBBox.maxX + tx,\n        minY: tKeyShapeBBox.minY + ty,\n        maxY: tKeyShapeBBox.maxY + ty\n      };\n      tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n      tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n    } else {\n      tBBox = getBBoxFromPoint(end);\n    }\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  } // if (isBBoxesOverlapping(sBBox, tBBox)) {\n  //   // source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n\n\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset); // if (isBBoxesOverlapping(sxBBox, txBBox)) {\n  //   // the expanded bounding boxes of source and target nodes are overlapping\n  //   return simplifyPolyline(getSimplePolyline(start, end));\n  // }\n\n  var sPoint = getExpandedBBoxPoint(sxBBox, start, end);\n  var tPoint = getExpandedBBoxPoint(txBBox, end, start);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n        connectPoints.push(p);\n      }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint); // filter out dulplicated points in connectPoints\n\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};\n\nexports.getPolylinePoints = getPolylinePoints;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.pathFinder = exports.octolinearCfg = void 0;\n\nvar _f6Core = require(\"@antv/f6-core\");\n\nvar _util = require(\"@antv/util\");\n\nvar _polylineUtil = require(\"./polyline-util\");\n\n/**\n * 通过配置不同的 costFunc, distFunc, constraints 可以得到不同效果的 router\n * generalRouter: 不限制搜索时的移动方向，避开障碍即可\n * orthogonal: 线必须沿着竖直或水平方向（4个方向）\n * octolinearRouter: 线沿着竖直、水平、对角线方向（8个方向）\n */\nvar manhattanDist = function manhattanDist(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n\nvar eucliDist = function eucliDist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nvar straightPath = function straightPath(start, end) {\n  // console.warn('fallbackRoute: straight path');\n  return [start, end];\n};\n\nvar simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {\n  return (0, _polylineUtil.simplifyPolyline)((0, _polylineUtil.getPolylinePoints)(start, end, startNode, endNode, cfg.offset));\n}; // getPolylinePoints\n\n\nvar defaultCfg = {\n  offset: 20,\n  maxAllowedDirectionChange: Math.PI / 2,\n  maximumLoops: 2000,\n  gridSize: 10,\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: -1\n  } // top\n  ],\n\n  get penalties() {\n    return {\n      0: 0,\n      45: this.gridSize / 2,\n      90: this.gridSize / 2\n    };\n  },\n\n  distFunc: manhattanDist,\n  fallbackRoute: simplePolyline\n};\nvar octolinearCfg = {\n  maxAllowedDirectionChange: Math.PI / 4,\n  // 8 个方向: 上下左右 + 45度斜线方向\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: 1,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: -1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }, {\n    stepX: 1,\n    stepY: -1\n  }],\n  distFunc: eucliDist,\n  fallbackRoute: straightPath\n};\nexports.octolinearCfg = octolinearCfg;\n\nvar pos2GridIx = function pos2GridIx(pos, gridSize) {\n  var gridIx = Math.round(Math.abs(pos / gridSize));\n  var sign = pos < 0 ? -1 : 1;\n  return gridIx < 0 ? 0 : sign * gridIx;\n};\n\nvar getObstacleMap = function getObstacleMap(items, gridSize, offset) {\n  var map = {};\n  items.forEach(function (item) {\n    // create-edge 时，当边类型为 polyline 时 endNode 为 null\n    if (!item) return;\n    var bbox = (0, _polylineUtil.getExpandedBBox)(item.getBBox(), offset);\n\n    for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {\n      for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {\n        map[x + \"|||\" + y] = true;\n      }\n    }\n  });\n  return map;\n};\n/**\n * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）\n * @param p1 PolyPoint\n * @param p2 PolyPoint\n */\n\n\nvar getDirectionAngle = function getDirectionAngle(p1, p2) {\n  var deltaX = p2.x - p1.x;\n  var deltaY = p2.y - p1.y;\n\n  if (deltaX || deltaY) {\n    return Math.atan2(deltaY, deltaX);\n  }\n\n  return 0;\n};\n/**\n * 方向角的改变，取小于180度角\n * @param angle1\n * @param angle2\n */\n\n\nvar getAngleDiff = function getAngleDiff(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange; // return directionChange > 180 ? 360 - directionChange : directionChange;\n}; // Path finder //\n\n\nvar estimateCost = function estimateCost(from, endPoints, distFunc) {\n  var min = Infinity;\n\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = distFunc(from, endPoints[i]);\n\n    if (cost < min) {\n      min = cost;\n    }\n  }\n\n  return min;\n}; // 计算考虑 offset 后的 BBox 上的连接点\n\n\nvar getBoxPoints = function getBoxPoints(point, // 被 gridSize 格式化后的位置（anchorPoint）\noriPoint, // 未被 gridSize 格式化的位置（anchorPoint）\nnode, // 原始节点，用于获取 bbox\nanotherPoint, // 另一端被 gridSize 格式化后的位置\ncfg) {\n  var points = []; // create-edge 生成边的过程中，endNode 为 null\n\n  if (!node) {\n    return [point];\n  }\n\n  var directions = cfg.directions,\n      offset = cfg.offset;\n  var bbox = node.getBBox();\n  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;\n  var expandBBox = (0, _polylineUtil.getExpandedBBox)(bbox, offset);\n\n  for (var i in expandBBox) {\n    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);\n  }\n\n  if (isInside) {\n    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点\n    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n      var dir = directions_1[_i];\n      var bounds = [[{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }]];\n\n      for (var i = 0; i < 4; i++) {\n        var boundLine = bounds[i];\n\n        var insterctP_1 = _f6Core.Util.getLineIntersect(point, {\n          x: point.x + dir.stepX * expandBBox.width,\n          y: point.y + dir.stepY * expandBBox.height\n        }, boundLine[0], boundLine[1]);\n\n        if (insterctP_1 && !(0, _polylineUtil.isSegmentCrossingBBox)(point, insterctP_1, bbox)) {\n          insterctP_1.id = insterctP_1.x + \"|||\" + insterctP_1.y;\n          points.push(insterctP_1);\n        }\n      }\n    }\n\n    return points;\n  } // 如果 anchorPoint 在节点上，只有一个可选方向\n\n\n  var insterctP = (0, _polylineUtil.getExpandedBBoxPoint)(expandBBox, point, anotherPoint);\n  insterctP.id = insterctP.x + \"|||\" + insterctP.y;\n  return [insterctP];\n};\n\nvar getDirectionChange = function getDirectionChange(current, neighbor, cameFrom, scaleStartPoint) {\n  var directionAngle = getDirectionAngle(current, neighbor);\n\n  if (!cameFrom[current.id]) {\n    var startAngle = getDirectionAngle(scaleStartPoint, current);\n    return getAngleDiff(startAngle, directionAngle);\n  }\n\n  var prevDirectionAngle = getDirectionAngle({\n    x: cameFrom[current.id].x,\n    y: cameFrom[current.id].y\n  }, current);\n  return getAngleDiff(prevDirectionAngle, directionAngle);\n};\n\nvar getControlPoints = function getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize) {\n  var controlPoints = [endPoint];\n  var currentId = current.id;\n  var currentX = current.x;\n  var currentY = current.y;\n  var lastPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  };\n\n  if (getDirectionChange(lastPoint, scaleEndPoint, cameFrom, scaleStartPoint)) {\n    // if (scaleEndPoint.x === endPoint.x && scaleEndPoint.y === endPoint.y)\n    //   controlPoints.unshift({\n    //     x: endPoint.x,\n    //     y: endPoint.y\n    //   })\n    // else\n    //   controlPoints.unshift({\n    //     x: lastPoint.x * gridSize,\n    //     y: lastPoint.y * gridSize,\n    //   });\n    controlPoints.unshift({\n      x: scaleEndPoint.x === endPoint.x ? endPoint.x : lastPoint.x * gridSize,\n      y: scaleEndPoint.y === endPoint.y ? endPoint.y : lastPoint.y * gridSize\n    });\n  }\n\n  while (cameFrom[currentId] && cameFrom[currentId].id !== currentId) {\n    var point = {\n      x: currentX,\n      y: currentY,\n      id: currentId\n    };\n    var preId = cameFrom[currentId].id;\n    var preX = cameFrom[currentId].x;\n    var preY = cameFrom[currentId].y;\n    var prePoint = {\n      x: preX,\n      y: preY,\n      id: preId\n    };\n    var directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);\n\n    if (directionChange) {\n      // if (prePoint.x === point.x && prePoint.y === point.y)\n      //   controlPoints.unshift({\n      //     x: controlPoints[0].x,\n      //     y: controlPoints[0].y\n      //   })\n      // else\n      //   controlPoints.unshift({\n      //     x: prePoint.x * gridSize,\n      //     y: prePoint.y * gridSize,\n      //   });\n      controlPoints.unshift({\n        x: prePoint.x === point.x ? controlPoints[0].x : prePoint.x * gridSize,\n        y: prePoint.y === point.y ? controlPoints[0].y : prePoint.y * gridSize\n      });\n    }\n\n    currentId = preId;\n    currentX = preX;\n    currentY = preY;\n  } // 和startNode对齐\n\n\n  var firstPoint = {\n    x: currentX,\n    y: currentY,\n    id: currentId\n  }; // if (firstPoint.x === scaleStartPoint.x && firstPoint.y === scaleStartPoint.y) {\n  //   controlPoints[0].x = startPoint.x;\n  //   controlPoints[0].y = startPoint.y;\n  // }\n\n  controlPoints[0].x = firstPoint.x === scaleStartPoint.x ? startPoint.x : controlPoints[0].x;\n  controlPoints[0].y = firstPoint.y === scaleStartPoint.y ? startPoint.y : controlPoints[0].y;\n  controlPoints.unshift(startPoint);\n  return controlPoints;\n};\n\nvar pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {\n  if (isNaN(startPoint.x) || isNaN(endPoint.x)) return [];\n  var cfg = (0, _util.deepMix)(defaultCfg, routerCfg);\n  cfg.obstacles = cfg.obstacles || [];\n  var gridSize = cfg.gridSize;\n  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), gridSize, cfg.offset);\n  var scaleStartPoint = {\n    x: pos2GridIx(startPoint.x, gridSize),\n    y: pos2GridIx(startPoint.y, gridSize)\n  };\n  var scaleEndPoint = {\n    x: pos2GridIx(endPoint.x, gridSize),\n    y: pos2GridIx(endPoint.y, gridSize)\n  };\n  startPoint.id = scaleStartPoint.x + \"|||\" + scaleStartPoint.y;\n  endPoint.id = scaleEndPoint.x + \"|||\" + scaleEndPoint.y;\n  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);\n  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);\n  startPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  endPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  var openSet = {};\n  var closedSet = {};\n  var cameFrom = {}; // 从起点到当前点已产生的 cost, default: Infinity\n\n  var gScore = {}; // 起点经过当前点到达终点预估的 cost, default: Infinity\n\n  var fScore = {}; // initialize\n\n  for (var i = 0; i < startPoints.length; i++) {\n    var firstStep = startPoints[i];\n    openSet[firstStep.id] = firstStep; // cameFrom[firstStep.id] = startPoint.id;\n\n    gScore[firstStep.id] = 0;\n    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);\n  }\n\n  var remainLoops = cfg.maximumLoops;\n  var penalties = cfg.penalties;\n  var current, curCost, direction, neighbor, neighborCost, costFromStart, directionChange;\n\n  while (Object.keys(openSet).length > 0 && remainLoops > 0) {\n    current = undefined;\n    curCost = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    Object.keys(openSet).forEach(function (key) {\n      var id = openSet[key].id;\n\n      if (fScore[id] <= curCost) {\n        curCost = fScore[id];\n        current = openSet[id];\n      }\n    });\n    if (!current) break; // 如果 fScore 最小的点就是终点\n\n    if (endPoints.findIndex(function (point) {\n      return point.x === current.x && point.y === current.y;\n    }) > -1) {\n      return getControlPoints(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize);\n    }\n\n    delete openSet[current.id];\n    closedSet[current.id] = true; // 获取符合条件的下一步的候选连接点\n    // 沿候选方向走一步\n\n    for (var i = 0; i < cfg.directions.length; i++) {\n      direction = cfg.directions[i];\n      neighbor = {\n        x: current.x + direction.stepX,\n        y: current.y + direction.stepY,\n        id: Math.round(current.x) + direction.stepX + \"|||\" + (Math.round(current.y) + direction.stepY)\n      };\n      if (closedSet[neighbor.id]) continue;\n      directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);\n      if (directionChange > cfg.maxAllowedDirectionChange) continue;\n      if (map[neighbor.id]) continue; // 如果交叉则跳过\n      // 将候选点加入 openSet, 并计算每个候选点的 cost\n\n      if (!openSet[neighbor.id]) {\n        openSet[neighbor.id] = neighbor;\n      }\n\n      neighborCost = cfg.distFunc(current, neighbor) + (isNaN(penalties[directionChange]) ? gridSize : penalties[directionChange]);\n      costFromStart = gScore[current.id] + neighborCost;\n\n      if (gScore[neighbor.id] && costFromStart >= gScore[neighbor.id]) {\n        continue;\n      }\n\n      cameFrom[neighbor.id] = current;\n      gScore[neighbor.id] = costFromStart;\n      fScore[neighbor.id] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);\n    }\n\n    remainLoops -= 1;\n  }\n\n  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);\n};\n\nexports.pathFinder = pathFinder;"]}