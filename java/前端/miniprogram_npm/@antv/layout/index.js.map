{"version":3,"sources":["index.js","registy/index.js","layout/base.js","util/index.js","util/string.js","util/array.js","util/number.js","util/math.js","util/object.js","util/function.js","layout/index.js","layout/grid.js","layout/random.js","layout/gForce.js","layout/force/index.js","layout/force/force.js","layout/force/force-in-a-box.js","layout/constants.js","layout/circular.js","layout/dagre.js","layout/radial/index.js","layout/radial/radial.js","layout/radial/mds.js","layout/radial/radialNonoverlapForce.js","layout/concentric.js","layout/mds.js","layout/fruchterman.js","layout/gpu/fruchterman.js","util/gpu.js","layout/gpu/fruchtermanShader.js","layout/gpu/gForce.js","layout/gpu/gForceShader.js","layout/comboForce.js","layout/forceAtlas2/index.js","layout/forceAtlas2/body.js","layout/forceAtlas2/quad.js","layout/forceAtlas2/quadTree.js","layout/layout.js","layout/types.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA;AHUA,AENA,ADGA,AENA,ACHA;AJaA,AENA,ADGA,AENA,ACHA;AJaA,AENA,ADGA,AENA,ACHA;AJaA,AENA,ADGA,AIZA,AFMA,ACHA;AJaA,AENA,ADGA,AIZA,AFMA,ACHA;AJaA,AENA,ADGA,AIZA,AFMA,ACHA;AJaA,AENA,ADGA,AIZA,AFMA,AGTA,AFMA;AJaA,AENA,ADGA,AIZA,AFMA,AGTA,AFMA;AFOA,ADGA,AENA,AGTA,AFMA;AFOA,ADGA,AENA,AIZA,ADGA,AFMA;AFOA,ADGA,AENA,AIZA,ADGA,AFMA;AFOA,ADGA,AENA,AIZA,ADGA,AFMA;AFOA,ADGA,AENA,AIZA,ADGA,AENA,AJYA;AFOA,ADGA,AENA,AIZA,ADGA,AENA,AJYA;AFOA,ADGA,AENA,AIZA,ADGA,AENA,AJYA;AFOA,ADGA,AQxBA,ANkBA,AIZA,ADGA,AENA,AJYA;AFOA,ADGA,AQxBA,AFMA,ADGA,AENA,AJYA;AFOA,ADGA,AQxBA,AFMA,ADGA,AENA,AJYA;AFOA,AQxBA,AT2BA,AQxBA,AFMA,ADGA,AENA,AJYA;AFOA,AQxBA,AT2BA,AQxBA,AFMA,ACHA,AJYA;AFOA,AQxBA,AT2BA,AQxBA,AFMA,ACHA;ANmBA,AS3BA,ADGA,AT2BA,AQxBA,AFMA,ACHA;ANmBA,AS3BA,ADGA,AT2BA,AQxBA,AFMA,ACHA;ANmBA,AS3BA,ADGA,AT2BA,AMlBA,ACHA;ANmBA,AS3BA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,AS3BA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,AS3BA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,AWjCA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,AWjCA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,AWjCA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,AYpCA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,AYpCA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,AYpCA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,AavCA,ADGA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,AavCA,ADGA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,AavCA,ADGA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,Ac1CA,ADGA,ADGA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,Ac1CA,ADGA,ADGA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;ANmBA,Ac1CA,ADGA,ADGA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;AS1BA,ADGA,ADGA,ADGA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;AS1BA,ADGA,ADGA,ADGA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;AS1BA,ADGA,ADGA,ADGA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,ADGA,ADGA,ADGA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,ADGA,ADGA,ADGA,ADGA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,ADGA,ADGA,AFMA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,AENA,AHSA,ADGA,AFMA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,AENA,AHSA,ADGA,AFMA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,AENA,AHSA,ADGA,AFMA,AFMA,ADGA,AENA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,AENA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,ARwBA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,AENA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,ARwBA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,AENA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,ARwBA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,AENA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,ACHA,AT2BA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,AENA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,ACHA,AT2BA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,AENA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,ACHA,AT2BA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,AENA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,AENA,ADGA,AT2BA,AXiCA,AMlBA,ACHA;AU7BA,ADGA,AENA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,AENA,ADGA,AT2BA,ALeA;AWhCA,ACHA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,AENA,ADGA,AT2BA,ALeA;AWhCA,ACHA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,AENA,ADGA,AENA,AXiCA,ALeA;AWhCA,ACHA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,AENA,ADGA,AENA,AXiCA,ALeA;AWhCA,ACHA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,AENA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,AENA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AFMA,AFMA,ADGA,AU9BA,AENA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AFMA,AFMA,ADGA,AYpCA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AFMA,AFMA,ADGA,Ae7CA,AHSA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AFMA,AFMA,ADGA,Ae7CA,AHSA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AFMA,AFMA,Ac1CA,AHSA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,AFMA,Ac1CA,AHSA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,AFMA,Ac1CA,AHSA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,AFMA,Ac1CA,AHSA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AhBgDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AhBgDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AhBgDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,ALeA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AhBgDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AhBgDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AhBgDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AENA,AlBsDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AENA,AlBsDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AENA,AlBsDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AENA,ACHA,AnByDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AENA,ACHA,AnByDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AENA,ACHA,AnByDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AENA,ACHA,ACHA,ApB4DA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AENA,ACHA,ACHA,ApB4DA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,AMlBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AGTA,ACHA,ApB4DA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AGTA,ACHA,ApB4DA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AGTA,ACHA,ApB4DA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AWjCA,AbuCA,Ac1CA,AGTA,ACHA,ApB4DA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,ACHA,ApB4DA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,ACHA,ApB4DA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,AT2BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,AT2BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,AT2BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AHSA,ADGA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AXiCA,A0B9EA,AV8BA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AXiCA,A0B9EA,AV8BA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AXiCA,A0B9EA,AV8BA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AXiCA,AgBhDA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA,ArB+DA;AWhCA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,A0B9EA,AZoCA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AmBzDA,ADGA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AENA,AKfA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AENA,ACHA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,AGTA,AV8BA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,Ac1CA,AJYA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ALeA,AHSA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,ARwBA,ARwBA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA,AOrBA;AV+BA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AHUA,Ac1CA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AnByDA,AU9BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,APqBA,AbuCA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AhBgDA,ADGA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,AjBmDA,AkBtDA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,ACHA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,ACHA,ApB4DA,Ac1CA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,ANkBA,AGTA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA,AT2BA;AWhCA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getLayoutByName = exports.unRegisterLayout = exports.registerLayout = void 0;\nvar registy_1 = require(\"./registy\");\nObject.defineProperty(exports, \"registerLayout\", { enumerable: true, get: function () { return registy_1.registerLayout; } });\nObject.defineProperty(exports, \"unRegisterLayout\", { enumerable: true, get: function () { return registy_1.unRegisterLayout; } });\nObject.defineProperty(exports, \"getLayoutByName\", { enumerable: true, get: function () { return registy_1.getLayoutByName; } });\n// layout, layout types file, worker\n__exportStar(require(\"./layout\"), exports);\n//# sourceMappingURL=index.js.map","\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getLayoutByName = exports.unRegisterLayout = exports.registerLayout = void 0;\nvar base_1 = require(\"../layout/base\");\nvar util_1 = require(\"../util\");\nvar map = new Map();\nvar registerLayout = function (name, layoutOverride) {\n    if (map.get(name)) {\n        console.warn(\"The layout with the name \" + name + \" exists already, it will be overridden\");\n    }\n    if (util_1.isObject(layoutOverride)) {\n        // tslint:disable-next-line: max-classes-per-file\n        var GLayout = /** @class */ (function (_super) {\n            __extends(GLayout, _super);\n            function GLayout(cfg) {\n                var _this = _super.call(this) || this;\n                var self = _this;\n                var props = {};\n                var defaultCfg = self.getDefaultCfg();\n                Object.assign(props, defaultCfg, layoutOverride, cfg);\n                Object.keys(props).forEach(function (key) {\n                    var value = props[key];\n                    self[key] = value;\n                });\n                return _this;\n            }\n            return GLayout;\n        }(base_1.Base));\n        map.set(name, GLayout);\n    }\n    else {\n        map.set(name, layoutOverride);\n    }\n};\nexports.registerLayout = registerLayout;\nvar unRegisterLayout = function (name) {\n    if (map.has(name)) {\n        map.delete(name);\n    }\n};\nexports.unRegisterLayout = unRegisterLayout;\nvar getLayoutByName = function (name) {\n    if (map.has(name)) {\n        return map.get(name);\n    }\n    return null;\n};\nexports.getLayoutByName = getLayoutByName;\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Base = void 0;\nvar Base = /** @class */ (function () {\n    function Base() {\n        this.nodes = [];\n        this.edges = [];\n        this.combos = [];\n        this.positions = [];\n        this.destroyed = false;\n        this.onLayoutEnd = function () { };\n    }\n    Base.prototype.layout = function (data) {\n        this.init(data);\n        return this.execute(true);\n    };\n    Base.prototype.init = function (data) {\n        this.nodes = data.nodes || [];\n        this.edges = data.edges || [];\n        this.combos = data.combos || [];\n    };\n    Base.prototype.execute = function (reloadData) { };\n    Base.prototype.executeWithWorker = function () { };\n    Base.prototype.getDefaultCfg = function () {\n        return {};\n    };\n    Base.prototype.updateCfg = function (cfg) {\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    };\n    Base.prototype.getType = function () {\n        return 'base';\n    };\n    Base.prototype.destroy = function () {\n        this.nodes = null;\n        this.edges = null;\n        this.combos = null;\n        this.positions = null;\n        this.destroyed = true;\n    };\n    return Base;\n}());\nexports.Base = Base;\n//# sourceMappingURL=base.js.map","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./string\"), exports);\n__exportStar(require(\"./array\"), exports);\n__exportStar(require(\"./number\"), exports);\n__exportStar(require(\"./math\"), exports);\n__exportStar(require(\"./object\"), exports);\n__exportStar(require(\"./function\"), exports);\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.camelize = exports.isString = void 0;\nvar isString = function (val) { return typeof val === 'string'; };\nexports.isString = isString;\nvar cacheStringFunction = function (fn) {\n    var cache = Object.create(null);\n    return (function (str) {\n        var hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    });\n};\nvar camelizeRE = /-(\\w)/g;\nexports.camelize = cacheStringFunction(function (str) {\n    return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });\n});\n// export const capitalize = cacheStringFunction(\n//   (str: string) => str.charAt(0).toUpperCase() + str.slice(1),\n// )\n//# sourceMappingURL=string.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isArray = void 0;\nexports.isArray = Array.isArray;\n//# sourceMappingURL=array.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toNumber = exports.isNaN = exports.isNumber = void 0;\nvar isNumber = function (val) { return typeof val === 'number'; };\nexports.isNumber = isNumber;\nvar isNaN = function (num) { return Number.isNaN(Number(num)); };\nexports.isNaN = isNaN;\nvar toNumber = function (val) {\n    var n = parseFloat(val);\n    return exports.isNaN(n) ? val : n;\n};\nexports.toNumber = toNumber;\n//# sourceMappingURL=number.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.traverseTreeUp = exports.scaleMatrix = exports.getAdjMatrix = exports.floydWarshall = exports.getDegree = void 0;\nvar getDegree = function (n, nodeIdxMap, edges) {\n    var degrees = [];\n    for (var i = 0; i < n; i++) {\n        degrees[i] = 0;\n    }\n    if (!edges)\n        return degrees;\n    edges.forEach(function (e) {\n        if (e.source) {\n            degrees[nodeIdxMap[e.source]] += 1;\n        }\n        if (e.target) {\n            degrees[nodeIdxMap[e.target]] += 1;\n        }\n    });\n    return degrees;\n};\nexports.getDegree = getDegree;\nvar floydWarshall = function (adjMatrix) {\n    // initialize\n    var dist = [];\n    var size = adjMatrix.length;\n    for (var i = 0; i < size; i += 1) {\n        dist[i] = [];\n        for (var j = 0; j < size; j += 1) {\n            if (i === j) {\n                dist[i][j] = 0;\n            }\n            else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n                dist[i][j] = Infinity;\n            }\n            else {\n                dist[i][j] = adjMatrix[i][j];\n            }\n        }\n    }\n    // floyd\n    for (var k = 0; k < size; k += 1) {\n        for (var i = 0; i < size; i += 1) {\n            for (var j = 0; j < size; j += 1) {\n                if (dist[i][j] > dist[i][k] + dist[k][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n    return dist;\n};\nexports.floydWarshall = floydWarshall;\nvar getAdjMatrix = function (data, directed) {\n    var nodes = data.nodes, edges = data.edges;\n    var matrix = [];\n    // map node with index in data.nodes\n    var nodeMap = {};\n    if (!nodes) {\n        throw new Error('invalid nodes data!');\n    }\n    if (nodes) {\n        nodes.forEach(function (node, i) {\n            nodeMap[node.id] = i;\n            var row = [];\n            matrix.push(row);\n        });\n    }\n    if (edges) {\n        edges.forEach(function (e) {\n            var source = e.source, target = e.target;\n            var sIndex = nodeMap[source];\n            var tIndex = nodeMap[target];\n            matrix[sIndex][tIndex] = 1;\n            if (!directed) {\n                matrix[tIndex][sIndex] = 1;\n            }\n        });\n    }\n    return matrix;\n};\nexports.getAdjMatrix = getAdjMatrix;\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\nvar scaleMatrix = function (matrix, ratio) {\n    var result = [];\n    matrix.forEach(function (row) {\n        var newRow = [];\n        row.forEach(function (v) {\n            newRow.push(v * ratio);\n        });\n        result.push(newRow);\n    });\n    return result;\n};\nexports.scaleMatrix = scaleMatrix;\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\nvar traverseUp = function (data, fn) {\n    if (data && data.children) {\n        for (var i = data.children.length - 1; i >= 0; i--) {\n            if (!traverseUp(data.children[i], fn))\n                return;\n        }\n    }\n    if (!fn(data)) {\n        return false;\n    }\n    return true;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\nvar traverseTreeUp = function (data, fn) {\n    if (typeof fn !== 'function') {\n        return;\n    }\n    traverseUp(data, fn);\n};\nexports.traverseTreeUp = traverseTreeUp;\n//# sourceMappingURL=math.js.map","\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clone = exports.isObject = void 0;\nvar isObject = function (val) {\n    return val !== null && typeof val === 'object';\n};\nexports.isObject = isObject;\nvar clone = function (target) {\n    if (target === null) {\n        return target;\n    }\n    if (target instanceof Date) {\n        return new Date(target.getTime());\n    }\n    if (target instanceof Array) {\n        var cp_1 = [];\n        target.forEach(function (v) {\n            cp_1.push(v);\n        });\n        return cp_1.map(function (n) { return exports.clone(n); });\n    }\n    if (typeof target === 'object' && target !== {}) {\n        var cp_2 = __assign({}, target);\n        Object.keys(cp_2).forEach(function (k) {\n            cp_2[k] = exports.clone(cp_2[k]);\n        });\n        return cp_2;\n    }\n    return target;\n};\nexports.clone = clone;\n//# sourceMappingURL=object.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isFunction = void 0;\nvar isFunction = function (val) {\n    return typeof val === 'function';\n};\nexports.isFunction = isFunction;\n//# sourceMappingURL=function.js.map","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ForceAtlas2Layout = exports.ComboForceLayout = exports.GForceGPULayout = exports.FruchtermanGPULayout = exports.FruchtermanLayout = exports.MDSLayout = exports.ConcentricLayout = exports.RadialLayout = exports.DagreLayout = exports.CircularLayout = exports.ForceLayout = exports.GForceLayout = exports.RandomLayout = exports.GridLayout = exports.Layouts = exports.Layout = void 0;\nvar grid_1 = require(\"./grid\");\nObject.defineProperty(exports, \"GridLayout\", { enumerable: true, get: function () { return grid_1.GridLayout; } });\nvar random_1 = require(\"./random\");\nObject.defineProperty(exports, \"RandomLayout\", { enumerable: true, get: function () { return random_1.RandomLayout; } });\nvar gForce_1 = require(\"./gForce\");\nObject.defineProperty(exports, \"GForceLayout\", { enumerable: true, get: function () { return gForce_1.GForceLayout; } });\nvar force_1 = require(\"./force\");\nObject.defineProperty(exports, \"ForceLayout\", { enumerable: true, get: function () { return force_1.ForceLayout; } });\nvar circular_1 = require(\"./circular\");\nObject.defineProperty(exports, \"CircularLayout\", { enumerable: true, get: function () { return circular_1.CircularLayout; } });\nvar dagre_1 = require(\"./dagre\");\nObject.defineProperty(exports, \"DagreLayout\", { enumerable: true, get: function () { return dagre_1.DagreLayout; } });\nvar radial_1 = require(\"./radial\");\nObject.defineProperty(exports, \"RadialLayout\", { enumerable: true, get: function () { return radial_1.RadialLayout; } });\nvar concentric_1 = require(\"./concentric\");\nObject.defineProperty(exports, \"ConcentricLayout\", { enumerable: true, get: function () { return concentric_1.ConcentricLayout; } });\nvar mds_1 = require(\"./mds\");\nObject.defineProperty(exports, \"MDSLayout\", { enumerable: true, get: function () { return mds_1.MDSLayout; } });\nvar fruchterman_1 = require(\"./fruchterman\");\nObject.defineProperty(exports, \"FruchtermanLayout\", { enumerable: true, get: function () { return fruchterman_1.FruchtermanLayout; } });\nvar fruchterman_2 = require(\"./gpu/fruchterman\");\nObject.defineProperty(exports, \"FruchtermanGPULayout\", { enumerable: true, get: function () { return fruchterman_2.FruchtermanGPULayout; } });\nvar gForce_2 = require(\"./gpu/gForce\");\nObject.defineProperty(exports, \"GForceGPULayout\", { enumerable: true, get: function () { return gForce_2.GForceGPULayout; } });\nvar comboForce_1 = require(\"./comboForce\");\nObject.defineProperty(exports, \"ComboForceLayout\", { enumerable: true, get: function () { return comboForce_1.ComboForceLayout; } });\nvar forceAtlas2_1 = require(\"./forceAtlas2\");\nObject.defineProperty(exports, \"ForceAtlas2Layout\", { enumerable: true, get: function () { return forceAtlas2_1.ForceAtlas2Layout; } });\nvar layout_1 = require(\"./layout\");\nObject.defineProperty(exports, \"Layout\", { enumerable: true, get: function () { return layout_1.Layout; } });\nObject.defineProperty(exports, \"Layouts\", { enumerable: true, get: function () { return layout_1.Layouts; } });\n// types file\n__exportStar(require(\"./types\"), exports);\n//# sourceMappingURL=index.js.map","\n/**\n * @fileOverview grid layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GridLayout = void 0;\nvar util_1 = require(\"../util\");\nvar base_1 = require(\"./base\");\n/**\n * 网格布局\n */\nvar GridLayout = /** @class */ (function (_super) {\n    __extends(GridLayout, _super);\n    function GridLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 布局起始点 */\n        _this.begin = [0, 0];\n        /** prevents node overlap, may overflow boundingBox if not enough space */\n        _this.preventOverlap = true;\n        /** extra spacing around nodes when preventOverlap: true */\n        _this.preventOverlapPadding = 10;\n        /** uses all available space on false, uses minimal space on true */\n        _this.condense = false;\n        /** a sorting function to order the nodes; e.g. function(a, b){ return a.datapublic ('weight') - b.data('weight') } */\n        _this.sortBy = \"degree\";\n        _this.nodeSize = 30;\n        _this.nodes = [];\n        _this.edges = [];\n        _this.width = 300;\n        _this.height = 300;\n        _this.row = 0;\n        _this.col = 0;\n        _this.cellWidth = 0;\n        _this.cellHeight = 0;\n        _this.cellUsed = {};\n        _this.id2manPos = {};\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        _this.updateCfg(options);\n        return _this;\n    }\n    GridLayout.prototype.getDefaultCfg = function () {\n        return {\n            begin: [0, 0],\n            preventOverlap: true,\n            preventOverlapPadding: 10,\n            condense: false,\n            rows: undefined,\n            cols: undefined,\n            position: undefined,\n            sortBy: \"degree\",\n            nodeSize: 30\n        };\n    };\n    /**\n     * 执行布局\n     */\n    GridLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var n = nodes.length;\n        var begin = self.begin;\n        if (n === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (n === 1) {\n            nodes[0].x = begin[0];\n            nodes[0].y = begin[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        var edges = self.edges;\n        var layoutNodes = [];\n        nodes.forEach(function (node) {\n            layoutNodes.push(node);\n        });\n        var nodeIdxMap = {};\n        layoutNodes.forEach(function (node, i) {\n            nodeIdxMap[node.id] = i;\n        });\n        if (self.sortBy === \"degree\" ||\n            !util_1.isString(self.sortBy) ||\n            layoutNodes[0][self.sortBy] === undefined) {\n            self.sortBy = \"degree\";\n            if (util_1.isNaN(nodes[0].degree)) {\n                var values_1 = util_1.getDegree(layoutNodes.length, nodeIdxMap, edges);\n                layoutNodes.forEach(function (node, i) {\n                    node.degree = values_1[i];\n                });\n            }\n        }\n        // sort nodes by value\n        layoutNodes.sort(function (n1, n2) { return n2[self.sortBy] - n1[self.sortBy]; });\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        var oRows = self.rows;\n        var oCols = self.cols != null ? self.cols : self.columns;\n        self.cells = n;\n        // if rows or columns were set in self, use those values\n        if (oRows != null && oCols != null) {\n            self.rows = oRows;\n            self.cols = oCols;\n        }\n        else if (oRows != null && oCols == null) {\n            self.rows = oRows;\n            self.cols = Math.ceil(self.cells / self.rows);\n        }\n        else if (oRows == null && oCols != null) {\n            self.cols = oCols;\n            self.rows = Math.ceil(self.cells / self.cols);\n        }\n        else {\n            // otherwise use the automatic values and adjust accordingly\t      // otherwise use the automatic values and adjust accordingly\n            // width/height * splits^2 = cells where splits is number of times to split width\n            self.splits = Math.sqrt((self.cells * self.height) / self.width);\n            self.rows = Math.round(self.splits);\n            self.cols = Math.round((self.width / self.height) * self.splits);\n        }\n        if (self.cols * self.rows > self.cells) {\n            // otherwise use the automatic values and adjust accordingly\n            // if rounding was up, see if we can reduce rows or columns\n            var sm = self.small();\n            var lg = self.large();\n            // reducing the small side takes away the most cells, so try it first\n            if ((sm - 1) * lg >= self.cells) {\n                self.small(sm - 1);\n            }\n            else if ((lg - 1) * sm >= self.cells) {\n                self.large(lg - 1);\n            }\n        }\n        else {\n            // if rounding was too low, add rows or columns\n            while (self.cols * self.rows < self.cells) {\n                var sm = self.small();\n                var lg = self.large();\n                // try to add to larger side first (adds less in multiplication)\n                if ((lg + 1) * sm >= self.cells) {\n                    self.large(lg + 1);\n                }\n                else {\n                    self.small(sm + 1);\n                }\n            }\n        }\n        self.cellWidth = self.width / self.cols;\n        self.cellHeight = self.height / self.rows;\n        if (self.condense) {\n            self.cellWidth = 0;\n            self.cellHeight = 0;\n        }\n        if (self.preventOverlap) {\n            layoutNodes.forEach(function (node) {\n                if (!node.x || !node.y) {\n                    // for bb\n                    node.x = 0;\n                    node.y = 0;\n                }\n                var nodew;\n                var nodeh;\n                if (util_1.isArray(node.size)) {\n                    nodew = node.size[0];\n                    nodeh = node.size[1];\n                }\n                else if (util_1.isNumber(node.size)) {\n                    nodew = node.size;\n                    nodeh = node.size;\n                }\n                if (nodew === undefined || nodeh === undefined) {\n                    if (util_1.isArray(self.nodeSize)) {\n                        nodew = self.nodeSize[0];\n                        nodeh = self.nodeSize[1];\n                    }\n                    else if (util_1.isNumber(self.nodeSize)) {\n                        nodew = self.nodeSize;\n                        nodeh = self.nodeSize;\n                    }\n                    else {\n                        nodew = 30;\n                        nodeh = 30;\n                    }\n                }\n                var p = self.preventOverlapPadding;\n                var w = nodew + p;\n                var h = nodeh + p;\n                self.cellWidth = Math.max(self.cellWidth, w);\n                self.cellHeight = Math.max(self.cellHeight, h);\n            });\n        }\n        self.cellUsed = {}; // e.g. 'c-0-2' => true\n        // to keep track of current cell position\n        self.row = 0;\n        self.col = 0;\n        // get a cache of all the manual positions\n        self.id2manPos = {};\n        for (var i = 0; i < layoutNodes.length; i++) {\n            var node = layoutNodes[i];\n            var rcPos = void 0;\n            if (self.position) {\n                rcPos = self.position(node);\n            }\n            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n                // must have at least row or col def'd\n                var pos = {\n                    row: rcPos.row,\n                    col: rcPos.col\n                };\n                if (pos.col === undefined) {\n                    // find unused col\n                    pos.col = 0;\n                    while (self.used(pos.row, pos.col)) {\n                        pos.col++;\n                    }\n                }\n                else if (pos.row === undefined) {\n                    // find unused row\n                    pos.row = 0;\n                    while (self.used(pos.row, pos.col)) {\n                        pos.row++;\n                    }\n                }\n                self.id2manPos[node.id] = pos;\n                self.use(pos.row, pos.col);\n            }\n            self.getPos(node);\n        }\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            edges: edges,\n            nodes: layoutNodes\n        };\n    };\n    GridLayout.prototype.small = function (val) {\n        var self = this;\n        var res;\n        var rows = self.rows || 5;\n        var cols = self.cols || 5;\n        if (val == null) {\n            res = Math.min(rows, cols);\n        }\n        else {\n            var min = Math.min(rows, cols);\n            if (min === self.rows) {\n                self.rows = val;\n            }\n            else {\n                self.cols = val;\n            }\n        }\n        return res;\n    };\n    GridLayout.prototype.large = function (val) {\n        var self = this;\n        var res;\n        var rows = self.rows || 5;\n        var cols = self.cols || 5;\n        if (val == null) {\n            res = Math.max(rows, cols);\n        }\n        else {\n            var max = Math.max(rows, cols);\n            if (max === self.rows) {\n                self.rows = val;\n            }\n            else {\n                self.cols = val;\n            }\n        }\n        return res;\n    };\n    GridLayout.prototype.used = function (row, col) {\n        var self = this;\n        return self.cellUsed[\"c-\" + row + \"-\" + col] || false;\n    };\n    GridLayout.prototype.use = function (row, col) {\n        var self = this;\n        self.cellUsed[\"c-\" + row + \"-\" + col] = true;\n    };\n    GridLayout.prototype.moveToNextCell = function () {\n        var self = this;\n        var cols = self.cols || 5;\n        self.col++;\n        if (self.col >= cols) {\n            self.col = 0;\n            self.row++;\n        }\n    };\n    GridLayout.prototype.getPos = function (node) {\n        var self = this;\n        var begin = self.begin;\n        var cellWidth = self.cellWidth;\n        var cellHeight = self.cellHeight;\n        var x;\n        var y;\n        // see if we have a manual position set\n        var rcPos = self.id2manPos[node.id];\n        if (rcPos) {\n            x = rcPos.col * cellWidth + cellWidth / 2 + begin[0];\n            y = rcPos.row * cellHeight + cellHeight / 2 + begin[1];\n        }\n        else {\n            // otherwise set automatically\n            while (self.used(self.row, self.col)) {\n                self.moveToNextCell();\n            }\n            x = self.col * cellWidth + cellWidth / 2 + begin[0];\n            y = self.row * cellHeight + cellHeight / 2 + begin[1];\n            self.use(self.row, self.col);\n            self.moveToNextCell();\n        }\n        node.x = x;\n        node.y = y;\n    };\n    GridLayout.prototype.getType = function () {\n        return \"grid\";\n    };\n    return GridLayout;\n}(base_1.Base));\nexports.GridLayout = GridLayout;\n//# sourceMappingURL=grid.js.map","\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RandomLayout = void 0;\nvar base_1 = require(\"./base\");\n/**\n * 随机布局\n */\nvar RandomLayout = /** @class */ (function (_super) {\n    __extends(RandomLayout, _super);\n    function RandomLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 布局中心 */\n        _this.center = [0, 0];\n        /** 宽度 */\n        _this.width = 300;\n        /** 高度 */\n        _this.height = 300;\n        _this.nodes = [];\n        _this.edges = [];\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        _this.updateCfg(options);\n        return _this;\n    }\n    RandomLayout.prototype.getDefaultCfg = function () {\n        return {\n            center: [0, 0],\n            width: 300,\n            height: 300\n        };\n    };\n    /**\n     * 执行布局\n     */\n    RandomLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var layoutScale = 0.9;\n        var center = self.center;\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (nodes) {\n            nodes.forEach(function (node) {\n                node.x = (Math.random() - 0.5) * layoutScale * self.width + center[0];\n                node.y = (Math.random() - 0.5) * layoutScale * self.height + center[1];\n            });\n        }\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes: nodes,\n            edges: this.edges\n        };\n    };\n    RandomLayout.prototype.getType = function () {\n        return \"random\";\n    };\n    return RandomLayout;\n}(base_1.Base));\nexports.RandomLayout = RandomLayout;\n//# sourceMappingURL=random.js.map","\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GForceLayout = void 0;\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util\");\nvar proccessToFunc = function (value, defaultV) {\n    var func;\n    if (!value) {\n        func = function (d) {\n            return defaultV || 1;\n        };\n    }\n    else if (util_1.isNumber(value)) {\n        func = function (d) {\n            return value;\n        };\n    }\n    else {\n        func = value;\n    }\n    return func;\n};\n/**\n * graphin 中的 force 布局\n */\nvar GForceLayout = /** @class */ (function (_super) {\n    __extends(GForceLayout, _super);\n    function GForceLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 停止迭代的最大迭代数 */\n        _this.maxIteration = 1000;\n        /** 弹簧引力系数 */\n        _this.edgeStrength = 200;\n        /** 斥力系数 */\n        _this.nodeStrength = 1000;\n        /** 库伦系数 */\n        _this.coulombDisScale = 0.005;\n        /** 阻尼系数 */\n        _this.damping = 0.9;\n        /** 最大速度 */\n        _this.maxSpeed = 1000;\n        /** 一次迭代的平均移动距离小于该值时停止迭代 */\n        _this.minMovement = 0.5;\n        /** 迭代中衰减 */\n        _this.interval = 0.02;\n        /** 斥力的一个系数 */\n        _this.factor = 1;\n        /** 理想边长 */\n        _this.linkDistance = 1;\n        /** 重力大小 */\n        _this.gravity = 10;\n        /** 是否防止重叠 */\n        _this.preventOverlap = true;\n        /** 每次迭代结束的回调函数 */\n        _this.tick = function () { };\n        _this.nodes = [];\n        _this.edges = [];\n        _this.width = 300;\n        _this.height = 300;\n        _this.nodeMap = {};\n        _this.nodeIdxMap = {};\n        _this.updateCfg(options);\n        return _this;\n    }\n    GForceLayout.prototype.getDefaultCfg = function () {\n        return {\n            maxIteration: 500,\n            gravity: 10,\n            enableTick: true\n        };\n    };\n    /**\n     * 执行布局\n     */\n    GForceLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes;\n        if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n            window.clearInterval(self.timeInterval);\n        }\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (!self.center) {\n            self.center = [self.width / 2, self.height / 2];\n        }\n        var center = self.center;\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        var nodeMap = {};\n        var nodeIdxMap = {};\n        nodes.forEach(function (node, i) {\n            if (!util_1.isNumber(node.x))\n                node.x = Math.random() * self.width;\n            if (!util_1.isNumber(node.y))\n                node.y = Math.random() * self.height;\n            nodeMap[node.id] = node;\n            nodeIdxMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.nodeIdxMap = nodeIdxMap;\n        self.linkDistance = proccessToFunc(self.linkDistance, 1);\n        self.nodeStrength = proccessToFunc(self.nodeStrength, 1);\n        self.edgeStrength = proccessToFunc(self.edgeStrength, 1);\n        // node size function\n        var nodeSize = self.nodeSize;\n        var nodeSizeFunc;\n        if (self.preventOverlap) {\n            var nodeSpacing_1 = self.nodeSpacing;\n            var nodeSpacingFunc_1;\n            if (util_1.isNumber(nodeSpacing_1)) {\n                nodeSpacingFunc_1 = function () { return nodeSpacing_1; };\n            }\n            else if (util_1.isFunction(nodeSpacing_1)) {\n                nodeSpacingFunc_1 = nodeSpacing_1;\n            }\n            else {\n                nodeSpacingFunc_1 = function () { return 0; };\n            }\n            if (!nodeSize) {\n                nodeSizeFunc = function (d) {\n                    if (d.size) {\n                        if (util_1.isArray(d.size)) {\n                            var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                            return res + nodeSpacingFunc_1(d);\n                        }\n                        return d.size + nodeSpacingFunc_1(d);\n                    }\n                    return 10 + nodeSpacingFunc_1(d);\n                };\n            }\n            else if (util_1.isArray(nodeSize)) {\n                nodeSizeFunc = function (d) {\n                    var res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n                    return res + nodeSpacingFunc_1(d);\n                };\n            }\n            else {\n                nodeSizeFunc = function (d) { return nodeSize + nodeSpacingFunc_1(d); };\n            }\n        }\n        self.nodeSize = nodeSizeFunc;\n        var edges = self.edges;\n        self.degrees = util_1.getDegree(nodes.length, self.nodeIdxMap, edges);\n        if (!self.getMass) {\n            self.getMass = function (d) {\n                var mass = self.degrees[self.nodeIdxMap[d.id]] || 1;\n                return mass;\n            };\n        }\n        // layout\n        self.run();\n    };\n    GForceLayout.prototype.run = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var edges = self.edges;\n        var maxIteration = self.maxIteration;\n        if (typeof window === \"undefined\")\n            return;\n        var iter = 0;\n        // interval for render the result after each iteration\n        this.timeInterval = window.setInterval(function () {\n            var accArray = [];\n            var velArray = [];\n            if (!nodes)\n                return;\n            nodes.forEach(function (_, i) {\n                accArray[2 * i] = 0;\n                accArray[2 * i + 1] = 0;\n                velArray[2 * i] = 0;\n                velArray[2 * i + 1] = 0;\n            });\n            self.calRepulsive(accArray, nodes);\n            if (edges)\n                self.calAttractive(accArray, edges);\n            self.calGravity(accArray, nodes);\n            var stepInterval = Math.max(0.02, self.interval - iter * 0.002);\n            self.updateVelocity(accArray, velArray, stepInterval, nodes);\n            var previousPos = [];\n            nodes.forEach(function (node) {\n                previousPos.push({\n                    x: node.x,\n                    y: node.y\n                });\n            });\n            self.updatePosition(velArray, stepInterval, nodes);\n            if (self.tick)\n                self.tick();\n            // whether to stop the iteration\n            var movement = 0;\n            nodes.forEach(function (node, j) {\n                var vx = node.x - previousPos[j].x;\n                var vy = node.y - previousPos[j].y;\n                movement += Math.sqrt(vx * vx + vy * vy);\n            });\n            movement /= nodes.length;\n            if (movement < self.minMovement) {\n                window.clearInterval(self.timeInterval);\n                if (self.onLayoutEnd)\n                    self.onLayoutEnd();\n            }\n            iter++;\n            if (iter >= maxIteration) {\n                if (self.onLayoutEnd)\n                    self.onLayoutEnd();\n                window.clearInterval(self.timeInterval);\n            }\n        }, 0);\n    };\n    GForceLayout.prototype.calRepulsive = function (accArray, nodes) {\n        var self = this;\n        // const nodes = self.nodes;\n        var getMass = self.getMass;\n        var nodeStrength = self.nodeStrength;\n        var factor = self.factor;\n        var coulombDisScale = self.coulombDisScale;\n        var preventOverlap = self.preventOverlap;\n        var nodeSize = self.nodeSize;\n        nodes.forEach(function (ni, i) {\n            var massi = getMass ? getMass(ni) : 1;\n            nodes.forEach(function (nj, j) {\n                if (i >= j)\n                    return;\n                // if (!accArray[j]) accArray[j] = 0;\n                var vecX = ni.x - nj.x;\n                var vecY = ni.y - nj.y;\n                var vecLength = Math.sqrt(vecX * vecX + vecY * vecY) + 0.01;\n                var nVecLength = (vecLength + 0.1) * coulombDisScale;\n                var direX = vecX / vecLength;\n                var direY = vecY / vecLength;\n                var param = (((nodeStrength(ni) + nodeStrength(nj)) / 2) * factor) /\n                    (nVecLength * nVecLength);\n                var massj = getMass ? getMass(nj) : 1;\n                accArray[2 * i] += (direX * param);\n                accArray[2 * i + 1] += (direY * param);\n                accArray[2 * j] -= (direX * param);\n                accArray[2 * j + 1] -= (direY * param);\n                if (preventOverlap && vecLength < (nodeSize(ni) + nodeSize(nj)) / 2) {\n                    var paramOverlap = (nodeStrength(ni) + nodeStrength(nj)) / 2 / (vecLength * vecLength);\n                    accArray[2 * i] += (direX * paramOverlap) / massi;\n                    accArray[2 * i + 1] += (direY * paramOverlap) / massi;\n                    accArray[2 * j] -= (direX * paramOverlap) / massj;\n                    accArray[2 * j + 1] -= (direY * paramOverlap) / massj;\n                }\n            });\n        });\n    };\n    GForceLayout.prototype.calAttractive = function (accArray, edges) {\n        var self = this;\n        // const edges = self.edges;\n        var nodeMap = self.nodeMap;\n        var nodeIdxMap = self.nodeIdxMap;\n        var linkDistance = self.linkDistance;\n        var edgeStrength = self.edgeStrength;\n        var getMass = self.getMass;\n        edges.forEach(function (edge, i) {\n            var sourceNode = nodeMap[edge.source];\n            var targetNode = nodeMap[edge.target];\n            var vecX = targetNode.x - sourceNode.x;\n            var vecY = targetNode.y - sourceNode.y;\n            var vecLength = Math.sqrt(vecX * vecX + vecY * vecY) + 0.01;\n            var direX = vecX / vecLength;\n            var direY = vecY / vecLength;\n            var length = linkDistance(edge) || 1;\n            var diff = length - vecLength;\n            var param = diff * edgeStrength(edge);\n            var sourceIdx = nodeIdxMap[edge.source];\n            var targetIdx = nodeIdxMap[edge.target];\n            var massSource = getMass ? getMass(sourceNode) : 1;\n            var massTarget = getMass ? getMass(targetNode) : 1;\n            accArray[2 * sourceIdx] -= (direX * param) / massSource;\n            accArray[2 * sourceIdx + 1] -= (direY * param) / massSource;\n            accArray[2 * targetIdx] += (direX * param) / massTarget;\n            accArray[2 * targetIdx + 1] += (direY * param) / massTarget;\n        });\n    };\n    GForceLayout.prototype.calGravity = function (accArray, nodes) {\n        var self = this;\n        // const nodes = self.nodes;\n        var center = self.center;\n        var defaultGravity = self.gravity;\n        var degrees = self.degrees;\n        var nodeLength = nodes.length;\n        for (var i = 0; i < nodeLength; i++) {\n            var node = nodes[i];\n            var vecX = node.x - center[0];\n            var vecY = node.y - center[1];\n            var gravity = defaultGravity;\n            if (self.getCenter) {\n                var customCenterOpt = self.getCenter(node, degrees[i]);\n                if (customCenterOpt &&\n                    util_1.isNumber(customCenterOpt[0]) &&\n                    util_1.isNumber(customCenterOpt[1]) &&\n                    util_1.isNumber(customCenterOpt[2])) {\n                    vecX = node.x - customCenterOpt[0];\n                    vecY = node.y - customCenterOpt[1];\n                    gravity = customCenterOpt[2];\n                }\n            }\n            if (!gravity)\n                continue;\n            accArray[2 * i] -= gravity * vecX;\n            accArray[2 * i + 1] -= gravity * vecY;\n        }\n    };\n    GForceLayout.prototype.updateVelocity = function (accArray, velArray, stepInterval, nodes) {\n        var self = this;\n        var param = stepInterval * self.damping;\n        // const nodes = self.nodes;\n        nodes.forEach(function (node, i) {\n            var vx = accArray[2 * i] * param || 0.01;\n            var vy = accArray[2 * i + 1] * param || 0.01;\n            var vLength = Math.sqrt(vx * vx + vy * vy);\n            if (vLength > self.maxSpeed) {\n                var param2 = self.maxSpeed / vLength;\n                vx = param2 * vx;\n                vy = param2 * vy;\n            }\n            velArray[2 * i] = vx;\n            velArray[2 * i + 1] = vy;\n        });\n    };\n    GForceLayout.prototype.updatePosition = function (velArray, stepInterval, nodes) {\n        nodes.forEach(function (node, i) {\n            if (util_1.isNumber(node.fx) && util_1.isNumber(node.fy)) {\n                node.x = node.fx;\n                node.y = node.fy;\n                return;\n            }\n            var distX = velArray[2 * i] * stepInterval;\n            var distY = velArray[2 * i + 1] * stepInterval;\n            node.x += distX;\n            node.y += distY;\n        });\n    };\n    GForceLayout.prototype.stop = function () {\n        if (this.timeInterval && typeof window !== \"undefined\") {\n            window.clearInterval(this.timeInterval);\n        }\n    };\n    GForceLayout.prototype.destroy = function () {\n        var self = this;\n        self.stop();\n        self.tick = null;\n        self.nodes = null;\n        self.edges = null;\n        self.destroyed = true;\n    };\n    GForceLayout.prototype.getType = function () {\n        return \"gForce\";\n    };\n    return GForceLayout;\n}(base_1.Base));\nexports.GForceLayout = GForceLayout;\n//# sourceMappingURL=gForce.js.map","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./force\"), exports);\n//# sourceMappingURL=index.js.map","\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ForceLayout = void 0;\nvar d3Force = __importStar(require(\"d3-force\"));\nvar force_in_a_box_1 = __importDefault(require(\"./force-in-a-box\"));\nvar util_1 = require(\"../../util\");\nvar base_1 = require(\"../base\");\nvar constants_1 = require(\"../constants\");\n/**\n * 经典力导布局 force-directed\n */\nvar ForceLayout = /** @class */ (function (_super) {\n    __extends(ForceLayout, _super);\n    function ForceLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 向心力作用点 */\n        _this.center = [0, 0];\n        /** 节点作用力 */\n        _this.nodeStrength = null;\n        /** 边的作用力, 默认为根据节点的入度出度自适应 */\n        _this.edgeStrength = null;\n        /** 是否防止节点相互覆盖 */\n        _this.preventOverlap = false;\n        /** 聚类节点作用力 */\n        _this.clusterNodeStrength = null;\n        /** 聚类边作用力 */\n        _this.clusterEdgeStrength = null;\n        /** 聚类边长度 */\n        _this.clusterEdgeDistance = null;\n        /** 聚类节点大小 / 直径，直径越大，越分散 */\n        _this.clusterNodeSize = null;\n        /** 用于 foci 的力 */\n        _this.clusterFociStrength = null;\n        /** 默认边长度 */\n        _this.linkDistance = 50;\n        /** 迭代阈值的衰减率 [0, 1]，0.028 对应最大迭代数为 300 */\n        _this.alphaDecay = 0.028;\n        /** 停止迭代的阈值 */\n        _this.alphaMin = 0.001;\n        /** 当前阈值 */\n        _this.alpha = 0.3;\n        /** 防止重叠的力强度 */\n        _this.collideStrength = 1;\n        /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n        _this.workerEnabled = false;\n        _this.tick = function () { };\n        /** 布局完成回调 */\n        _this.onLayoutEnd = function () { };\n        /** 是否正在布局 */\n        _this.ticking = undefined;\n        if (options) {\n            _this.updateCfg(options);\n        }\n        return _this;\n    }\n    ForceLayout.prototype.getDefaultCfg = function () {\n        return {\n            center: [0, 0],\n            nodeStrength: null,\n            edgeStrength: null,\n            preventOverlap: false,\n            nodeSize: undefined,\n            nodeSpacing: undefined,\n            linkDistance: 50,\n            forceSimulation: null,\n            alphaDecay: 0.028,\n            alphaMin: 0.001,\n            alpha: 0.3,\n            collideStrength: 1,\n            clustering: false,\n            clusterNodeStrength: -1,\n            clusterEdgeStrength: 0.1,\n            clusterEdgeDistance: 100,\n            clusterFociStrength: 0.8,\n            clusterNodeSize: 10,\n            tick: function () { },\n            onLayoutEnd: function () { },\n            // 是否启用web worker。前提是在web worker里执行布局，否则无效\n            workerEnabled: false\n        };\n    };\n    /**\n     * 初始化\n     * @param {object} data 数据\n     */\n    ForceLayout.prototype.init = function (data) {\n        var self = this;\n        self.nodes = data.nodes || [];\n        var edges = data.edges || [];\n        self.edges = edges.map(function (edge) {\n            var res = {};\n            var expectKeys = [\"targetNode\", \"sourceNode\", \"startPoint\", \"endPoint\"];\n            Object.keys(edge).forEach(function (key) {\n                if (!(expectKeys.indexOf(key) > -1)) {\n                    res[key] = edge[key];\n                }\n            });\n            return res;\n        });\n        self.ticking = false;\n    };\n    /**\n     * 执行布局\n     */\n    ForceLayout.prototype.execute = function (reloadData) {\n        var self = this;\n        var nodes = self.nodes;\n        var edges = self.edges;\n        // 如果正在布局，忽略布局请求\n        if (self.ticking) {\n            return;\n        }\n        var simulation = self.forceSimulation;\n        var alphaMin = self.alphaMin;\n        var alphaDecay = self.alphaDecay;\n        var alpha = self.alpha;\n        if (!simulation) {\n            try {\n                // 定义节点的力\n                var nodeForce = d3Force.forceManyBody();\n                if (self.nodeStrength) {\n                    nodeForce.strength(self.nodeStrength);\n                }\n                simulation = d3Force.forceSimulation().nodes(nodes);\n                if (self.clustering) {\n                    var clusterForce = force_in_a_box_1.default();\n                    clusterForce\n                        .centerX(self.center[0])\n                        .centerY(self.center[1])\n                        .template(\"force\")\n                        .strength(self.clusterFociStrength);\n                    if (edges) {\n                        clusterForce.links(edges);\n                    }\n                    if (nodes) {\n                        clusterForce.nodes(nodes);\n                    }\n                    clusterForce\n                        .forceLinkDistance(self.clusterEdgeDistance)\n                        .forceLinkStrength(self.clusterEdgeStrength)\n                        .forceCharge(self.clusterNodeStrength)\n                        .forceNodeSize(self.clusterNodeSize);\n                    self.clusterForce = clusterForce;\n                    simulation.force(\"group\", clusterForce);\n                }\n                simulation\n                    .force(\"center\", d3Force.forceCenter(self.center[0], self.center[1]))\n                    .force(\"charge\", nodeForce)\n                    .alpha(alpha)\n                    .alphaDecay(alphaDecay)\n                    .alphaMin(alphaMin);\n                if (self.preventOverlap) {\n                    self.overlapProcess(simulation);\n                }\n                // 如果有边，定义边的力\n                if (edges) {\n                    // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n                    var edgeForce = d3Force\n                        .forceLink()\n                        .id(function (d) { return d.id; })\n                        .links(edges);\n                    if (self.edgeStrength) {\n                        edgeForce.strength(self.edgeStrength);\n                    }\n                    if (self.linkDistance) {\n                        edgeForce.distance(self.linkDistance);\n                    }\n                    self.edgeForce = edgeForce;\n                    simulation.force(\"link\", edgeForce);\n                }\n                if (self.workerEnabled && !isInWorker()) {\n                    // 如果不是运行在web worker里，不用web worker布局\n                    self.workerEnabled = false;\n                    console.warn(\"workerEnabled option is only supported when running in web worker.\");\n                }\n                if (!self.workerEnabled) {\n                    simulation\n                        .on(\"tick\", function () {\n                        self.tick();\n                    })\n                        .on(\"end\", function () {\n                        self.ticking = false;\n                        if (self.onLayoutEnd)\n                            self.onLayoutEnd();\n                    });\n                    self.ticking = true;\n                }\n                else {\n                    // worker is enabled\n                    simulation.stop();\n                    var totalTicks = getSimulationTicks(simulation);\n                    for (var currentTick = 1; currentTick <= totalTicks; currentTick++) {\n                        simulation.tick();\n                        // currentTick starts from 1.\n                        postMessage({\n                            nodes: nodes,\n                            currentTick: currentTick,\n                            totalTicks: totalTicks,\n                            type: constants_1.LAYOUT_MESSAGE.TICK\n                        }, undefined);\n                    }\n                    self.ticking = false;\n                }\n                self.forceSimulation = simulation;\n                self.ticking = true;\n            }\n            catch (e) {\n                self.ticking = false;\n                console.warn(e);\n            }\n        }\n        else {\n            if (reloadData) {\n                if (self.clustering && self.clusterForce) {\n                    self.clusterForce.nodes(nodes);\n                    self.clusterForce.links(edges);\n                }\n                simulation.nodes(nodes);\n                if (edges && self.edgeForce)\n                    self.edgeForce.links(edges);\n                else if (edges && !self.edgeForce) {\n                    // d3 的 forceLayout 会重新生成边的数据模型，为了避免污染源数据\n                    var edgeForce = d3Force\n                        .forceLink()\n                        .id(function (d) { return d.id; })\n                        .links(edges);\n                    if (self.edgeStrength) {\n                        edgeForce.strength(self.edgeStrength);\n                    }\n                    if (self.linkDistance) {\n                        edgeForce.distance(self.linkDistance);\n                    }\n                    self.edgeForce = edgeForce;\n                    simulation.force(\"link\", edgeForce);\n                }\n            }\n            if (self.preventOverlap) {\n                self.overlapProcess(simulation);\n            }\n            simulation.alpha(alpha).restart();\n            this.ticking = true;\n        }\n    };\n    /**\n     * 防止重叠\n     * @param {object} simulation 力模拟模型\n     */\n    ForceLayout.prototype.overlapProcess = function (simulation) {\n        var self = this;\n        var nodeSize = self.nodeSize;\n        var nodeSpacing = self.nodeSpacing;\n        var nodeSizeFunc;\n        var nodeSpacingFunc;\n        var collideStrength = self.collideStrength;\n        if (util_1.isNumber(nodeSpacing)) {\n            nodeSpacingFunc = function () { return nodeSpacing; };\n        }\n        else if (util_1.isFunction(nodeSpacing)) {\n            nodeSpacingFunc = nodeSpacing;\n        }\n        else {\n            nodeSpacingFunc = function () { return 0; };\n        }\n        if (!nodeSize) {\n            nodeSizeFunc = function (d) {\n                if (d.size) {\n                    if (util_1.isArray(d.size)) {\n                        var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                        return res / 2 + nodeSpacingFunc(d);\n                    }\n                    return d.size / 2 + nodeSpacingFunc(d);\n                }\n                return 10 + nodeSpacingFunc(d);\n            };\n        }\n        else if (util_1.isFunction(nodeSize)) {\n            nodeSizeFunc = function (d) {\n                var size = nodeSize(d);\n                return size + nodeSpacingFunc(d);\n            };\n        }\n        else if (util_1.isArray(nodeSize)) {\n            var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n            var radius_1 = larger / 2;\n            nodeSizeFunc = function (d) { return radius_1 + nodeSpacingFunc(d); };\n        }\n        else if (util_1.isNumber(nodeSize)) {\n            var radius_2 = nodeSize / 2;\n            nodeSizeFunc = function (d) { return radius_2 + nodeSpacingFunc(d); };\n        }\n        else {\n            nodeSizeFunc = function () { return 10; };\n        }\n        // forceCollide's parameter is a radius\n        simulation.force(\"collisionForce\", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));\n    };\n    /**\n     * 更新布局配置，但不执行布局\n     * @param {object} cfg 需要更新的配置项\n     */\n    ForceLayout.prototype.updateCfg = function (cfg) {\n        var self = this;\n        if (self.ticking) {\n            self.forceSimulation.stop();\n            self.ticking = false;\n        }\n        self.forceSimulation = null;\n        Object.assign(self, cfg);\n    };\n    ForceLayout.prototype.destroy = function () {\n        var self = this;\n        if (self.ticking) {\n            self.forceSimulation.stop();\n            self.ticking = false;\n        }\n        self.nodes = null;\n        self.edges = null;\n        self.destroyed = true;\n    };\n    return ForceLayout;\n}(base_1.Base));\nexports.ForceLayout = ForceLayout;\n// Return total ticks of d3-force simulation\nfunction getSimulationTicks(simulation) {\n    var alphaMin = simulation.alphaMin();\n    var alphaTarget = simulation.alphaTarget();\n    var alpha = simulation.alpha();\n    var totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) /\n        Math.log(1 - simulation.alphaDecay());\n    var totalTicks = Math.ceil(totalTicksFloat);\n    return totalTicks;\n}\n// 判断是否运行在web worker里\nfunction isInWorker() {\n    // eslint-disable-next-line no-undef\n    return (typeof WorkerGlobalScope !== \"undefined\" &&\n        self instanceof WorkerGlobalScope);\n}\n//# sourceMappingURL=force.js.map","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar d3Force = __importStar(require(\"d3-force\"));\n// https://github.com/john-guerra/forceInABox/blob/master/src/forceInABox.js\nfunction forceInABox() {\n    function constant(_) {\n        return function () { return _; };\n    }\n    var groupBy = function (d) {\n        return d.cluster;\n    };\n    var forceNodeSize = constant(1);\n    var forceCharge = constant(-1);\n    var forceLinkDistance = constant(100);\n    var forceLinkStrength = constant(0.1);\n    var offset = [0, 0];\n    var nodes = [];\n    var nodesMap = {};\n    var links = [];\n    var centerX = 100;\n    var centerY = 100;\n    var foci = {\n        none: {\n            x: 0,\n            y: 0,\n        },\n    };\n    var templateNodes = [];\n    var templateForce;\n    var template = 'force';\n    var enableGrouping = true;\n    var strength = 0.1;\n    function force(alpha) {\n        if (!enableGrouping) {\n            return force;\n        }\n        templateForce.tick();\n        getFocisFromTemplate();\n        for (var i = 0, n = nodes.length, node = void 0, k = alpha * strength; i < n; ++i) {\n            node = nodes[i];\n            node.vx += (foci[groupBy(node)].x - node.x) * k;\n            node.vy += (foci[groupBy(node)].y - node.y) * k;\n        }\n    }\n    function initialize() {\n        if (!nodes)\n            return;\n        initializeWithForce();\n    }\n    function initializeWithForce() {\n        if (!nodes || !nodes.length) {\n            return;\n        }\n        if (groupBy(nodes[0]) === undefined) {\n            throw Error(\"Couldnt find the grouping attribute for the nodes. Make sure to set it up with forceInABox.groupBy('clusterAttr') before calling .links()\");\n        }\n        // checkLinksAsObjects();\n        var net = getGroupsGraph();\n        templateForce = d3Force\n            .forceSimulation(net.nodes)\n            .force('x', d3Force.forceX(centerX).strength(0.1))\n            .force('y', d3Force.forceY(centerY).strength(0.1))\n            .force('collide', d3Force.forceCollide(function (d) { return d.r; }).iterations(4))\n            .force('charge', d3Force.forceManyBody().strength(forceCharge))\n            .force('links', d3Force\n            .forceLink(net.nodes.length ? net.links : [])\n            .distance(forceLinkDistance)\n            .strength(forceLinkStrength));\n        templateNodes = templateForce.nodes();\n        getFocisFromTemplate();\n    }\n    function getGroupsGraph() {\n        var gnodes = [];\n        var glinks = [];\n        var dNodes = {};\n        var clustersList = [];\n        var clustersCounts = {};\n        var clustersLinks = [];\n        clustersCounts = computeClustersNodeCounts(nodes);\n        clustersLinks = computeClustersLinkCounts(links);\n        clustersList = Object.keys(clustersCounts);\n        clustersList.forEach(function (key, index) {\n            var val = clustersCounts[key];\n            // Uses approx meta-node size\n            gnodes.push({\n                id: key,\n                size: val.count,\n                r: Math.sqrt(val.sumforceNodeSize / Math.PI),\n            });\n            dNodes[key] = index;\n        });\n        clustersLinks.forEach(function (l) {\n            var source = dNodes[l.source];\n            var target = dNodes[l.target];\n            if (source !== undefined && target !== undefined) {\n                glinks.push({\n                    source: source,\n                    target: target,\n                    count: l.count,\n                });\n            }\n        });\n        return {\n            nodes: gnodes,\n            links: glinks,\n        };\n    }\n    function computeClustersNodeCounts(nodes) {\n        var clustersCounts = {};\n        nodes.forEach(function (d) {\n            var key = groupBy(d);\n            if (!clustersCounts[key]) {\n                clustersCounts[key] = {\n                    count: 0,\n                    sumforceNodeSize: 0,\n                };\n            }\n        });\n        nodes.forEach(function (d) {\n            var key = groupBy(d);\n            var nodeSize = forceNodeSize(d);\n            var tmpCount = clustersCounts[key];\n            tmpCount.count = tmpCount.count + 1;\n            tmpCount.sumforceNodeSize =\n                tmpCount.sumforceNodeSize + Math.PI * (nodeSize * nodeSize) * 1.3;\n            clustersCounts[key] = tmpCount;\n        });\n        return clustersCounts;\n    }\n    function computeClustersLinkCounts(links) {\n        var dClusterLinks = {};\n        var clusterLinks = [];\n        links.forEach(function (l) {\n            var key = getLinkKey(l);\n            var count = 0;\n            if (dClusterLinks[key] !== undefined) {\n                count = dClusterLinks[key];\n            }\n            count += 1;\n            dClusterLinks[key] = count;\n        });\n        var entries = Object.entries(dClusterLinks);\n        entries.forEach(function (_a) {\n            var key = _a[0], count = _a[1];\n            var source = key.split('~')[0];\n            var target = key.split('~')[1];\n            if (source !== undefined && target !== undefined) {\n                clusterLinks.push({\n                    source: source,\n                    target: target,\n                    count: count,\n                });\n            }\n        });\n        return clusterLinks;\n    }\n    function getFocisFromTemplate() {\n        foci = {\n            none: {\n                x: 0,\n                y: 0,\n            },\n        };\n        templateNodes.forEach(function (d) {\n            foci[d.id] = {\n                x: d.x - offset[0],\n                y: d.y - offset[1],\n            };\n        });\n        return foci;\n    }\n    function getLinkKey(l) {\n        var sourceID = groupBy(nodesMap[l.source]);\n        var targetID = groupBy(nodesMap[l.target]);\n        return sourceID <= targetID\n            ? sourceID + \"~\" + targetID\n            : targetID + \"~\" + sourceID;\n    }\n    function genNodesMap(nodes) {\n        nodesMap = {};\n        nodes.forEach(function (node) {\n            nodesMap[node.id] = node;\n        });\n    }\n    function setTemplate(x) {\n        if (!arguments.length)\n            return template;\n        template = x;\n        initialize();\n        return force;\n    }\n    function setGroupBy(x) {\n        if (!arguments.length)\n            return groupBy;\n        if (typeof x === 'string') {\n            groupBy = function (d) {\n                return d[x];\n            };\n            return force;\n        }\n        groupBy = x;\n        return force;\n    }\n    function setEnableGrouping(x) {\n        if (!arguments.length)\n            return enableGrouping;\n        enableGrouping = x;\n        return force;\n    }\n    function setStrength(x) {\n        if (!arguments.length)\n            return strength;\n        strength = x;\n        return force;\n    }\n    function setCenterX(_) {\n        if (arguments.length) {\n            centerX = _;\n            return force;\n        }\n        return centerX;\n    }\n    function setCenterY(_) {\n        if (arguments.length) {\n            centerY = _;\n            return force;\n        }\n        return centerY;\n    }\n    function setNodes(_) {\n        if (arguments.length) {\n            genNodesMap(_ || []);\n            nodes = _ || [];\n            return force;\n        }\n        return nodes;\n    }\n    function setLinks(_) {\n        if (arguments.length) {\n            links = _ || [];\n            initialize();\n            return force;\n        }\n        return links;\n    }\n    function setForceNodeSize(_) {\n        if (arguments.length) {\n            if (typeof _ === 'function') {\n                forceNodeSize = _;\n            }\n            else {\n                forceNodeSize = constant(+_);\n            }\n            initialize();\n            return force;\n        }\n        return forceNodeSize;\n    }\n    function setForceCharge(_) {\n        if (arguments.length) {\n            if (typeof _ === 'function') {\n                forceCharge = _;\n            }\n            else {\n                forceCharge = constant(+_);\n            }\n            initialize();\n            return force;\n        }\n        return forceCharge;\n    }\n    function setForceLinkDistance(_) {\n        if (arguments.length) {\n            if (typeof _ === 'function') {\n                forceLinkDistance = _;\n            }\n            else {\n                forceLinkDistance = constant(+_);\n            }\n            initialize();\n            return force;\n        }\n        return forceLinkDistance;\n    }\n    function setForceLinkStrength(_) {\n        if (arguments.length) {\n            if (typeof _ === 'function') {\n                forceLinkStrength = _;\n            }\n            else {\n                forceLinkStrength = constant(+_);\n            }\n            initialize();\n            return force;\n        }\n        return forceLinkStrength;\n    }\n    function setOffset(_) {\n        if (arguments.length) {\n            offset = _;\n            return force;\n        }\n        return offset;\n    }\n    force.initialize = function (_) {\n        nodes = _;\n        initialize();\n    };\n    force.template = setTemplate;\n    force.groupBy = setGroupBy;\n    force.enableGrouping = setEnableGrouping;\n    force.strength = setStrength;\n    force.centerX = setCenterX;\n    force.centerY = setCenterY;\n    force.nodes = setNodes;\n    force.links = setLinks;\n    force.forceNodeSize = setForceNodeSize;\n    // Legacy support\n    force.nodeSize = force.forceNodeSize;\n    force.forceCharge = setForceCharge;\n    force.forceLinkDistance = setForceLinkDistance;\n    force.forceLinkStrength = setForceLinkStrength;\n    force.offset = setOffset;\n    force.getFocis = getFocisFromTemplate;\n    return force;\n}\nexports.default = forceInABox;\n//# sourceMappingURL=force-in-a-box.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LAYOUT_MESSAGE = void 0;\n/** layout message type */\nexports.LAYOUT_MESSAGE = {\n    // run layout\n    RUN: \"LAYOUT_RUN\",\n    // layout ended with success\n    END: \"LAYOUT_END\",\n    // layout error\n    ERROR: \"LAYOUT_ERROR\",\n    // layout tick, used in force directed layout\n    TICK: \"LAYOUT_TICK\",\n    GPURUN: \"GPU_LAYOUT_RUN\",\n    GPUEND: \"GPU_LAYOUT_END\"\n};\n//# sourceMappingURL=constants.js.map","\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CircularLayout = void 0;\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util\");\nfunction initHierarchy(nodes, edges, nodeMap, directed) {\n    nodes.forEach(function (_, i) {\n        nodes[i].children = [];\n        nodes[i].parent = [];\n    });\n    if (directed) {\n        edges.forEach(function (e) {\n            var sourceIdx = 0;\n            if (e.source) {\n                sourceIdx = nodeMap[e.source];\n            }\n            var targetIdx = 0;\n            if (e.target) {\n                targetIdx = nodeMap[e.target];\n            }\n            var child = nodes[sourceIdx].children;\n            var parent = nodes[targetIdx].parent;\n            child.push(nodes[targetIdx].id);\n            parent.push(nodes[sourceIdx].id);\n        });\n    }\n    else {\n        edges.forEach(function (e) {\n            var sourceIdx = 0;\n            if (e.source) {\n                sourceIdx = nodeMap[e.source];\n            }\n            var targetIdx = 0;\n            if (e.target) {\n                targetIdx = nodeMap[e.target];\n            }\n            var sourceChildren = nodes[sourceIdx].children;\n            var targetChildren = nodes[targetIdx].children;\n            sourceChildren.push(nodes[targetIdx].id);\n            targetChildren.push(nodes[sourceIdx].id);\n        });\n    }\n}\nfunction connect(a, b, edges) {\n    var m = edges.length;\n    for (var i = 0; i < m; i++) {\n        if ((a.id === edges[i].source && b.id === edges[i].target) ||\n            (b.id === edges[i].source && a.id === edges[i].target)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction compareDegree(a, b) {\n    var aDegree = a.degree;\n    var bDegree = b.degree;\n    if (aDegree < bDegree) {\n        return -1;\n    }\n    if (aDegree > bDegree) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * 圆形布局\n */\nvar CircularLayout = /** @class */ (function (_super) {\n    __extends(CircularLayout, _super);\n    function CircularLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\n        _this.radius = null;\n        /** 起始半径 */\n        _this.startRadius = null;\n        /** 终止半径 */\n        _this.endRadius = null;\n        /** 起始角度 */\n        _this.startAngle = 0;\n        /** 终止角度 */\n        _this.endAngle = 2 * Math.PI;\n        /** 是否顺时针 */\n        _this.clockwise = true;\n        /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\n        _this.divisions = 1;\n        /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\n        _this.ordering = null;\n        /** how many 2*pi from first to last nodes */\n        _this.angleRatio = 1;\n        _this.nodes = [];\n        _this.edges = [];\n        _this.nodeMap = {};\n        _this.degrees = [];\n        _this.width = 300;\n        _this.height = 300;\n        _this.updateCfg(options);\n        return _this;\n    }\n    CircularLayout.prototype.getDefaultCfg = function () {\n        return {\n            radius: null,\n            startRadius: null,\n            endRadius: null,\n            startAngle: 0,\n            endAngle: 2 * Math.PI,\n            clockwise: true,\n            divisions: 1,\n            ordering: null,\n            angleRatio: 1\n        };\n    };\n    /**\n     * 执行布局\n     */\n    CircularLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var edges = self.edges;\n        var n = nodes.length;\n        if (n === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (!self.center) {\n            self.center = [self.width / 2, self.height / 2];\n        }\n        var center = self.center;\n        if (n === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        var radius = self.radius;\n        var startRadius = self.startRadius;\n        var endRadius = self.endRadius;\n        var divisions = self.divisions;\n        var startAngle = self.startAngle;\n        var endAngle = self.endAngle;\n        var angleStep = (endAngle - startAngle) / n;\n        // layout\n        var nodeMap = {};\n        nodes.forEach(function (node, i) {\n            nodeMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        var degrees = util_1.getDegree(nodes.length, nodeMap, edges);\n        self.degrees = degrees;\n        if (!radius && !startRadius && !endRadius) {\n            radius = self.height > self.width ? self.width / 2 : self.height / 2;\n        }\n        else if (!startRadius && endRadius) {\n            startRadius = endRadius;\n        }\n        else if (startRadius && !endRadius) {\n            endRadius = startRadius;\n        }\n        var angleRatio = self.angleRatio;\n        var astep = angleStep * angleRatio;\n        var ordering = self.ordering;\n        var layoutNodes = [];\n        if (ordering === \"topology\") {\n            // layout according to the topology\n            layoutNodes = self.topologyOrdering();\n        }\n        else if (ordering === \"topology-directed\") {\n            // layout according to the topology\n            layoutNodes = self.topologyOrdering(true);\n        }\n        else if (ordering === \"degree\") {\n            // layout according to the descent order of degrees\n            layoutNodes = self.degreeOrdering();\n        }\n        else {\n            // layout according to the original order in the data.nodes\n            layoutNodes = nodes;\n        }\n        var clockwise = self.clockwise;\n        var divN = Math.ceil(n / divisions); // node number in each division\n        for (var i = 0; i < n; ++i) {\n            var r = radius;\n            if (!r && startRadius !== null && endRadius !== null) {\n                r = startRadius + (i * (endRadius - startRadius)) / (n - 1);\n            }\n            if (!r) {\n                r = 10 + (i * 100) / (n - 1);\n            }\n            var angle = startAngle +\n                (i % divN) * astep +\n                ((2 * Math.PI) / divisions) * Math.floor(i / divN);\n            if (!clockwise) {\n                angle =\n                    endAngle -\n                        (i % divN) * astep -\n                        ((2 * Math.PI) / divisions) * Math.floor(i / divN);\n            }\n            layoutNodes[i].x = center[0] + Math.cos(angle) * r;\n            layoutNodes[i].y = center[1] + Math.sin(angle) * r;\n            layoutNodes[i].weight = degrees[i];\n        }\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes: layoutNodes,\n            edges: this.edges\n        };\n    };\n    /**\n     * 根据节点的拓扑结构排序\n     * @return {array} orderedNodes 排序后的结果\n     */\n    CircularLayout.prototype.topologyOrdering = function (directed) {\n        if (directed === void 0) { directed = false; }\n        var self = this;\n        var degrees = self.degrees;\n        var edges = self.edges;\n        var nodes = self.nodes;\n        var cnodes = util_1.clone(nodes);\n        var nodeMap = self.nodeMap;\n        var orderedCNodes = [cnodes[0]];\n        var resNodes = [nodes[0]];\n        var pickFlags = [];\n        var n = nodes.length;\n        pickFlags[0] = true;\n        initHierarchy(cnodes, edges, nodeMap, directed);\n        var k = 0;\n        cnodes.forEach(function (cnode, i) {\n            if (i !== 0) {\n                if ((i === n - 1 ||\n                    degrees[i] !== degrees[i + 1] ||\n                    connect(orderedCNodes[k], cnode, edges)) &&\n                    !pickFlags[i]) {\n                    orderedCNodes.push(cnode);\n                    resNodes.push(nodes[nodeMap[cnode.id]]);\n                    pickFlags[i] = true;\n                    k++;\n                }\n                else {\n                    var children = orderedCNodes[k].children;\n                    var foundChild = false;\n                    for (var j = 0; j < children.length; j++) {\n                        var childIdx = nodeMap[children[j]];\n                        if (degrees[childIdx] === degrees[i] && !pickFlags[childIdx]) {\n                            orderedCNodes.push(cnodes[childIdx]);\n                            resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\n                            pickFlags[childIdx] = true;\n                            foundChild = true;\n                            break;\n                        }\n                    }\n                    var ii = 0;\n                    while (!foundChild) {\n                        if (!pickFlags[ii]) {\n                            orderedCNodes.push(cnodes[ii]);\n                            resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\n                            pickFlags[ii] = true;\n                            foundChild = true;\n                        }\n                        ii++;\n                        if (ii === n) {\n                            break;\n                        }\n                    }\n                }\n            }\n        });\n        return resNodes;\n    };\n    /**\n     * 根据节点度数大小排序\n     * @return {array} orderedNodes 排序后的结果\n     */\n    CircularLayout.prototype.degreeOrdering = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var orderedNodes = [];\n        var degrees = self.degrees;\n        nodes.forEach(function (node, i) {\n            node.degree = degrees[i];\n            orderedNodes.push(node);\n        });\n        orderedNodes.sort(compareDegree);\n        return orderedNodes;\n    };\n    CircularLayout.prototype.getType = function () {\n        return \"circular\";\n    };\n    return CircularLayout;\n}(base_1.Base));\nexports.CircularLayout = CircularLayout;\n//# sourceMappingURL=circular.js.map","\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DagreLayout = void 0;\nvar dagre_1 = __importDefault(require(\"dagre\"));\nvar util_1 = require(\"../util\");\nvar base_1 = require(\"./base\");\n/**\n * 层次布局\n */\nvar DagreLayout = /** @class */ (function (_super) {\n    __extends(DagreLayout, _super);\n    function DagreLayout(options) {\n        var _this = _super.call(this) || this;\n        /** layout 方向, 可选 TB, BT, LR, RL */\n        _this.rankdir = \"TB\";\n        /** 节点水平间距(px) */\n        _this.nodesep = 50;\n        /** 每一层节点之间间距 */\n        _this.ranksep = 50;\n        /** 是否保留布局连线的控制点 */\n        _this.controlPoints = false;\n        /** 每层节点是否根据节点数据中的 comboId 进行排序，以放置同层 combo 重叠 */\n        _this.sortByCombo = false;\n        _this.nodes = [];\n        _this.edges = [];\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        _this.updateCfg(options);\n        return _this;\n    }\n    DagreLayout.prototype.getDefaultCfg = function () {\n        return {\n            rankdir: \"TB\",\n            align: undefined,\n            nodeSize: undefined,\n            nodesepFunc: undefined,\n            ranksepFunc: undefined,\n            nodesep: 50,\n            ranksep: 50,\n            controlPoints: false, // 是否保留布局连线的控制点\n        };\n    };\n    /**\n     * 执行布局\n     */\n    DagreLayout.prototype.execute = function () {\n        var _this = this;\n        var self = this;\n        var nodes = self.nodes, nodeSize = self.nodeSize, rankdir = self.rankdir, combos = self.combos;\n        if (!nodes)\n            return;\n        var edges = self.edges || [];\n        var g = new dagre_1.default.graphlib.Graph({\n            multigraph: true,\n            compound: true,\n        });\n        var nodeSizeFunc;\n        if (!nodeSize) {\n            nodeSizeFunc = function (d) {\n                if (d.size) {\n                    if (util_1.isArray(d.size)) {\n                        return d.size;\n                    }\n                    return [d.size, d.size];\n                }\n                return [40, 40];\n            };\n        }\n        else if (util_1.isArray(nodeSize)) {\n            nodeSizeFunc = function () { return nodeSize; };\n        }\n        else {\n            nodeSizeFunc = function () { return [nodeSize, nodeSize]; };\n        }\n        var horisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n        var vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n        if (rankdir === \"LR\" || rankdir === \"RL\") {\n            horisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n            vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n        }\n        g.setDefaultEdgeLabel(function () { return ({}); });\n        g.setGraph(self);\n        var comboMap = {};\n        nodes.forEach(function (node) {\n            var size = nodeSizeFunc(node);\n            var verti = vertisep(node);\n            var hori = horisep(node);\n            var width = size[0] + 2 * hori;\n            var height = size[1] + 2 * verti;\n            g.setNode(node.id, { width: width, height: height });\n            if (_this.sortByCombo && node.comboId) {\n                if (!comboMap[node.comboId]) {\n                    comboMap[node.comboId] = true;\n                    g.setNode(node.comboId, {});\n                }\n                g.setParent(node.id, node.comboId);\n            }\n        });\n        if (this.sortByCombo && combos) {\n            combos.forEach(function (combo) {\n                if (!combo.parentId)\n                    return;\n                if (!comboMap[combo.parentId]) {\n                    comboMap[combo.parentId] = true;\n                    g.setNode(combo.parentId, {});\n                }\n                g.setParent(combo.id, combo.parentId);\n            });\n        }\n        edges.forEach(function (edge) {\n            // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n            g.setEdge(edge.source, edge.target, {\n                weight: edge.weight || 1,\n            });\n        });\n        dagre_1.default.layout(g);\n        var coord;\n        g.nodes().forEach(function (node) {\n            coord = g.node(node);\n            var i = nodes.findIndex(function (it) { return it.id === node; });\n            if (!nodes[i])\n                return;\n            nodes[i].x = coord.x;\n            nodes[i].y = coord.y;\n        });\n        g.edges().forEach(function (edge) {\n            coord = g.edge(edge);\n            var i = edges.findIndex(function (it) { return it.source === edge.v && it.target === edge.w; });\n            if (self.controlPoints && edges[i].type !== \"loop\") {\n                edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);\n            }\n        });\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes: nodes,\n            edges: edges,\n        };\n    };\n    DagreLayout.prototype.getType = function () {\n        return \"dagre\";\n    };\n    return DagreLayout;\n}(base_1.Base));\nexports.DagreLayout = DagreLayout;\nfunction getFunc(func, value, defaultValue) {\n    var resultFunc;\n    if (func) {\n        resultFunc = func;\n    }\n    else if (util_1.isNumber(value)) {\n        resultFunc = function () { return value; };\n    }\n    else {\n        resultFunc = function () { return defaultValue; };\n    }\n    return resultFunc;\n}\n//# sourceMappingURL=dagre.js.map","\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./radial\"), exports);\n//# sourceMappingURL=index.js.map","\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RadialLayout = void 0;\nvar util_1 = require(\"../../util\");\nvar base_1 = require(\"../base\");\nvar mds_1 = __importDefault(require(\"./mds\"));\nvar radialNonoverlapForce_1 = __importDefault(require(\"./radialNonoverlapForce\"));\nfunction getWeightMatrix(M) {\n    var rows = M.length;\n    var cols = M[0].length;\n    var result = [];\n    for (var i = 0; i < rows; i++) {\n        var row = [];\n        for (var j = 0; j < cols; j++) {\n            if (M[i][j] !== 0) {\n                row.push(1 / (M[i][j] * M[i][j]));\n            }\n            else {\n                row.push(0);\n            }\n        }\n        result.push(row);\n    }\n    return result;\n}\nfunction getIndexById(array, id) {\n    var index = -1;\n    array.forEach(function (a, i) {\n        if (a.id === id) {\n            index = i;\n        }\n    });\n    return index;\n}\nfunction getEDistance(p1, p2) {\n    return Math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));\n}\n/**\n * 辐射状布局\n */\nvar RadialLayout = /** @class */ (function (_super) {\n    __extends(RadialLayout, _super);\n    function RadialLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 停止迭代的最大迭代数 */\n        _this.maxIteration = 1000;\n        /** 中心点，默认为数据中第一个点 */\n        _this.focusNode = null;\n        /** 每一圈半径 */\n        _this.unitRadius = null;\n        /** 默认边长度 */\n        _this.linkDistance = 50;\n        /** 是否防止重叠 */\n        _this.preventOverlap = false;\n        /** 是否必须是严格的 radial 布局，即每一层的节点严格布局在一个环上。preventOverlap 为 true 时生效 */\n        _this.strictRadial = true;\n        /** 防止重叠步骤的最大迭代次数 */\n        _this.maxPreventOverlapIteration = 200;\n        _this.sortStrength = 10;\n        _this.nodes = [];\n        _this.edges = [];\n        _this.updateCfg(options);\n        return _this;\n    }\n    RadialLayout.prototype.getDefaultCfg = function () {\n        return {\n            maxIteration: 1000,\n            focusNode: null,\n            unitRadius: null,\n            linkDistance: 50,\n            preventOverlap: false,\n            nodeSize: undefined,\n            nodeSpacing: undefined,\n            strictRadial: true,\n            maxPreventOverlapIteration: 200,\n            sortBy: undefined,\n            sortStrength: 10\n        };\n    };\n    /**\n     * 执行布局\n     */\n    RadialLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var edges = self.edges || [];\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (!self.center) {\n            self.center = [self.width / 2, self.height / 2];\n        }\n        var center = self.center;\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        var linkDistance = self.linkDistance;\n        // layout\n        var focusNode = null;\n        if (util_1.isString(self.focusNode)) {\n            var found = false;\n            for (var i = 0; i < nodes.length; i++) {\n                if (nodes[i].id === self.focusNode) {\n                    focusNode = nodes[i];\n                    self.focusNode = focusNode;\n                    found = true;\n                    i = nodes.length;\n                }\n            }\n            if (!found) {\n                focusNode = null;\n            }\n        }\n        else {\n            focusNode = self.focusNode;\n        }\n        // default focus node\n        if (!focusNode) {\n            focusNode = nodes[0];\n            self.focusNode = focusNode;\n        }\n        // the index of the focusNode in data\n        var focusIndex = getIndexById(nodes, focusNode.id);\n        self.focusIndex = focusIndex;\n        // the graph-theoretic distance (shortest path distance) matrix\n        var adjMatrix = util_1.getAdjMatrix({ nodes: nodes, edges: edges }, false);\n        var D = util_1.floydWarshall(adjMatrix);\n        var maxDistance = self.maxToFocus(D, focusIndex);\n        // replace first node in unconnected component to the circle at (maxDistance + 1)\n        self.handleInfinity(D, focusIndex, maxDistance + 1);\n        self.distances = D;\n        // the shortest path distance from each node to focusNode\n        var focusNodeD = D[focusIndex];\n        var width = self.width || 500;\n        var height = self.height || 500;\n        var semiWidth = width - center[0] > center[0] ? center[0] : width - center[0];\n        var semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];\n        if (semiWidth === 0) {\n            semiWidth = width / 2;\n        }\n        if (semiHeight === 0) {\n            semiHeight = height / 2;\n        }\n        // the maxRadius of the graph\n        var maxRadius = semiHeight > semiWidth ? semiWidth : semiHeight;\n        var maxD = Math.max.apply(Math, focusNodeD);\n        // the radius for each nodes away from focusNode\n        var radii = [];\n        focusNodeD.forEach(function (value, i) {\n            if (!self.unitRadius) {\n                self.unitRadius = maxRadius / maxD;\n            }\n            radii[i] = value * self.unitRadius;\n        });\n        self.radii = radii;\n        var eIdealD = self.eIdealDisMatrix();\n        // const eIdealD = scaleMatrix(D, linkDistance);\n        self.eIdealDistances = eIdealD;\n        // the weight matrix, Wij = 1 / dij^(-2)\n        var W = getWeightMatrix(eIdealD);\n        self.weights = W;\n        // the initial positions from mds\n        var mds = new mds_1.default({ linkDistance: linkDistance, distances: eIdealD });\n        var positions = mds.layout();\n        positions.forEach(function (p) {\n            if (util_1.isNaN(p[0])) {\n                p[0] = Math.random() * linkDistance;\n            }\n            if (util_1.isNaN(p[1])) {\n                p[1] = Math.random() * linkDistance;\n            }\n        });\n        self.positions = positions;\n        positions.forEach(function (p, i) {\n            nodes[i].x = p[0] + center[0];\n            nodes[i].y = p[1] + center[1];\n        });\n        // move the graph to origin, centered at focusNode\n        positions.forEach(function (p) {\n            p[0] -= positions[focusIndex][0];\n            p[1] -= positions[focusIndex][1];\n        });\n        self.run();\n        var preventOverlap = self.preventOverlap;\n        var nodeSize = self.nodeSize;\n        var nodeSizeFunc;\n        var strictRadial = self.strictRadial;\n        // stagger the overlapped nodes\n        if (preventOverlap) {\n            var nodeSpacing_1 = self.nodeSpacing;\n            var nodeSpacingFunc_1;\n            if (util_1.isNumber(nodeSpacing_1)) {\n                nodeSpacingFunc_1 = function () { return nodeSpacing_1; };\n            }\n            else if (util_1.isFunction(nodeSpacing_1)) {\n                nodeSpacingFunc_1 = nodeSpacing_1;\n            }\n            else {\n                nodeSpacingFunc_1 = function () { return 0; };\n            }\n            if (!nodeSize) {\n                nodeSizeFunc = function (d) {\n                    if (d.size) {\n                        if (util_1.isArray(d.size)) {\n                            var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                            return res + nodeSpacingFunc_1(d);\n                        }\n                        return d.size + nodeSpacingFunc_1(d);\n                    }\n                    return 10 + nodeSpacingFunc_1(d);\n                };\n            }\n            else if (util_1.isArray(nodeSize)) {\n                nodeSizeFunc = function (d) {\n                    var res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n                    return res + nodeSpacingFunc_1(d);\n                };\n            }\n            else {\n                nodeSizeFunc = function (d) { return nodeSize + nodeSpacingFunc_1(d); };\n            }\n            var nonoverlapForceParams = {\n                nodes: nodes,\n                nodeSizeFunc: nodeSizeFunc,\n                adjMatrix: adjMatrix,\n                positions: positions,\n                radii: radii,\n                height: height,\n                width: width,\n                strictRadial: strictRadial,\n                focusID: focusIndex,\n                iterations: self.maxPreventOverlapIteration || 200,\n                k: positions.length / 4.5\n            };\n            var nonoverlapForce = new radialNonoverlapForce_1.default(nonoverlapForceParams);\n            positions = nonoverlapForce.layout();\n        }\n        // move the graph to center\n        positions.forEach(function (p, i) {\n            nodes[i].x = p[0] + center[0];\n            nodes[i].y = p[1] + center[1];\n        });\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes: nodes,\n            edges: edges\n        };\n    };\n    RadialLayout.prototype.run = function () {\n        var self = this;\n        var maxIteration = self.maxIteration;\n        var positions = self.positions || [];\n        var W = self.weights || [];\n        var eIdealDis = self.eIdealDistances || [];\n        var radii = self.radii || [];\n        for (var i = 0; i <= maxIteration; i++) {\n            var param = i / maxIteration;\n            self.oneIteration(param, positions, radii, eIdealDis, W);\n        }\n    };\n    RadialLayout.prototype.oneIteration = function (param, positions, radii, D, W) {\n        var self = this;\n        var vparam = 1 - param;\n        var focusIndex = self.focusIndex;\n        positions.forEach(function (v, i) {\n            // v\n            var originDis = getEDistance(v, [0, 0]);\n            var reciODis = originDis === 0 ? 0 : 1 / originDis;\n            if (i === focusIndex) {\n                return;\n            }\n            var xMolecule = 0;\n            var yMolecule = 0;\n            var denominator = 0;\n            positions.forEach(function (u, j) {\n                // u\n                if (i === j) {\n                    return;\n                }\n                // the euclidean distance between v and u\n                var edis = getEDistance(v, u);\n                var reciEdis = edis === 0 ? 0 : 1 / edis;\n                var idealDis = D[j][i];\n                // same for x and y\n                denominator += W[i][j];\n                // x\n                xMolecule += W[i][j] * (u[0] + idealDis * (v[0] - u[0]) * reciEdis);\n                // y\n                yMolecule += W[i][j] * (u[1] + idealDis * (v[1] - u[1]) * reciEdis);\n            });\n            var reciR = radii[i] === 0 ? 0 : 1 / radii[i];\n            denominator *= vparam;\n            denominator += param * reciR * reciR;\n            // x\n            xMolecule *= vparam;\n            xMolecule += param * reciR * v[0] * reciODis;\n            v[0] = xMolecule / denominator;\n            // y\n            yMolecule *= vparam;\n            yMolecule += param * reciR * v[1] * reciODis;\n            v[1] = yMolecule / denominator;\n        });\n    };\n    RadialLayout.prototype.eIdealDisMatrix = function () {\n        var self = this;\n        var nodes = self.nodes;\n        if (!nodes)\n            return [];\n        var D = self.distances;\n        var linkDis = self.linkDistance;\n        var radii = self.radii || [];\n        var unitRadius = self.unitRadius || 50;\n        var result = [];\n        if (D) {\n            D.forEach(function (row, i) {\n                var newRow = [];\n                row.forEach(function (v, j) {\n                    if (i === j) {\n                        newRow.push(0);\n                    }\n                    else if (radii[i] === radii[j]) {\n                        // i and j are on the same circle\n                        if (self.sortBy === \"data\") {\n                            // sort the nodes on the same circle according to the ordering of the data\n                            newRow.push((v * (Math.abs(i - j) * self.sortStrength)) /\n                                (radii[i] / unitRadius));\n                        }\n                        else if (self.sortBy) {\n                            // sort the nodes on the same circle according to the attributes\n                            var iValue = nodes[i][self.sortBy] || 0;\n                            var jValue = nodes[j][self.sortBy] || 0;\n                            if (util_1.isString(iValue)) {\n                                iValue = iValue.charCodeAt(0);\n                            }\n                            if (util_1.isString(jValue)) {\n                                jValue = jValue.charCodeAt(0);\n                            }\n                            newRow.push((v * (Math.abs(iValue - jValue) * self.sortStrength)) /\n                                (radii[i] / unitRadius));\n                        }\n                        else {\n                            newRow.push((v * linkDis) / (radii[i] / unitRadius));\n                        }\n                    }\n                    else {\n                        // i and j are on different circle\n                        // i and j are on different circle\n                        var link = (linkDis + unitRadius) / 2;\n                        newRow.push(v * link);\n                    }\n                });\n                result.push(newRow);\n            });\n        }\n        return result;\n    };\n    RadialLayout.prototype.handleInfinity = function (matrix, focusIndex, step) {\n        var length = matrix.length;\n        // 遍历 matrix 中遍历 focus 对应行\n        for (var i = 0; i < length; i++) {\n            // matrix 关注点对应行的 Inf 项\n            if (matrix[focusIndex][i] === Infinity) {\n                matrix[focusIndex][i] = step;\n                matrix[i][focusIndex] = step;\n                // 遍历 matrix 中的 i 行，i 行中非 Inf 项若在 focus 行为 Inf，则替换 focus 行的那个 Inf\n                for (var j = 0; j < length; j++) {\n                    if (matrix[i][j] !== Infinity && matrix[focusIndex][j] === Infinity) {\n                        matrix[focusIndex][j] = step + matrix[i][j];\n                        matrix[j][focusIndex] = step + matrix[i][j];\n                    }\n                }\n            }\n        }\n        // 处理其他行的 Inf。根据该行对应点与 focus 距离以及 Inf 项点 与 focus 距离，决定替换值\n        for (var i = 0; i < length; i++) {\n            if (i === focusIndex) {\n                continue;\n            }\n            for (var j = 0; j < length; j++) {\n                if (matrix[i][j] === Infinity) {\n                    var minus = Math.abs(matrix[focusIndex][i] - matrix[focusIndex][j]);\n                    minus = minus === 0 ? 1 : minus;\n                    matrix[i][j] = minus;\n                }\n            }\n        }\n    };\n    RadialLayout.prototype.maxToFocus = function (matrix, focusIndex) {\n        var max = 0;\n        for (var i = 0; i < matrix[focusIndex].length; i++) {\n            if (matrix[focusIndex][i] === Infinity) {\n                continue;\n            }\n            max = matrix[focusIndex][i] > max ? matrix[focusIndex][i] : max;\n        }\n        return max;\n    };\n    RadialLayout.prototype.getType = function () {\n        return \"radial\";\n    };\n    return RadialLayout;\n}(base_1.Base));\nexports.RadialLayout = RadialLayout;\n//# sourceMappingURL=radial.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ml_matrix_1 = require(\"ml-matrix\");\nvar MDS = /** @class */ (function () {\n    function MDS(params) {\n        this.distances = params.distances;\n        this.dimension = params.dimension || 2;\n        this.linkDistance = params.linkDistance;\n    }\n    MDS.prototype.layout = function () {\n        var self = this;\n        var dimension = self.dimension, distances = self.distances, linkDistance = self.linkDistance;\n        try {\n            // square distances\n            var M = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5);\n            // double centre the rows/columns\n            var rowMeans = M.mean('row');\n            var colMeans = M.mean('column');\n            var totalMean = M.mean();\n            M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);\n            // take the SVD of the double centred matrix, and return the\n            // points from it\n            var ret = new ml_matrix_1.SingularValueDecomposition(M);\n            var eigenValues_1 = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();\n            return ret.leftSingularVectors.toJSON().map(function (row) {\n                return ml_matrix_1.Matrix.mul([row], [eigenValues_1]).toJSON()[0].splice(0, dimension);\n            });\n        }\n        catch (_a) {\n            var res = [];\n            for (var i = 0; i < distances.length; i++) {\n                var x = Math.random() * linkDistance;\n                var y = Math.random() * linkDistance;\n                res.push([x, y]);\n            }\n            return res;\n        }\n    };\n    return MDS;\n}());\nexports.default = MDS;\n//# sourceMappingURL=mds.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SPEED_DIVISOR = 800;\nvar RadialNonoverlapForce = /** @class */ (function () {\n    function RadialNonoverlapForce(params) {\n        this.disp = [];\n        this.positions = params.positions;\n        this.adjMatrix = params.adjMatrix;\n        this.focusID = params.focusID;\n        this.radii = params.radii;\n        this.iterations = params.iterations || 10;\n        this.height = params.height || 10;\n        this.width = params.width || 10;\n        this.speed = params.speed || 100;\n        this.gravity = params.gravity || 10;\n        this.nodeSizeFunc = params.nodeSizeFunc;\n        this.k = params.k || 5;\n        this.strictRadial = params.strictRadial;\n        this.nodes = params.nodes;\n    }\n    RadialNonoverlapForce.prototype.layout = function () {\n        var self = this;\n        var positions = self.positions;\n        var disp = [];\n        var iterations = self.iterations;\n        var maxDisplace = self.width / 10;\n        self.maxDisplace = maxDisplace;\n        self.disp = disp;\n        for (var i = 0; i < iterations; i++) {\n            positions.forEach(function (_, k) {\n                disp[k] = { x: 0, y: 0 };\n            });\n            // 给重叠的节点增加斥力\n            self.getRepulsion();\n            self.updatePositions();\n        }\n        return positions;\n    };\n    RadialNonoverlapForce.prototype.getRepulsion = function () {\n        var self = this;\n        var positions = self.positions;\n        var nodes = self.nodes;\n        var disp = self.disp;\n        var k = self.k;\n        var radii = self.radii || [];\n        positions.forEach(function (v, i) {\n            disp[i] = { x: 0, y: 0 };\n            positions.forEach(function (u, j) {\n                if (i === j) {\n                    return;\n                }\n                // v and u are not on the same circle, return\n                if (radii[i] !== radii[j]) {\n                    return;\n                }\n                var vecx = v[0] - u[0];\n                var vecy = v[1] - u[1];\n                var vecLength = Math.sqrt(vecx * vecx + vecy * vecy);\n                if (vecLength === 0) {\n                    vecLength = 1;\n                    var sign = i > j ? 1 : -1;\n                    vecx = 0.01 * sign;\n                    vecy = 0.01 * sign;\n                }\n                // these two nodes overlap\n                if (vecLength < self.nodeSizeFunc(nodes[i]) / 2 + self.nodeSizeFunc(nodes[j]) / 2) {\n                    var common = (k * k) / vecLength;\n                    disp[i].x += (vecx / vecLength) * common;\n                    disp[i].y += (vecy / vecLength) * common;\n                }\n            });\n        });\n    };\n    RadialNonoverlapForce.prototype.updatePositions = function () {\n        var self = this;\n        var positions = self.positions;\n        var disp = self.disp;\n        var speed = self.speed;\n        var strictRadial = self.strictRadial;\n        var f = self.focusID;\n        var maxDisplace = self.maxDisplace || self.width / 10;\n        if (strictRadial) {\n            disp.forEach(function (di, i) {\n                var vx = positions[i][0] - positions[f][0];\n                var vy = positions[i][1] - positions[f][1];\n                var vLength = Math.sqrt(vx * vx + vy * vy);\n                var vpx = vy / vLength;\n                var vpy = -vx / vLength;\n                var diLength = Math.sqrt(di.x * di.x + di.y * di.y);\n                var alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);\n                if (alpha > Math.PI / 2) {\n                    alpha -= Math.PI / 2;\n                    vpx *= -1;\n                    vpy *= -1;\n                }\n                var tdispLength = Math.cos(alpha) * diLength;\n                di.x = vpx * tdispLength;\n                di.y = vpy * tdispLength;\n            });\n        }\n        // move\n        var radii = self.radii;\n        positions.forEach(function (n, i) {\n            if (i === f) {\n                return;\n            }\n            var distLength = Math.sqrt(disp[i].x * disp[i].x + disp[i].y * disp[i].y);\n            if (distLength > 0 && i !== f) {\n                var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n                n[0] += (disp[i].x / distLength) * limitedDist;\n                n[1] += (disp[i].y / distLength) * limitedDist;\n                if (strictRadial) {\n                    var vx = n[0] - positions[f][0];\n                    var vy = n[1] - positions[f][1];\n                    var nfDis = Math.sqrt(vx * vx + vy * vy);\n                    vx = (vx / nfDis) * radii[i];\n                    vy = (vy / nfDis) * radii[i];\n                    n[0] = positions[f][0] + vx;\n                    n[1] = positions[f][1] + vy;\n                }\n            }\n        });\n    };\n    return RadialNonoverlapForce;\n}());\nexports.default = RadialNonoverlapForce;\n//# sourceMappingURL=radialNonoverlapForce.js.map","\n/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConcentricLayout = void 0;\nvar util_1 = require(\"../util\");\nvar base_1 = require(\"./base\");\n/**\n * 同心圆布局\n */\nvar ConcentricLayout = /** @class */ (function (_super) {\n    __extends(ConcentricLayout, _super);\n    function ConcentricLayout(options) {\n        var _this = _super.call(this) || this;\n        _this.nodeSize = 30;\n        /** min spacing between outside of nodes (used for radius adjustment) */\n        _this.minNodeSpacing = 10;\n        /** prevents node overlap, may overflow boundingBox if not enough space */\n        _this.preventOverlap = false;\n        /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n        _this.equidistant = false;\n        /** where nodes start in radians */\n        _this.startAngle = (3 / 2) * Math.PI;\n        /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n        _this.clockwise = true;\n        /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n        _this.sortBy = \"degree\";\n        _this.nodes = [];\n        _this.edges = [];\n        _this.width = 300;\n        _this.height = 300;\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        _this.updateCfg(options);\n        return _this;\n    }\n    ConcentricLayout.prototype.getDefaultCfg = function () {\n        return {\n            nodeSize: 30,\n            minNodeSpacing: 10,\n            preventOverlap: false,\n            sweep: undefined,\n            equidistant: false,\n            startAngle: (3 / 2) * Math.PI,\n            clockwise: true,\n            maxLevelDiff: undefined,\n            sortBy: \"degree\"\n        };\n    };\n    /**\n     * 执行布局\n     */\n    ConcentricLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var edges = self.edges;\n        var n = nodes.length;\n        if (n === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (!self.center) {\n            self.center = [self.width / 2, self.height / 2];\n        }\n        var center = self.center;\n        if (n === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        var layoutNodes = [];\n        var maxNodeSize;\n        if (util_1.isArray(self.nodeSize)) {\n            maxNodeSize = Math.max(self.nodeSize[0], self.nodeSize[1]);\n        }\n        else {\n            maxNodeSize = self.nodeSize;\n        }\n        nodes.forEach(function (node) {\n            layoutNodes.push(node);\n            var nodeSize = maxNodeSize;\n            if (util_1.isArray(node.size)) {\n                nodeSize = Math.max(node.size[0], node.size[1]);\n            }\n            else if (util_1.isNumber(node.size)) {\n                nodeSize = node.size;\n            }\n            maxNodeSize = Math.max(maxNodeSize, nodeSize);\n        });\n        self.clockwise =\n            self.counterclockwise !== undefined\n                ? !self.counterclockwise\n                : self.clockwise;\n        // layout\n        var nodeMap = {};\n        var indexMap = {};\n        layoutNodes.forEach(function (node, i) {\n            nodeMap[node.id] = node;\n            indexMap[node.id] = i;\n        });\n        // get the node degrees\n        if (self.sortBy === \"degree\" ||\n            !util_1.isString(self.sortBy) ||\n            layoutNodes[0][self.sortBy] === undefined) {\n            self.sortBy = \"degree\";\n            if (!util_1.isNumber(nodes[0].degree)) {\n                var values_1 = util_1.getDegree(nodes.length, indexMap, edges);\n                layoutNodes.forEach(function (node, i) {\n                    node.degree = values_1[i];\n                });\n            }\n        }\n        // sort nodes by value\n        layoutNodes.sort(function (n1, n2) {\n            return n2[self.sortBy] - n1[self.sortBy];\n        });\n        self.maxValueNode = layoutNodes[0];\n        self.maxLevelDiff =\n            self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4;\n        // put the values into levels\n        var levels = [[]];\n        var currentLevel = levels[0];\n        layoutNodes.forEach(function (node) {\n            if (currentLevel.length > 0) {\n                var diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);\n                if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n                    currentLevel = [];\n                    levels.push(currentLevel);\n                }\n            }\n            currentLevel.push(node);\n        });\n        // create positions for levels\n        var minDist = maxNodeSize + self.minNodeSpacing; // min dist between nodes\n        if (!self.preventOverlap) {\n            // then strictly constrain to bb\n            var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n            var maxR = Math.min(self.width, self.height) / 2 - minDist;\n            var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n            minDist = Math.min(minDist, rStep);\n        }\n        // find the metrics for each level\n        var r = 0;\n        levels.forEach(function (level) {\n            var sweep = self.sweep;\n            if (sweep === undefined) {\n                sweep = 2 * Math.PI - (2 * Math.PI) / level.length;\n            }\n            var dTheta = (level.dTheta = sweep / Math.max(1, level.length - 1));\n            // calculate the radius\n            if (level.length > 1 && self.preventOverlap) {\n                // but only if more than one node (can't overlap)\n                var dcos = Math.cos(dTheta) - Math.cos(0);\n                var dsin = Math.sin(dTheta) - Math.sin(0);\n                var rMin = Math.sqrt((minDist * minDist) / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n                r = Math.max(rMin, r);\n            }\n            level.r = r;\n            r += minDist;\n        });\n        if (self.equidistant) {\n            var rDeltaMax_1 = 0;\n            var rr_1 = 0;\n            for (var i = 0; i < levels.length; i++) {\n                var level = levels[i];\n                var rDelta = level.r - rr_1;\n                rDeltaMax_1 = Math.max(rDeltaMax_1, rDelta);\n            }\n            rr_1 = 0;\n            levels.forEach(function (level, i) {\n                if (i === 0) {\n                    rr_1 = level.r;\n                }\n                level.r = rr_1;\n                rr_1 += rDeltaMax_1;\n            });\n        }\n        // calculate the node positions\n        levels.forEach(function (level) {\n            var dTheta = level.dTheta;\n            var rr = level.r;\n            level.forEach(function (node, j) {\n                var theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n                node.x = center[0] + rr * Math.cos(theta);\n                node.y = center[1] + rr * Math.sin(theta);\n            });\n        });\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes: nodes,\n            edges: edges\n        };\n    };\n    ConcentricLayout.prototype.getType = function () {\n        return \"concentric\";\n    };\n    return ConcentricLayout;\n}(base_1.Base));\nexports.ConcentricLayout = ConcentricLayout;\n//# sourceMappingURL=concentric.js.map","\n/**\n * @fileOverview MDS layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MDSLayout = void 0;\nvar ml_matrix_1 = require(\"ml-matrix\");\nvar util_1 = require(\"../util\");\nvar base_1 = require(\"./base\");\n/**\n * mds 布局\n */\nvar MDSLayout = /** @class */ (function (_super) {\n    __extends(MDSLayout, _super);\n    function MDSLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 布局中心 */\n        _this.center = [0, 0];\n        /** 边长度 */\n        _this.linkDistance = 50;\n        _this.nodes = [];\n        _this.edges = [];\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        _this.updateCfg(options);\n        return _this;\n    }\n    MDSLayout.prototype.getDefaultCfg = function () {\n        return {\n            center: [0, 0],\n            linkDistance: 50\n        };\n    };\n    /**\n     * 执行布局\n     */\n    MDSLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes, _a = self.edges, edges = _a === void 0 ? [] : _a;\n        var center = self.center;\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        var linkDistance = self.linkDistance;\n        // the graph-theoretic distance (shortest path distance) matrix\n        var adjMatrix = util_1.getAdjMatrix({ nodes: nodes, edges: edges }, false);\n        var distances = util_1.floydWarshall(adjMatrix);\n        self.handleInfinity(distances);\n        // scale the ideal edge length acoording to linkDistance\n        var scaledD = util_1.scaleMatrix(distances, linkDistance);\n        self.scaledDistances = scaledD;\n        // get positions by MDS\n        var positions = self.runMDS();\n        self.positions = positions;\n        positions.forEach(function (p, i) {\n            nodes[i].x = p[0] + center[0];\n            nodes[i].y = p[1] + center[1];\n        });\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes: nodes,\n            edges: edges\n        };\n    };\n    /**\n     * mds 算法\n     * @return {array} positions 计算后的节点位置数组\n     */\n    MDSLayout.prototype.runMDS = function () {\n        var self = this;\n        var dimension = 2;\n        var distances = self.scaledDistances;\n        // square distances\n        var M = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5);\n        // double centre the rows/columns\n        var rowMeans = M.mean(\"row\");\n        var colMeans = M.mean(\"column\");\n        var totalMean = M.mean();\n        M.add(totalMean)\n            .subRowVector(rowMeans)\n            .subColumnVector(colMeans);\n        // take the SVD of the double centred matrix, and return the\n        // points from it\n        var ret = new ml_matrix_1.SingularValueDecomposition(M);\n        var eigenValues = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();\n        return ret.leftSingularVectors.toJSON().map(function (row) {\n            return ml_matrix_1.Matrix.mul([row], [eigenValues])\n                .toJSON()[0]\n                .splice(0, dimension);\n        });\n    };\n    MDSLayout.prototype.handleInfinity = function (distances) {\n        var maxDistance = -999999;\n        distances.forEach(function (row) {\n            row.forEach(function (value) {\n                if (value === Infinity) {\n                    return;\n                }\n                if (maxDistance < value) {\n                    maxDistance = value;\n                }\n            });\n        });\n        distances.forEach(function (row, i) {\n            row.forEach(function (value, j) {\n                if (value === Infinity) {\n                    distances[i][j] = maxDistance;\n                }\n            });\n        });\n    };\n    MDSLayout.prototype.getType = function () {\n        return \"mds\";\n    };\n    return MDSLayout;\n}(base_1.Base));\nexports.MDSLayout = MDSLayout;\n//# sourceMappingURL=mds.js.map","\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FruchtermanLayout = void 0;\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util\");\nvar SPEED_DIVISOR = 800;\n/**\n * fruchterman 布局\n */\nvar FruchtermanLayout = /** @class */ (function (_super) {\n    __extends(FruchtermanLayout, _super);\n    function FruchtermanLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 停止迭代的最大迭代数 */\n        _this.maxIteration = 1000;\n        /** 重力大小，影响图的紧凑程度 */\n        _this.gravity = 10;\n        /** 速度 */\n        _this.speed = 5;\n        /** 是否产生聚类力 */\n        _this.clustering = false;\n        /** 聚类力大小 */\n        _this.clusterGravity = 10;\n        _this.nodes = [];\n        _this.edges = [];\n        _this.width = 300;\n        _this.height = 300;\n        _this.nodeMap = {};\n        _this.nodeIdxMap = {};\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        /** 每次迭代结束的回调函数 */\n        _this.tick = function () { };\n        _this.updateCfg(options);\n        return _this;\n    }\n    FruchtermanLayout.prototype.getDefaultCfg = function () {\n        return {\n            maxIteration: 1000,\n            gravity: 10,\n            speed: 1,\n            clustering: false,\n            clusterGravity: 10\n        };\n    };\n    /**\n     * 执行布局\n     */\n    FruchtermanLayout.prototype.execute = function () {\n        var _this = this;\n        var self = this;\n        var nodes = self.nodes;\n        if (self.timeInterval !== undefined && typeof window !== \"undefined\") {\n            window.clearInterval(self.timeInterval);\n        }\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        if (!self.center) {\n            self.center = [self.width / 2, self.height / 2];\n        }\n        var center = self.center;\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        var nodeMap = {};\n        var nodeIdxMap = {};\n        nodes.forEach(function (node, i) {\n            if (!util_1.isNumber(node.x))\n                node.x = Math.random() * _this.width;\n            if (!util_1.isNumber(node.y))\n                node.y = Math.random() * _this.height;\n            nodeMap[node.id] = node;\n            nodeIdxMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.nodeIdxMap = nodeIdxMap;\n        // layout\n        return self.run();\n    };\n    FruchtermanLayout.prototype.run = function () {\n        var self = this;\n        var nodes = self.nodes;\n        if (!nodes)\n            return;\n        var edges = self.edges;\n        var maxIteration = self.maxIteration;\n        var center = self.center;\n        var area = self.height * self.width;\n        var maxDisplace = Math.sqrt(area) / 10;\n        var k2 = area / (nodes.length + 1);\n        var k = Math.sqrt(k2);\n        var gravity = self.gravity;\n        var speed = self.speed;\n        var clustering = self.clustering;\n        var clusterMap = {};\n        if (clustering) {\n            nodes.forEach(function (n) {\n                if (clusterMap[n.cluster] === undefined) {\n                    var cluster = {\n                        name: n.cluster,\n                        cx: 0,\n                        cy: 0,\n                        count: 0\n                    };\n                    clusterMap[n.cluster] = cluster;\n                }\n                var c = clusterMap[n.cluster];\n                if (util_1.isNumber(n.x)) {\n                    c.cx += n.x;\n                }\n                if (util_1.isNumber(n.y)) {\n                    c.cy += n.y;\n                }\n                c.count++;\n            });\n            for (var key in clusterMap) {\n                clusterMap[key].cx /= clusterMap[key].count;\n                clusterMap[key].cy /= clusterMap[key].count;\n            }\n        }\n        if (typeof window === \"undefined\")\n            return;\n        var iter = 0;\n        // interval for render the result after each iteration\n        this.timeInterval = window.setInterval(function () {\n            if (!nodes)\n                return;\n            // for (let i = 0; i < maxIteration; i++) {\n            var displacements = [];\n            nodes.forEach(function (_, j) {\n                displacements[j] = { x: 0, y: 0 };\n            });\n            self.applyCalculate(nodes, edges, displacements, k, k2);\n            // gravity for clusters\n            if (clustering) {\n                var clusterGravity_1 = self.clusterGravity || gravity;\n                nodes.forEach(function (n, j) {\n                    if (!util_1.isNumber(n.x) || !util_1.isNumber(n.y))\n                        return;\n                    var c = clusterMap[n.cluster];\n                    var distLength = Math.sqrt((n.x - c.cx) * (n.x - c.cx) + (n.y - c.cy) * (n.y - c.cy));\n                    var gravityForce = k * clusterGravity_1;\n                    displacements[j].x -= (gravityForce * (n.x - c.cx)) / distLength;\n                    displacements[j].y -= (gravityForce * (n.y - c.cy)) / distLength;\n                });\n                for (var key in clusterMap) {\n                    clusterMap[key].cx = 0;\n                    clusterMap[key].cy = 0;\n                    clusterMap[key].count = 0;\n                }\n                nodes.forEach(function (n) {\n                    var c = clusterMap[n.cluster];\n                    if (util_1.isNumber(n.x)) {\n                        c.cx += n.x;\n                    }\n                    if (util_1.isNumber(n.y)) {\n                        c.cy += n.y;\n                    }\n                    c.count++;\n                });\n                for (var key in clusterMap) {\n                    clusterMap[key].cx /= clusterMap[key].count;\n                    clusterMap[key].cy /= clusterMap[key].count;\n                }\n            }\n            // gravity\n            nodes.forEach(function (n, j) {\n                if (!util_1.isNumber(n.x) || !util_1.isNumber(n.y))\n                    return;\n                var gravityForce = 0.01 * k * gravity;\n                displacements[j].x -= gravityForce * (n.x - center[0]);\n                displacements[j].y -= gravityForce * (n.y - center[1]);\n            });\n            // move\n            nodes.forEach(function (n, j) {\n                if (util_1.isNumber(n.fx) && util_1.isNumber(n.fy)) {\n                    n.x = n.fx;\n                    n.y = n.fy;\n                    return;\n                }\n                if (!util_1.isNumber(n.x) || !util_1.isNumber(n.y))\n                    return;\n                var distLength = Math.sqrt(displacements[j].x * displacements[j].x +\n                    displacements[j].y * displacements[j].y);\n                if (distLength > 0) {\n                    // && !n.isFixed()\n                    var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n                    n.x += (displacements[j].x / distLength) * limitedDist;\n                    n.y += (displacements[j].y / distLength) * limitedDist;\n                }\n            });\n            if (self.tick)\n                self.tick();\n            iter++;\n            if (iter >= maxIteration) {\n                if (self.onLayoutEnd)\n                    self.onLayoutEnd();\n                window.clearInterval(self.timeInterval);\n            }\n        }, 0);\n        return {\n            nodes: nodes,\n            edges: edges\n        };\n    };\n    FruchtermanLayout.prototype.applyCalculate = function (nodes, edges, displacements, k, k2) {\n        var self = this;\n        self.calRepulsive(nodes, displacements, k2);\n        if (edges)\n            self.calAttractive(edges, displacements, k);\n    };\n    FruchtermanLayout.prototype.calRepulsive = function (nodes, displacements, k2) {\n        nodes.forEach(function (v, i) {\n            displacements[i] = { x: 0, y: 0 };\n            nodes.forEach(function (u, j) {\n                if (i === j) {\n                    return;\n                }\n                if (!util_1.isNumber(v.x) ||\n                    !util_1.isNumber(u.x) ||\n                    !util_1.isNumber(v.y) ||\n                    !util_1.isNumber(u.y))\n                    return;\n                var vecX = v.x - u.x;\n                var vecY = v.y - u.y;\n                var vecLengthSqr = vecX * vecX + vecY * vecY;\n                if (vecLengthSqr === 0) {\n                    vecLengthSqr = 1;\n                    var sign = i > j ? 1 : -1;\n                    vecX = 0.01 * sign;\n                    vecY = 0.01 * sign;\n                }\n                var common = k2 / vecLengthSqr;\n                displacements[i].x += vecX * common;\n                displacements[i].y += vecY * common;\n            });\n        });\n    };\n    FruchtermanLayout.prototype.calAttractive = function (edges, displacements, k) {\n        var _this = this;\n        edges.forEach(function (e) {\n            if (!e.source || !e.target)\n                return;\n            var uIndex = _this.nodeIdxMap[e.source];\n            var vIndex = _this.nodeIdxMap[e.target];\n            if (uIndex === vIndex) {\n                return;\n            }\n            var u = _this.nodeMap[e.source];\n            var v = _this.nodeMap[e.target];\n            if (!util_1.isNumber(v.x) || !util_1.isNumber(u.x) || !util_1.isNumber(v.y) || !util_1.isNumber(u.y))\n                return;\n            var vecX = v.x - u.x;\n            var vecY = v.y - u.y;\n            var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);\n            var common = (vecLength * vecLength) / k;\n            displacements[vIndex].x -= (vecX / vecLength) * common;\n            displacements[vIndex].y -= (vecY / vecLength) * common;\n            displacements[uIndex].x += (vecX / vecLength) * common;\n            displacements[uIndex].y += (vecY / vecLength) * common;\n        });\n    };\n    FruchtermanLayout.prototype.stop = function () {\n        if (this.timeInterval && typeof window !== \"undefined\") {\n            window.clearInterval(this.timeInterval);\n        }\n    };\n    FruchtermanLayout.prototype.destroy = function () {\n        var self = this;\n        self.stop();\n        self.tick = null;\n        self.nodes = null;\n        self.edges = null;\n        self.destroyed = true;\n    };\n    FruchtermanLayout.prototype.getType = function () {\n        return \"fruchterman\";\n    };\n    return FruchtermanLayout;\n}(base_1.Base));\nexports.FruchtermanLayout = FruchtermanLayout;\n//# sourceMappingURL=fruchterman.js.map","\n// @ts-nocheck\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FruchtermanGPULayout = void 0;\nvar base_1 = require(\"../base\");\nvar util_1 = require(\"../../util\");\n// @ts-ignore\nvar g_webgpu_1 = require(\"@antv/g-webgpu\");\n// compile at runtime in dev mode\nvar gpu_1 = require(\"../../util/gpu\");\n// use compiled bundle in prod mode\nvar fruchtermanShader_1 = require(\"./fruchtermanShader\");\nvar constants_1 = require(\"../constants\");\n/**\n * fruchterman 布局\n */\nvar FruchtermanGPULayout = /** @class */ (function (_super) {\n    __extends(FruchtermanGPULayout, _super);\n    function FruchtermanGPULayout(options) {\n        var _this = _super.call(this) || this;\n        /** 停止迭代的最大迭代数 */\n        _this.maxIteration = 1000;\n        /** 重力大小，影响图的紧凑程度 */\n        _this.gravity = 10;\n        /** 速度 */\n        _this.speed = 1;\n        /** 是否产生聚类力 */\n        _this.clustering = false;\n        /** 根据哪个字段聚类 */\n        _this.clusterField = \"cluster\";\n        /** 聚类力大小 */\n        _this.clusterGravity = 10;\n        /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n        _this.workerEnabled = false;\n        _this.nodes = [];\n        _this.edges = [];\n        _this.width = 300;\n        _this.height = 300;\n        _this.nodeMap = {};\n        _this.nodeIdxMap = {};\n        _this.updateCfg(options);\n        return _this;\n    }\n    FruchtermanGPULayout.prototype.getDefaultCfg = function () {\n        return {\n            maxIteration: 1000,\n            gravity: 10,\n            speed: 1,\n            clustering: false,\n            clusterGravity: 10\n        };\n    };\n    /**\n     * 执行布局\n     */\n    FruchtermanGPULayout.prototype.execute = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var self, nodes, center, nodeMap, nodeIdxMap;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        self = this;\n                        nodes = self.nodes;\n                        if (!nodes || nodes.length === 0) {\n                            if (self.onLayoutEnd)\n                                self.onLayoutEnd();\n                            return [2 /*return*/];\n                        }\n                        if (!self.width && typeof window !== \"undefined\") {\n                            self.width = window.innerWidth;\n                        }\n                        if (!self.height && typeof window !== \"undefined\") {\n                            self.height = window.innerHeight;\n                        }\n                        if (!self.center) {\n                            self.center = [self.width / 2, self.height / 2];\n                        }\n                        center = self.center;\n                        if (nodes.length === 1) {\n                            nodes[0].x = center[0];\n                            nodes[0].y = center[1];\n                            if (self.onLayoutEnd)\n                                self.onLayoutEnd();\n                            return [2 /*return*/];\n                        }\n                        nodeMap = {};\n                        nodeIdxMap = {};\n                        nodes.forEach(function (node, i) {\n                            if (!util_1.isNumber(node.x))\n                                node.x = Math.random() * _this.width;\n                            if (!util_1.isNumber(node.y))\n                                node.y = Math.random() * _this.height;\n                            nodeMap[node.id] = node;\n                            nodeIdxMap[node.id] = i;\n                        });\n                        self.nodeMap = nodeMap;\n                        self.nodeIdxMap = nodeIdxMap;\n                        // layout\n                        return [4 /*yield*/, self.run()];\n                    case 1:\n                        // layout\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FruchtermanGPULayout.prototype.executeWithWorker = function (canvas, ctx) {\n        return __awaiter(this, void 0, void 0, function () {\n            var self, nodes, center, nodeMap, nodeIdxMap;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        self = this;\n                        nodes = self.nodes;\n                        center = self.center;\n                        if (!nodes || nodes.length === 0) {\n                            return [2 /*return*/];\n                        }\n                        if (nodes.length === 1) {\n                            nodes[0].x = center[0];\n                            nodes[0].y = center[1];\n                            return [2 /*return*/];\n                        }\n                        nodeMap = {};\n                        nodeIdxMap = {};\n                        nodes.forEach(function (node, i) {\n                            if (!util_1.isNumber(node.x))\n                                node.x = Math.random() * _this.width;\n                            if (!util_1.isNumber(node.y))\n                                node.y = Math.random() * _this.height;\n                            nodeMap[node.id] = node;\n                            nodeIdxMap[node.id] = i;\n                        });\n                        self.nodeMap = nodeMap;\n                        self.nodeIdxMap = nodeIdxMap;\n                        // layout\n                        return [4 /*yield*/, self.run(canvas, ctx)];\n                    case 1:\n                        // layout\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FruchtermanGPULayout.prototype.run = function (canvas, ctx) {\n        return __awaiter(this, void 0, void 0, function () {\n            var self, nodes, edges, maxIteration, center, area, maxDisplace, k2, k, speed, clustering, _a, attributeArray, clusterCount, numParticles, _b, maxEdgePerVetex, nodesEdgesArray, workerEnabled, world, onLayoutEnd, clusterCenters, i, kernelFruchterman, kernelCluster, execute;\n            var _this = this;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0:\n                        self = this;\n                        nodes = self.nodes;\n                        edges = self.edges;\n                        maxIteration = self.maxIteration;\n                        center = self.center;\n                        area = self.height * self.width;\n                        maxDisplace = Math.sqrt(area) / 10;\n                        k2 = area / (nodes.length + 1);\n                        k = Math.sqrt(k2);\n                        speed = self.speed;\n                        clustering = self.clustering;\n                        _a = gpu_1.attributesToTextureData([self.clusterField], nodes), attributeArray = _a.array, clusterCount = _a.count;\n                        // pushing the fx and fy\n                        nodes.forEach(function (node, i) {\n                            var fx = 0, fy = 0;\n                            if (util_1.isNumber(node.fx) && util_1.isNumber(node.fy)) {\n                                fx = node.fx || 0.001;\n                                fy = node.fy || 0.001;\n                            }\n                            attributeArray[4 * i + 1] = fx;\n                            attributeArray[4 * i + 2] = fy;\n                        });\n                        numParticles = nodes.length;\n                        _b = gpu_1.buildTextureData(nodes, edges), maxEdgePerVetex = _b.maxEdgePerVetex, nodesEdgesArray = _b.array;\n                        workerEnabled = self.workerEnabled;\n                        if (workerEnabled) {\n                            world = g_webgpu_1.World.create({\n                                canvas: canvas,\n                                engineOptions: {\n                                    supportCompute: true\n                                }\n                            });\n                        }\n                        else {\n                            world = g_webgpu_1.World.create({\n                                engineOptions: {\n                                    supportCompute: true\n                                }\n                            });\n                        }\n                        onLayoutEnd = self.onLayoutEnd;\n                        clusterCenters = [];\n                        for (i = 0; i < clusterCount; i++) {\n                            clusterCenters.push(0, 0, 0, 0);\n                        }\n                        kernelFruchterman = world\n                            .createKernel(fruchtermanShader_1.fruchtermanBundle)\n                            .setDispatch([numParticles, 1, 1])\n                            .setBinding({\n                            u_Data: nodesEdgesArray,\n                            u_K: k,\n                            u_K2: k2,\n                            u_Gravity: self.gravity,\n                            u_ClusterGravity: self.clusterGravity || self.gravity || 1,\n                            u_Speed: speed,\n                            u_MaxDisplace: maxDisplace,\n                            u_Clustering: clustering ? 1 : 0,\n                            u_Center: center,\n                            u_AttributeArray: attributeArray,\n                            u_ClusterCenters: clusterCenters,\n                            MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n                            VERTEX_COUNT: numParticles\n                        });\n                        if (clustering) {\n                            kernelCluster = world\n                                .createKernel(fruchtermanShader_1.clusterBundle)\n                                .setDispatch([clusterCount, 1, 1])\n                                .setBinding({\n                                u_Data: nodesEdgesArray,\n                                u_NodeAttributes: attributeArray,\n                                u_ClusterCenters: clusterCenters,\n                                VERTEX_COUNT: numParticles,\n                                CLUSTER_COUNT: clusterCount\n                            });\n                        }\n                        execute = function () { return __awaiter(_this, void 0, void 0, function () {\n                            var i, finalParticleData;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        i = 0;\n                                        _a.label = 1;\n                                    case 1:\n                                        if (!(i < maxIteration)) return [3 /*break*/, 6];\n                                        // eslint-disable-next-line no-await-in-loop\n                                        return [4 /*yield*/, kernelFruchterman.execute()];\n                                    case 2:\n                                        // eslint-disable-next-line no-await-in-loop\n                                        _a.sent();\n                                        if (!clustering) return [3 /*break*/, 4];\n                                        kernelCluster.setBinding({\n                                            u_Data: kernelFruchterman\n                                        });\n                                        // eslint-disable-next-line no-await-in-loop\n                                        return [4 /*yield*/, kernelCluster.execute()];\n                                    case 3:\n                                        // eslint-disable-next-line no-await-in-loop\n                                        _a.sent();\n                                        kernelFruchterman.setBinding({\n                                            u_ClusterCenters: kernelCluster\n                                        });\n                                        _a.label = 4;\n                                    case 4:\n                                        kernelFruchterman.setBinding({\n                                            u_MaxDisplace: maxDisplace *= 0.99\n                                        });\n                                        _a.label = 5;\n                                    case 5:\n                                        i++;\n                                        return [3 /*break*/, 1];\n                                    case 6: return [4 /*yield*/, kernelFruchterman.getOutput()];\n                                    case 7:\n                                        finalParticleData = _a.sent();\n                                        if (canvas) {\n                                            // 传递数据给主线程\n                                            ctx.postMessage({\n                                                type: constants_1.LAYOUT_MESSAGE.GPUEND,\n                                                vertexEdgeData: finalParticleData\n                                                // edgeIndexBufferData,\n                                            });\n                                        }\n                                        else {\n                                            nodes.forEach(function (node, i) {\n                                                var x = finalParticleData[4 * i];\n                                                var y = finalParticleData[4 * i + 1];\n                                                node.x = x;\n                                                node.y = y;\n                                            });\n                                        }\n                                        if (onLayoutEnd)\n                                            onLayoutEnd();\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); };\n                        return [4 /*yield*/, execute()];\n                    case 1:\n                        _c.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    FruchtermanGPULayout.prototype.getType = function () {\n        return \"fruchterman-gpu\";\n    };\n    return FruchtermanGPULayout;\n}(base_1.Base));\nexports.FruchtermanGPULayout = FruchtermanGPULayout;\n//# sourceMappingURL=fruchterman.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.arrayToTextureData = exports.attributesToTextureData = exports.buildTextureDataWithTwoEdgeAttr = exports.buildTextureData = exports.proccessToFunc = void 0;\nvar _1 = require(\"./\");\n/**\n * 将 number | Function 类型的参数转换为 return number 的 Function\n * @param  {number | Function}  value 需要被转换的值\n * @param  {number}  defaultV 返回函数的默认返回值\n * @return {Function} 转换后的函数\n */\nvar proccessToFunc = function (value, defaultV) {\n    var func;\n    if (!value) {\n        func = function () {\n            return defaultV || 1;\n        };\n    }\n    else if (_1.isNumber(value)) {\n        func = function () {\n            return value;\n        };\n    }\n    else {\n        func = value;\n    }\n    return func;\n};\nexports.proccessToFunc = proccessToFunc;\n/**\n * 将节点和边数据转换为 GPU 可读的数组。并返回 maxEdgePerVetex，每个节点上最多的边数\n * @param  {NodeConfig[]}  nodes 需要被转换的值\n * @param  {EdgeConfig[]}  edges 返回函数的默认返回值\n * @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n */\nvar buildTextureData = function (nodes, edges) {\n    var dataArray = [];\n    var nodeDict = [];\n    var mapIdPos = {};\n    var i = 0;\n    for (i = 0; i < nodes.length; i++) {\n        var n = nodes[i];\n        mapIdPos[n.id] = i;\n        dataArray.push(n.x);\n        dataArray.push(n.y);\n        dataArray.push(0);\n        dataArray.push(0);\n        nodeDict.push([]);\n    }\n    for (i = 0; i < edges.length; i++) {\n        var e = edges[i];\n        nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n        nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n    }\n    var maxEdgePerVetex = 0;\n    for (i = 0; i < nodes.length; i++) {\n        var offset = dataArray.length;\n        var dests = nodeDict[i];\n        var len = dests.length;\n        dataArray[i * 4 + 2] = offset;\n        dataArray[i * 4 + 3] = dests.length;\n        maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);\n        for (var j = 0; j < len; ++j) {\n            var dest = dests[j];\n            dataArray.push(+dest);\n        }\n    }\n    while (dataArray.length % 4 !== 0) {\n        dataArray.push(0);\n    }\n    return {\n        maxEdgePerVetex: maxEdgePerVetex,\n        array: new Float32Array(dataArray),\n    };\n};\nexports.buildTextureData = buildTextureData;\n/**\n* 将节点和边数据转换为 GPU 可读的数组，每条边带有一个属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n* @param  {NodeConfig[]}  nodes 节点数组\n* @param  {EdgeConfig[]}  edges 边数组\n* @param  {Function}  attrs 读取边属性的函数\n* @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n*/\n// export const buildTextureDataWithOneEdgeAttr = (nodes: OutNode[], edges: Edge[], attrs: Function): {\n//   array: Float32Array,\n//   maxEdgePerVetex: number\n// } => {\n//   const dataArray = [];\n//   const nodeDict: any = [];\n//   const mapIdPos: IndexMap = {};\n//   let i = 0;\n//   for (i = 0; i < nodes.length; i++) {\n//       const n = nodes[i];\n//       mapIdPos[n.id] = i;\n//       dataArray.push(n.x);\n//       dataArray.push(n.y);\n//       dataArray.push(0);\n//       dataArray.push(0);\n//       nodeDict.push([]);\n//   }\n//   for (i = 0; i < edges.length; i++) {\n//       const e = edges[i];\n//       nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n//       nodeDict[mapIdPos[e.source]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n//       nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n//       nodeDict[mapIdPos[e.target]].push(attrs(e)); // 理想边长，后续可以改成每条边不同\n//   }\n//   let maxEdgePerVetex = 0;\n//   for (i = 0; i < nodes.length; i++) {\n//       const offset: number = dataArray.length;\n//       const dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n//       const len = dests.length;\n//       dataArray[i * 4 + 2] = offset;\n//       dataArray[i * 4 + 3] = len / 2; // 第四位存储与该节点相关的所有节点个数\n//       maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 2);\n//       for (let j = 0; j < len; ++j) {\n//           const dest = dests[j];\n//           dataArray.push(+dest);\n//       }\n//   }\n//   // 不是 4 的倍数，填充 0\n//   while (dataArray.length % 4 !== 0) {\n//       dataArray.push(0);\n//   }\n//   return {\n//       array: new Float32Array(dataArray),\n//       maxEdgePerVetex\n//   }\n// }\n/**\n* 将节点和边数据转换为 GPU 可读的数组，每条边带有一个以上属性。并返回 maxEdgePerVetex，每个节点上最多的边数\n* @param  {NodeConfig[]}  nodes 节点数组\n* @param  {EdgeConfig[]}  edges 边数组\n* @param  {Function}  attrs 读取边属性的函数\n* @return {Object} 转换后的数组及 maxEdgePerVetex 组成的对象\n*/\nvar buildTextureDataWithTwoEdgeAttr = function (nodes, edges, attrs1, attrs2) {\n    var dataArray = [];\n    var nodeDict = [];\n    var mapIdPos = {};\n    var i = 0;\n    for (i = 0; i < nodes.length; i++) {\n        var n = nodes[i];\n        mapIdPos[n.id] = i;\n        dataArray.push(n.x);\n        dataArray.push(n.y);\n        dataArray.push(0);\n        dataArray.push(0);\n        nodeDict.push([]);\n    }\n    for (i = 0; i < edges.length; i++) {\n        var e = edges[i];\n        nodeDict[mapIdPos[e.source]].push(mapIdPos[e.target]);\n        nodeDict[mapIdPos[e.source]].push(attrs1(e));\n        nodeDict[mapIdPos[e.source]].push(attrs2(e));\n        nodeDict[mapIdPos[e.source]].push(0);\n        nodeDict[mapIdPos[e.target]].push(mapIdPos[e.source]);\n        nodeDict[mapIdPos[e.target]].push(attrs1(e));\n        nodeDict[mapIdPos[e.target]].push(attrs2(e));\n        nodeDict[mapIdPos[e.target]].push(0);\n    }\n    var maxEdgePerVetex = 0;\n    for (i = 0; i < nodes.length; i++) {\n        var offset = dataArray.length;\n        var dests = nodeDict[i]; // dest 中节点 id 与边长间隔存储，即一位节点 id，一位边长……\n        var len = dests.length;\n        // dataArray[i * 4 + 2] = offset;\n        // dataArray[i * 4 + 3] = len / 4; // 第四位存储与该节点相关的所有节点个数\n        // pack offset & length into float32: offset 20bit, length 12bit\n        dataArray[i * 4 + 2] = offset + 1048576 * len / 4;\n        dataArray[i * 4 + 3] = 0; // 第四位存储与上一次的距离差值\n        maxEdgePerVetex = Math.max(maxEdgePerVetex, len / 4);\n        for (var j = 0; j < len; ++j) {\n            var dest = dests[j];\n            dataArray.push(+dest);\n        }\n    }\n    // 不是 4 的倍数，填充 0\n    while (dataArray.length % 4 !== 0) {\n        dataArray.push(0);\n    }\n    return {\n        maxEdgePerVetex: maxEdgePerVetex,\n        array: new Float32Array(dataArray),\n    };\n};\nexports.buildTextureDataWithTwoEdgeAttr = buildTextureDataWithTwoEdgeAttr;\n/**\n* transform the extended attributes of nodes or edges to a texture array\n* @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n* @param  {ModelConfig[]}  items the items to be read\n* @return {Float32Array} the attributes' value array to be read by GPU\n*/\nvar attributesToTextureData = function (attributeNames, items) {\n    var dataArray = [];\n    var attributeNum = attributeNames.length;\n    var attributteStringMap = {};\n    items.forEach(function (item) {\n        attributeNames.forEach(function (name, i) {\n            if (attributteStringMap[item[name]] === undefined) {\n                attributteStringMap[item[name]] = Object.keys(attributteStringMap).length;\n            }\n            dataArray.push(attributteStringMap[item[name]]);\n            // insure each node's attributes take inter number of grids\n            if (i === attributeNum - 1) {\n                while (dataArray.length % 4 !== 0) {\n                    dataArray.push(0);\n                }\n            }\n        });\n    });\n    return {\n        array: new Float32Array(dataArray),\n        count: Object.keys(attributteStringMap).length\n    };\n};\nexports.attributesToTextureData = attributesToTextureData;\n/**\n* transform the number array format of extended attributes of nodes or edges to a texture array\n* @param  {string[]}  attributeNames attributes' name to be read from items and put into output array\n* @return {Float32Array} the attributes' value array to be read by GPU\n*/\nvar arrayToTextureData = function (valueArrays) {\n    var dataArray = [];\n    var attributeNum = valueArrays.length;\n    var itemNum = valueArrays[0].length;\n    var _loop_1 = function (j) {\n        valueArrays.forEach(function (valueArray, i) {\n            dataArray.push(valueArray[j]);\n            // insure each node's attributes take inter number of grids\n            if (i === attributeNum - 1) {\n                while (dataArray.length % 4 !== 0) {\n                    dataArray.push(0);\n                }\n            }\n        });\n    };\n    for (var j = 0; j < itemNum; j++) {\n        _loop_1(j);\n    }\n    return new Float32Array(dataArray);\n};\nexports.arrayToTextureData = arrayToTextureData;\n//# sourceMappingURL=gpu.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clusterBundle = exports.clusterCode = exports.fruchtermanBundle = exports.fruchtermanCode = void 0;\nexports.fruchtermanCode = \"\\nimport { globalInvocationID } from 'g-webgpu';\\nconst MAX_EDGE_PER_VERTEX;\\nconst VERTEX_COUNT;\\n@numthreads(1, 1, 1)\\nclass Fruchterman {\\n  @in @out\\n  u_Data: vec4[];\\n  @in\\n  u_K: float;\\n  @in\\n  u_K2: float;\\n  \\n  @in\\n  u_Center: vec2;\\n  @in\\n  u_Gravity: float;\\n  @in\\n  u_ClusterGravity: float;\\n  @in\\n  u_Speed: float;\\n  @in\\n  u_MaxDisplace: float;\\n  @in\\n  u_Clustering: float;\\n  @in\\n  u_AttributeArray: vec4[];\\n  @in\\n  u_ClusterCenters: vec4[];\\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\\n    let dx = 0, dy = 0;\\n    for (let j = 0; j < VERTEX_COUNT; j++) {\\n      if (i != j) {\\n        const nextNode = this.u_Data[j];\\n        const xDist = currentNode[0] - nextNode[0];\\n        const yDist = currentNode[1] - nextNode[1];\\n        const dist = (xDist * xDist + yDist * yDist) + 0.01;\\n        let param = this.u_K2 / dist;\\n        \\n        if (dist > 0.0) {\\n          dx += param * xDist;\\n          dy += param * yDist;\\n          if (xDist == 0 && yDist == 0) {\\n            const sign = i < j ? 1 : -1;\\n            dx += param * sign;\\n            dy += param * sign;\\n          }\\n        }\\n      }\\n    }\\n    return [dx, dy];\\n  }\\n  calcGravity(currentNode: vec4, nodeAttributes: vec4): vec2 { // \\n    let dx = 0, dy = 0;\\n    const vx = currentNode[0] - this.u_Center[0];\\n    const vy = currentNode[1] - this.u_Center[1];\\n    const gf = 0.01 * this.u_K * this.u_Gravity;\\n    dx = gf * vx;\\n    dy = gf * vy;\\n    if (this.u_Clustering == 1) {\\n      const clusterIdx = int(nodeAttributes[0]);\\n      const center = this.u_ClusterCenters[clusterIdx];\\n      const cvx = currentNode[0] - center[0];\\n      const cvy = currentNode[1] - center[1];\\n      const dist = sqrt(cvx * cvx + cvy * cvy) + 0.01;\\n      const parma = this.u_K * this.u_ClusterGravity / dist;\\n      dx += parma * cvx;\\n      dy += parma * cvy;\\n    }\\n    return [dx, dy];\\n  }\\n  calcAttractive(i: int, currentNode: vec4): vec2 {\\n    let dx = 0, dy = 0;\\n    const arr_offset = int(floor(currentNode[2] + 0.5));\\n    const length = int(floor(currentNode[3] + 0.5));\\n    const node_buffer: vec4;\\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\\n      if (p >= length) break;\\n      const arr_idx = arr_offset + p;\\n      // when arr_idx % 4 == 0 update currentNodedx_buffer\\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\\n      if (p == 0 || buf_offset == 0) {\\n        node_buffer = this.u_Data[int(arr_idx / 4)];\\n      }\\n      const float_j = buf_offset == 0 ? node_buffer[0] :\\n                      buf_offset == 1 ? node_buffer[1] :\\n                      buf_offset == 2 ? node_buffer[2] :\\n                                        node_buffer[3];\\n      const nextNode = this.u_Data[int(float_j)];\\n      const xDist = currentNode[0] - nextNode[0];\\n      const yDist = currentNode[1] - nextNode[1];\\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\\n      let attractiveF = dist / this.u_K;\\n    \\n      if (dist > 0.0) {\\n        dx -= xDist * attractiveF;\\n        dy -= yDist * attractiveF;\\n        if (xDist == 0 && yDist == 0) {\\n          const sign = i < int(float_j) ? 1 : -1;\\n          dx -= sign * attractiveF;\\n          dy -= sign * attractiveF;\\n        }\\n      }\\n    }\\n    return [dx, dy];\\n  }\\n  @main\\n  compute() {\\n    const i = globalInvocationID.x;\\n    const currentNode = this.u_Data[i];\\n    let dx = 0, dy = 0;\\n    if (i >= VERTEX_COUNT) {\\n      this.u_Data[i] = currentNode;\\n      return;\\n    }\\n\\n    // [gravity, fx, fy, 0]\\n    const nodeAttributes = this.u_AttributeArray[i];\\n\\n    if (nodeAttributes[1] != 0 && nodeAttributes[2] != 0) {\\n      // the node is fixed\\n      this.u_Data[i] = [\\n        nodeAttributes[1],\\n        nodeAttributes[2],\\n        currentNode[2],\\n        currentNode[3]\\n      ];\\n      return;\\n    }\\n\\n    // repulsive\\n    const repulsive = this.calcRepulsive(i, currentNode);\\n    dx += repulsive[0];\\n    dy += repulsive[1];\\n    // attractive\\n    const attractive = this.calcAttractive(i, currentNode);\\n    dx += attractive[0];\\n    dy += attractive[1];\\n    // gravity\\n    const gravity = this.calcGravity(currentNode, nodeAttributes);\\n    dx -= gravity[0];\\n    dy -= gravity[1];\\n    // speed\\n    dx *= this.u_Speed;\\n    dy *= this.u_Speed;\\n\\n    // move\\n    const distLength = sqrt(dx * dx + dy * dy);\\n    if (distLength > 0.0) {\\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\\n      this.u_Data[i] = [\\n        currentNode[0] + dx / distLength * limitedDist,\\n        currentNode[1] + dy / distLength * limitedDist,\\n        currentNode[2],\\n        currentNode[3]\\n      ];\\n    }\\n  }\\n}\\n\";\nexports.fruchtermanBundle = \"{\\\"shaders\\\":{\\\"WGSL\\\":\\\"import \\\\\\\"GLSL.std.450\\\\\\\" as std;\\\\n\\\\n\\\\n# var gWebGPUDebug : bool = false;\\\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\\\n\\\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\\\n[[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\\\n[[builtin local_invocation_idx]] var<in> localInvocationIndex : u32;\\\\n\\\\ntype GWebGPUParams = [[block]] struct {\\\\n  [[offset 0]] u_K : f32;\\\\n  [[offset 4]] u_K2 : f32;\\\\n  [[offset 8]] u_Center : vec2<f32>;\\\\n  [[offset 16]] u_Gravity : f32;\\\\n  [[offset 20]] u_ClusterGravity : f32;\\\\n  [[offset 24]] u_Speed : f32;\\\\n  [[offset 28]] u_MaxDisplace : f32;\\\\n  [[offset 32]] u_Clustering : f32;\\\\n};\\\\n[[binding 0, set 0]] var<uniform> gWebGPUUniformParams : GWebGPUParams;\\\\ntype GWebGPUBuffer0 = [[block]] struct {\\\\n  [[offset 0]] u_Data : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\\\ntype GWebGPUBuffer1 = [[block]] struct {\\\\n  [[offset 0]] u_AttributeArray : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 2, set 0]] var<storage_buffer> gWebGPUBuffer1 : GWebGPUBuffer1;\\\\ntype GWebGPUBuffer2 = [[block]] struct {\\\\n  [[offset 0]] u_ClusterCenters : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 3, set 0]] var<storage_buffer> gWebGPUBuffer2 : GWebGPUBuffer2;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nfn calcRepulsive(i : i32, currentNode : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nfor (var j : i32 = 0; j < __DefineValuePlaceholder__VERTEX_COUNT; j = j + 1) {if (i != j) {var nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[j];\\\\nvar xDist : f32 = currentNode.x - nextNode.x;\\\\nvar yDist : f32 = currentNode.y - nextNode.y;\\\\nvar dist : f32 = ((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nvar param : f32 = gWebGPUUniformParams.u_K2 / dist;\\\\nif (dist > 0.0) {dx = dx + param * xDist;\\\\ndy = dy + param * yDist;\\\\nif ((xDist == 0.0) && (yDist == 0.0)) {var sign : f32 = select(1.0, -1.0, i < j);\\\\ndx = dx + param * std::sign;\\\\ndy = dy + param * std::sign;}}}}\\\\nreturn vec2<f32>(dx, dy);}\\\\nfn calcGravity(currentNode : vec4<f32>, nodeAttributes : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nvar vx : f32 = currentNode.x - gWebGPUUniformParams.u_Center.x;\\\\nvar vy : f32 = currentNode.y - gWebGPUUniformParams.u_Center.y;\\\\nvar gf : f32 = (0.01 * gWebGPUUniformParams.u_K) * gWebGPUUniformParams.u_Gravity;\\\\ndx = gf * vx;\\\\ndy = gf * vy;\\\\nif (gWebGPUUniformParams.u_Clustering == 1.0) {var clusterIdx : i32 = i32(nodeAttributes.x);\\\\nvar center : vec4<f32> = gWebGPUBuffer2.u_ClusterCenters[clusterIdx];\\\\nvar cvx : f32 = currentNode.x - center.x;\\\\nvar cvy : f32 = currentNode.y - center.y;\\\\nvar dist : f32 = std::sqrt((cvx * cvx) + (cvy * cvy)) + 0.01;\\\\nvar parma : f32 = (gWebGPUUniformParams.u_K * gWebGPUUniformParams.u_ClusterGravity) / dist;\\\\ndx = dx + parma * cvx;\\\\ndy = dy + parma * cvy;}\\\\nreturn vec2<f32>(dx, dy);}\\\\nfn calcAttractive(i : i32, currentNode : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nvar arr_offset : i32 = i32(std::floor(currentNode.z + 0.5));\\\\nvar length : i32 = i32(std::floor(currentNode.w + 0.5));\\\\nvar node_buffer : vec4<f32>;\\\\nfor (var p : i32 = 0; p < __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX; p = p + 1) {if (p >= length) {break;}\\\\nvar arr_idx : i32 = arr_offset + i32(p);\\\\nvar buf_offset : i32 = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[i32(arr_idx / 4)];}\\\\nvar float_j : f32 = select(node_buffer.x, select(node_buffer.y, select(node_buffer.z, node_buffer.w, buf_offset == 2), buf_offset == 1), buf_offset == 0);\\\\nvar nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[i32(float_j)];\\\\nvar xDist : f32 = currentNode.x - nextNode.x;\\\\nvar yDist : f32 = currentNode.y - nextNode.y;\\\\nvar dist : f32 = std::sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nvar attractiveF : f32 = dist / gWebGPUUniformParams.u_K;\\\\nif (dist > 0.0) {dx = dx - xDist * attractiveF;\\\\ndy = dy - yDist * attractiveF;\\\\nif ((xDist == 0.0) && (yDist == 0.0)) {var sign : f32 = select(1.0, -1.0, i < i32(float_j));\\\\ndx = dx - std::sign * attractiveF;\\\\ndy = dy - std::sign * attractiveF;}}}\\\\nreturn vec2<f32>(dx, dy);}\\\\nfn main() -> void {var i : i32 = globalInvocationID.x;\\\\nvar currentNode : vec4<f32> = gWebGPUBuffer0.u_Data[i];\\\\nvar dx : f32 = 0.0;\\\\nvar dy : f32 = 0.0;\\\\nif (i >= __DefineValuePlaceholder__VERTEX_COUNT) {gWebGPUBuffer0.u_Data[i] = currentNode;\\\\nreturn ;}\\\\nvar nodeAttributes : vec4<f32> = gWebGPUBuffer1.u_AttributeArray[i];\\\\nif ((nodeAttributes.y != 0.0) && (nodeAttributes.z != 0.0)) {gWebGPUBuffer0.u_Data[i] = vec4<f32>(nodeAttributes.y, nodeAttributes.z, currentNode.z, currentNode.w);\\\\nreturn ;}\\\\nvar repulsive : vec2<f32> = calcRepulsive(i, currentNode);\\\\ndx = dx + repulsive.x;\\\\ndy = dy + repulsive.y;\\\\nvar attractive : vec2<f32> = calcAttractive(i, currentNode);\\\\ndx = dx + attractive.x;\\\\ndy = dy + attractive.y;\\\\nvar gravity : vec2<f32> = calcGravity(currentNode, nodeAttributes);\\\\ndx = dx - gravity.x;\\\\ndy = dy - gravity.y;\\\\ndx = dx * gWebGPUUniformParams.u_Speed;\\\\ndy = dy * gWebGPUUniformParams.u_Speed;\\\\nvar distLength : f32 = std::sqrt((dx * dx) + (dy * dy));\\\\nif (distLength > 0.0) {var limitedDist : f32 = std::min(gWebGPUUniformParams.u_MaxDisplace * gWebGPUUniformParams.u_Speed, distLength);\\\\ngWebGPUBuffer0.u_Data[i] = vec4<f32>(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w);}\\\\nreturn;}\\\\n\\\\nentry_point compute as \\\\\\\"main\\\\\\\" = main;\\\\n\\\",\\\"GLSL450\\\":\\\"\\\\n\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\\\nivec3 workGroupSize = ivec3(1,1,1);\\\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\\\n\\\\nlayout(std140, set = 0, binding = 0) uniform GWebGPUParams {\\\\n  float u_K;\\\\n  float u_K2;\\\\n  vec2 u_Center;\\\\n  float u_Gravity;\\\\n  float u_ClusterGravity;\\\\n  float u_Speed;\\\\n  float u_MaxDisplace;\\\\n  float u_Clustering;\\\\n} gWebGPUUniformParams;\\\\nlayout(std430, set = 0, binding = 1) buffer   GWebGPUBuffer0 {\\\\n  vec4 u_Data[];\\\\n} gWebGPUBuffer0;\\\\n\\\\nlayout(std430, set = 0, binding = 2) buffer readonly  GWebGPUBuffer1 {\\\\n  vec4 u_AttributeArray[];\\\\n} gWebGPUBuffer1;\\\\n\\\\nlayout(std430, set = 0, binding = 3) buffer readonly  GWebGPUBuffer2 {\\\\n  vec4 u_ClusterCenters[];\\\\n} gWebGPUBuffer2;\\\\n\\\\n\\\\n\\\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\nlayout (\\\\n  local_size_x = 1,\\\\n  local_size_y = 1,\\\\n  local_size_z = 1\\\\n) in;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nvec2 calcRepulsive(int i, vec4 currentNode) {float dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = gWebGPUBuffer0.u_Data[j];\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = ((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nfloat param = gWebGPUUniformParams.u_K2 / dist;\\\\nif (dist > 0.0) {dx += param * xDist;\\\\ndy += param * yDist;\\\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < j) ? (1.0) : (-1.0);\\\\ndx += param * sign;\\\\ndy += param * sign;}}}}\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcGravity(vec4 currentNode, vec4 nodeAttributes) {float dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfloat vx = currentNode.x - gWebGPUUniformParams.u_Center.x;\\\\nfloat vy = currentNode.y - gWebGPUUniformParams.u_Center.y;\\\\nfloat gf = (0.01 * gWebGPUUniformParams.u_K) * gWebGPUUniformParams.u_Gravity;\\\\ndx = gf * vx;\\\\ndy = gf * vy;\\\\nif (gWebGPUUniformParams.u_Clustering == 1.0) {int clusterIdx = int(nodeAttributes.x);\\\\nvec4 center = gWebGPUBuffer2.u_ClusterCenters[clusterIdx];\\\\nfloat cvx = currentNode.x - center.x;\\\\nfloat cvy = currentNode.y - center.y;\\\\nfloat dist = sqrt((cvx * cvx) + (cvy * cvy)) + 0.01;\\\\nfloat parma = (gWebGPUUniformParams.u_K * gWebGPUUniformParams.u_ClusterGravity) / dist;\\\\ndx += parma * cvx;\\\\ndy += parma * cvy;}\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcAttractive(int i, vec4 currentNode) {float dx = 0.0;\\\\nfloat dy = 0.0;\\\\nint arr_offset = int(floor(currentNode.z + 0.5));\\\\nint length = int(floor(currentNode.w + 0.5));\\\\nvec4 node_buffer;\\\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\\\nint arr_idx = arr_offset + int(p);\\\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[int(arr_idx / 4)];}\\\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\\\nvec4 nextNode = gWebGPUBuffer0.u_Data[int(float_j)];\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nfloat attractiveF = dist / gWebGPUUniformParams.u_K;\\\\nif (dist > 0.0) {dx -= xDist * attractiveF;\\\\ndy -= yDist * attractiveF;\\\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < int(float_j)) ? (1.0) : (-1.0);\\\\ndx -= sign * attractiveF;\\\\ndy -= sign * attractiveF;}}}\\\\nreturn vec2(dx, dy);}\\\\nvoid main() {int i = globalInvocationID.x;\\\\nvec4 currentNode = gWebGPUBuffer0.u_Data[i];\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nif (i >= VERTEX_COUNT) {gWebGPUBuffer0.u_Data[i] = currentNode;\\\\nreturn ;}\\\\nvec4 nodeAttributes = gWebGPUBuffer1.u_AttributeArray[i];\\\\nif ((nodeAttributes.y != 0.0) && (nodeAttributes.z != 0.0)) {gWebGPUBuffer0.u_Data[i] = vec4(nodeAttributes.y, nodeAttributes.z, currentNode.z, currentNode.w);\\\\nreturn ;}\\\\nvec2 repulsive = calcRepulsive(i, currentNode);\\\\ndx += repulsive.x;\\\\ndy += repulsive.y;\\\\nvec2 attractive = calcAttractive(i, currentNode);\\\\ndx += attractive.x;\\\\ndy += attractive.y;\\\\nvec2 gravity = calcGravity(currentNode, nodeAttributes);\\\\ndx -= gravity.x;\\\\ndy -= gravity.y;\\\\ndx *= gWebGPUUniformParams.u_Speed;\\\\ndy *= gWebGPUUniformParams.u_Speed;\\\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\\\nif (distLength > 0.0) {float limitedDist = min(gWebGPUUniformParams.u_MaxDisplace * gWebGPUUniformParams.u_Speed, distLength);\\\\ngWebGPUBuffer0.u_Data[i] = vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w);}}\\\\n\\\",\\\"GLSL100\\\":\\\"\\\\n\\\\nfloat epsilon = 0.00001;\\\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\\\n  vec2 normAddr2D = float(address1D) * conv_const;\\\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\\\n}\\\\n\\\\nvoid barrier() {}\\\\n  \\\\n\\\\nuniform vec2 u_OutputTextureSize;\\\\nuniform int u_OutputTexelCount;\\\\nvarying vec2 v_TexCoord;\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\n\\\\nuniform sampler2D u_Data;\\\\nuniform vec2 u_DataSize;\\\\nvec4 getDatau_Data(vec2 address2D) {\\\\n  return vec4(texture2D(u_Data, address2D).rgba);\\\\n}\\\\nvec4 getDatau_Data(float address1D) {\\\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\\\n}\\\\nvec4 getDatau_Data(int address1D) {\\\\n  return getDatau_Data(float(address1D));\\\\n}\\\\nuniform float u_K;\\\\nuniform float u_K2;\\\\nuniform vec2 u_Center;\\\\nuniform float u_Gravity;\\\\nuniform float u_ClusterGravity;\\\\nuniform float u_Speed;\\\\nuniform float u_MaxDisplace;\\\\nuniform float u_Clustering;\\\\nuniform sampler2D u_AttributeArray;\\\\nuniform vec2 u_AttributeArraySize;\\\\nvec4 getDatau_AttributeArray(vec2 address2D) {\\\\n  return vec4(texture2D(u_AttributeArray, address2D).rgba);\\\\n}\\\\nvec4 getDatau_AttributeArray(float address1D) {\\\\n  return getDatau_AttributeArray(addrTranslation_1Dto2D(address1D, u_AttributeArraySize));\\\\n}\\\\nvec4 getDatau_AttributeArray(int address1D) {\\\\n  return getDatau_AttributeArray(float(address1D));\\\\n}\\\\nuniform sampler2D u_ClusterCenters;\\\\nuniform vec2 u_ClusterCentersSize;\\\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\\\n}\\\\nvec4 getDatau_ClusterCenters(float address1D) {\\\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\\\n}\\\\nvec4 getDatau_ClusterCenters(int address1D) {\\\\n  return getDatau_ClusterCenters(float(address1D));\\\\n}\\\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = ((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nfloat param = u_K2 / dist;\\\\nif (dist > 0.0) {dx += param * xDist;\\\\ndy += param * yDist;\\\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < j) ? (1.0) : (-1.0);\\\\ndx += param * sign;\\\\ndy += param * sign;}}}}\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcGravity(vec4 currentNode, vec4 nodeAttributes) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nfloat vx = currentNode.x - u_Center.x;\\\\nfloat vy = currentNode.y - u_Center.y;\\\\nfloat gf = (0.01 * u_K) * u_Gravity;\\\\ndx = gf * vx;\\\\ndy = gf * vy;\\\\nif (u_Clustering == 1.0) {int clusterIdx = int(nodeAttributes.x);\\\\nvec4 center = getDatau_ClusterCenters(clusterIdx);\\\\nfloat cvx = currentNode.x - center.x;\\\\nfloat cvy = currentNode.y - center.y;\\\\nfloat dist = sqrt((cvx * cvx) + (cvy * cvy)) + 0.01;\\\\nfloat parma = (u_K * u_ClusterGravity) / dist;\\\\ndx += parma * cvx;\\\\ndy += parma * cvy;}\\\\nreturn vec2(dx, dy);}\\\\nvec2 calcAttractive(int i, vec4 currentNode) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nint arr_offset = int(floor(currentNode.z + 0.5));\\\\nint length = int(floor(currentNode.w + 0.5));\\\\nvec4 node_buffer;\\\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\\\nint arr_idx = arr_offset + int(p);\\\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\\\nvec4 nextNode = getDatau_Data(int(float_j));\\\\nfloat xDist = currentNode.x - nextNode.x;\\\\nfloat yDist = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\\\nfloat attractiveF = dist / u_K;\\\\nif (dist > 0.0) {dx -= xDist * attractiveF;\\\\ndy -= yDist * attractiveF;\\\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < int(float_j)) ? (1.0) : (-1.0);\\\\ndx -= sign * attractiveF;\\\\ndy -= sign * attractiveF;}}}\\\\nreturn vec2(dx, dy);}\\\\nvoid main() {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nint i = globalInvocationID.x;\\\\nvec4 currentNode = getDatau_Data(i);\\\\nfloat dx = 0.0;\\\\nfloat dy = 0.0;\\\\nif (i >= VERTEX_COUNT) {gl_FragColor = vec4(currentNode);\\\\nreturn ;}\\\\nvec4 nodeAttributes = getDatau_AttributeArray(i);\\\\nif ((nodeAttributes.y != 0.0) && (nodeAttributes.z != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes.y, nodeAttributes.z, currentNode.z, currentNode.w));\\\\nreturn ;}\\\\nvec2 repulsive = calcRepulsive(i, currentNode);\\\\ndx += repulsive.x;\\\\ndy += repulsive.y;\\\\nvec2 attractive = calcAttractive(i, currentNode);\\\\ndx += attractive.x;\\\\ndy += attractive.y;\\\\nvec2 gravity = calcGravity(currentNode, nodeAttributes);\\\\ndx -= gravity.x;\\\\ndy -= gravity.y;\\\\ndx *= u_Speed;\\\\ndy *= u_Speed;\\\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\\\nif (distLength > 0.0) {float limitedDist = min(u_MaxDisplace * u_Speed, distLength);\\\\ngl_FragColor = vec4(vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w));}if (gWebGPUDebug) {\\\\n  gl_FragColor = gWebGPUDebugOutput;\\\\n}}\\\\n\\\"},\\\"context\\\":{\\\"name\\\":\\\"\\\",\\\"dispatch\\\":[1,1,1],\\\"threadGroupSize\\\":[1,1,1],\\\"maxIteration\\\":1,\\\"defines\\\":[{\\\"name\\\":\\\"MAX_EDGE_PER_VERTEX\\\",\\\"type\\\":\\\"Float\\\",\\\"runtime\\\":true},{\\\"name\\\":\\\"VERTEX_COUNT\\\",\\\"type\\\":\\\"Float\\\",\\\"runtime\\\":true}],\\\"uniforms\\\":[{\\\"name\\\":\\\"u_Data\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":false,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_K\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_K2\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_Center\\\",\\\"type\\\":\\\"vec2<f32>\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_Gravity\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_ClusterGravity\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_Speed\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_MaxDisplace\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_Clustering\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_AttributeArray\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_ClusterCenters\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]}],\\\"globalDeclarations\\\":[],\\\"output\\\":{\\\"name\\\":\\\"u_Data\\\",\\\"size\\\":[1,1],\\\"length\\\":1},\\\"needPingpong\\\":true}}\";\nexports.clusterCode = \"\\nimport { globalInvocationID } from 'g-webgpu';\\nconst VERTEX_COUNT;\\nconst CLUSTER_COUNT;\\n@numthreads(1, 1, 1)\\nclass CalcCenter {\\n  @in\\n  u_Data: vec4[];\\n  @in\\n  u_NodeAttributes: vec4[]; // [[clusterIdx, 0, 0, 0], ...]\\n  @in @out\\n  u_ClusterCenters: vec4[]; // [[cx, cy, nodeCount, clusterIdx], ...]\\n  @main\\n  compute() {\\n    const i = globalInvocationID.x;\\n    const center = this.u_ClusterCenters[i];\\n    let sumx = 0;\\n    let sumy = 0;\\n    let count = 0;\\n    for (let j = 0; j < VERTEX_COUNT; j++) {\\n      const attributes = this.u_NodeAttributes[j];\\n      const clusterIdx = int(attributes[0]);\\n      const vertex = this.u_Data[j];\\n      if (clusterIdx == i) {\\n        sumx += vertex.x;\\n        sumy += vertex.y;\\n        count += 1;\\n      }\\n    }\\n    this.u_ClusterCenters[i] = [\\n      sumx / count,\\n      sumy / count,\\n      count,\\n      i\\n    ];\\n  }\\n}\\n\";\nexports.clusterBundle = \"{\\\"shaders\\\":{\\\"WGSL\\\":\\\"import \\\\\\\"GLSL.std.450\\\\\\\" as std;\\\\n\\\\n\\\\n# var gWebGPUDebug : bool = false;\\\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\\\n\\\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\\\n[[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\\\n[[builtin local_invocation_idx]] var<in> localInvocationIndex : u32;\\\\n\\\\n\\\\ntype GWebGPUBuffer0 = [[block]] struct {\\\\n  [[offset 0]] u_Data : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 0, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\\\ntype GWebGPUBuffer1 = [[block]] struct {\\\\n  [[offset 0]] u_NodeAttributes : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer1 : GWebGPUBuffer1;\\\\ntype GWebGPUBuffer2 = [[block]] struct {\\\\n  [[offset 0]] u_ClusterCenters : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 2, set 0]] var<storage_buffer> gWebGPUBuffer2 : GWebGPUBuffer2;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nfn main() -> void {var i : i32 = globalInvocationID.x;\\\\nvar center : vec4<f32> = gWebGPUBuffer2.u_ClusterCenters[i];\\\\nvar sumx : f32 = 0.0;\\\\nvar sumy : f32 = 0.0;\\\\nvar count : f32 = 0.0;\\\\nfor (var j : i32 = 0; j < __DefineValuePlaceholder__VERTEX_COUNT; j = j + 1) {var attributes : vec4<f32> = gWebGPUBuffer1.u_NodeAttributes[j];\\\\nvar clusterIdx : i32 = i32(attributes.x);\\\\nvar vertex : vec4<f32> = gWebGPUBuffer0.u_Data[j];\\\\nif (clusterIdx == i) {sumx = sumx + vertex.x;\\\\nsumy = sumy + vertex.y;\\\\ncount = count + 1.0;}}\\\\ngWebGPUBuffer2.u_ClusterCenters[i] = vec4<f32>(sumx / count, sumy / count, count, i);\\\\nreturn;}\\\\n\\\\nentry_point compute as \\\\\\\"main\\\\\\\" = main;\\\\n\\\",\\\"GLSL450\\\":\\\"\\\\n\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\\\nivec3 workGroupSize = ivec3(1,1,1);\\\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\\\n\\\\n\\\\nlayout(std430, set = 0, binding = 0) buffer readonly  GWebGPUBuffer0 {\\\\n  vec4 u_Data[];\\\\n} gWebGPUBuffer0;\\\\n\\\\nlayout(std430, set = 0, binding = 1) buffer readonly  GWebGPUBuffer1 {\\\\n  vec4 u_NodeAttributes[];\\\\n} gWebGPUBuffer1;\\\\n\\\\nlayout(std430, set = 0, binding = 2) buffer   GWebGPUBuffer2 {\\\\n  vec4 u_ClusterCenters[];\\\\n} gWebGPUBuffer2;\\\\n\\\\n\\\\n\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\n#define CLUSTER_COUNT __DefineValuePlaceholder__CLUSTER_COUNT\\\\nlayout (\\\\n  local_size_x = 1,\\\\n  local_size_y = 1,\\\\n  local_size_z = 1\\\\n) in;\\\\n\\\\n\\\\n\\\\nvoid main() {int i = globalInvocationID.x;\\\\nvec4 center = gWebGPUBuffer2.u_ClusterCenters[i];\\\\nfloat sumx = 0.0;\\\\nfloat sumy = 0.0;\\\\nfloat count = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 attributes = gWebGPUBuffer1.u_NodeAttributes[j];\\\\nint clusterIdx = int(attributes.x);\\\\nvec4 vertex = gWebGPUBuffer0.u_Data[j];\\\\nif (clusterIdx == i) {sumx += vertex.x;\\\\nsumy += vertex.y;\\\\ncount += 1.0;}}\\\\ngWebGPUBuffer2.u_ClusterCenters[i] = vec4(sumx / count, sumy / count, count, i);}\\\\n\\\",\\\"GLSL100\\\":\\\"\\\\n\\\\nfloat epsilon = 0.00001;\\\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\\\n  vec2 normAddr2D = float(address1D) * conv_const;\\\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\\\n}\\\\n\\\\nvoid barrier() {}\\\\n  \\\\n\\\\nuniform vec2 u_OutputTextureSize;\\\\nuniform int u_OutputTexelCount;\\\\nvarying vec2 v_TexCoord;\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\n#define CLUSTER_COUNT __DefineValuePlaceholder__CLUSTER_COUNT\\\\n\\\\nuniform sampler2D u_Data;\\\\nuniform vec2 u_DataSize;\\\\nvec4 getDatau_Data(vec2 address2D) {\\\\n  return vec4(texture2D(u_Data, address2D).rgba);\\\\n}\\\\nvec4 getDatau_Data(float address1D) {\\\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\\\n}\\\\nvec4 getDatau_Data(int address1D) {\\\\n  return getDatau_Data(float(address1D));\\\\n}\\\\nuniform sampler2D u_NodeAttributes;\\\\nuniform vec2 u_NodeAttributesSize;\\\\nvec4 getDatau_NodeAttributes(vec2 address2D) {\\\\n  return vec4(texture2D(u_NodeAttributes, address2D).rgba);\\\\n}\\\\nvec4 getDatau_NodeAttributes(float address1D) {\\\\n  return getDatau_NodeAttributes(addrTranslation_1Dto2D(address1D, u_NodeAttributesSize));\\\\n}\\\\nvec4 getDatau_NodeAttributes(int address1D) {\\\\n  return getDatau_NodeAttributes(float(address1D));\\\\n}\\\\nuniform sampler2D u_ClusterCenters;\\\\nuniform vec2 u_ClusterCentersSize;\\\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\\\n}\\\\nvec4 getDatau_ClusterCenters(float address1D) {\\\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\\\n}\\\\nvec4 getDatau_ClusterCenters(int address1D) {\\\\n  return getDatau_ClusterCenters(float(address1D));\\\\n}\\\\nvoid main() {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nint i = globalInvocationID.x;\\\\nvec4 center = getDatau_ClusterCenters(i);\\\\nfloat sumx = 0.0;\\\\nfloat sumy = 0.0;\\\\nfloat count = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 attributes = getDatau_NodeAttributes(j);\\\\nint clusterIdx = int(attributes.x);\\\\nvec4 vertex = getDatau_Data(j);\\\\nif (clusterIdx == i) {sumx += vertex.x;\\\\nsumy += vertex.y;\\\\ncount += 1.0;}}\\\\ngl_FragColor = vec4(vec4(sumx / count, sumy / count, count, i));if (gWebGPUDebug) {\\\\n  gl_FragColor = gWebGPUDebugOutput;\\\\n}}\\\\n\\\"},\\\"context\\\":{\\\"name\\\":\\\"\\\",\\\"dispatch\\\":[1,1,1],\\\"threadGroupSize\\\":[1,1,1],\\\"maxIteration\\\":1,\\\"defines\\\":[{\\\"name\\\":\\\"VERTEX_COUNT\\\",\\\"type\\\":\\\"Float\\\",\\\"runtime\\\":true},{\\\"name\\\":\\\"CLUSTER_COUNT\\\",\\\"type\\\":\\\"Float\\\",\\\"runtime\\\":true}],\\\"uniforms\\\":[{\\\"name\\\":\\\"u_Data\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_NodeAttributes\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_ClusterCenters\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":false,\\\"writeonly\\\":false,\\\"size\\\":[1,1]}],\\\"globalDeclarations\\\":[],\\\"output\\\":{\\\"name\\\":\\\"u_ClusterCenters\\\",\\\"size\\\":[1,1],\\\"length\\\":1},\\\"needPingpong\\\":true}}\";\n//# sourceMappingURL=fruchtermanShader.js.map","\n// @ts-nocheck\n/**\n * @fileOverview fruchterman layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GForceGPULayout = void 0;\nvar base_1 = require(\"../base\");\nvar util_1 = require(\"../../util\");\n// @ts-ignore\nvar g_webgpu_1 = require(\"@antv/g-webgpu\");\nvar gpu_1 = require(\"../../util/gpu\");\nvar math_1 = require(\"../../util/math\");\nvar gForceShader_1 = require(\"./gForceShader\");\nvar constants_1 = require(\"../constants\");\n/**\n * graphin 中的 force 布局\n */\nvar GForceGPULayout = /** @class */ (function (_super) {\n    __extends(GForceGPULayout, _super);\n    function GForceGPULayout(options) {\n        var _this = _super.call(this) || this;\n        /** 停止迭代的最大迭代数 */\n        _this.maxIteration = 1000;\n        /** 弹簧引力系数 */\n        _this.edgeStrength = 200;\n        /** 斥力系数 */\n        _this.nodeStrength = 1000;\n        /** 库伦系数 */\n        _this.coulombDisScale = 0.005;\n        /** 阻尼系数 */\n        _this.damping = 0.9;\n        /** 最大速度 */\n        _this.maxSpeed = 1000;\n        /** 一次迭代的平均移动距离小于该值时停止迭代 */\n        _this.minMovement = 0.5;\n        /** 迭代中衰减 */\n        _this.interval = 0.02;\n        /** 斥力的一个系数 */\n        _this.factor = 1;\n        /** 理想边长 */\n        _this.linkDistance = 1;\n        /** 重力大小 */\n        _this.gravity = 10;\n        /** 是否启用web worker。前提是在web worker里执行布局，否则无效\t*/\n        _this.workerEnabled = false;\n        _this.nodes = [];\n        _this.edges = [];\n        _this.width = 300;\n        _this.height = 300;\n        _this.nodeMap = {};\n        _this.nodeIdxMap = {};\n        _this.updateCfg(options);\n        return _this;\n    }\n    GForceGPULayout.prototype.getDefaultCfg = function () {\n        return {\n            maxIteration: 2000,\n            gravity: 10,\n            clustering: false,\n            clusterGravity: 10\n        };\n    };\n    /**\n     * 执行布局\n     */\n    GForceGPULayout.prototype.execute = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var self, nodes, center, nodeMap, nodeIdxMap;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        self = this;\n                        nodes = self.nodes;\n                        if (!nodes || nodes.length === 0) {\n                            if (self.onLayoutEnd)\n                                self.onLayoutEnd();\n                            return [2 /*return*/];\n                        }\n                        if (!self.width && typeof window !== \"undefined\") {\n                            self.width = window.innerWidth;\n                        }\n                        if (!self.height && typeof window !== \"undefined\") {\n                            self.height = window.innerHeight;\n                        }\n                        if (!self.center) {\n                            self.center = [self.width / 2, self.height / 2];\n                        }\n                        center = self.center;\n                        if (nodes.length === 1) {\n                            nodes[0].x = center[0];\n                            nodes[0].y = center[1];\n                            if (self.onLayoutEnd)\n                                self.onLayoutEnd();\n                            return [2 /*return*/];\n                        }\n                        nodeMap = {};\n                        nodeIdxMap = {};\n                        nodes.forEach(function (node, i) {\n                            if (!util_1.isNumber(node.x))\n                                node.x = Math.random() * self.width;\n                            if (!util_1.isNumber(node.y))\n                                node.y = Math.random() * self.height;\n                            nodeMap[node.id] = node;\n                            nodeIdxMap[node.id] = i;\n                        });\n                        self.nodeMap = nodeMap;\n                        self.nodeIdxMap = nodeIdxMap;\n                        self.nodeStrength = gpu_1.proccessToFunc(self.nodeStrength, 1);\n                        self.edgeStrength = gpu_1.proccessToFunc(self.edgeStrength, 1);\n                        // layout\n                        return [4 /*yield*/, self.run()];\n                    case 1:\n                        // layout\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    GForceGPULayout.prototype.executeWithWorker = function (canvas, ctx) {\n        var self = this;\n        var nodes = self.nodes;\n        var center = self.center;\n        if (!nodes || nodes.length === 0) {\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            return;\n        }\n        var nodeMap = {};\n        var nodeIdxMap = {};\n        nodes.forEach(function (node, i) {\n            if (!util_1.isNumber(node.x))\n                node.x = Math.random() * self.width;\n            if (!util_1.isNumber(node.y))\n                node.y = Math.random() * self.height;\n            nodeMap[node.id] = node;\n            nodeIdxMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.nodeIdxMap = nodeIdxMap;\n        self.nodeStrength = gpu_1.proccessToFunc(self.nodeStrength, 1);\n        self.edgeStrength = gpu_1.proccessToFunc(self.edgeStrength, 1);\n        // layout\n        self.run(canvas, ctx);\n    };\n    GForceGPULayout.prototype.run = function (canvas, ctx) {\n        return __awaiter(this, void 0, void 0, function () {\n            var self, nodes, edges, maxIteration, numParticles, _a, maxEdgePerVetex, nodesEdgesArray, masses, nodeStrengths, centerXs, centerYs, centerGravities, fxs, fys, gravity, center, nodeAttributeArray1, nodeAttributeArray2, workerEnabled, world, onLayoutEnd, initPreviousData, i, kernelGForce, kernelAveMovement, execute;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        self = this;\n                        nodes = self.nodes;\n                        edges = self.edges;\n                        maxIteration = self.maxIteration;\n                        if (!self.width && typeof window !== \"undefined\") {\n                            self.width = window.innerWidth;\n                        }\n                        if (!self.height && typeof window !== \"undefined\") {\n                            self.height = window.innerHeight;\n                        }\n                        numParticles = nodes.length;\n                        self.linkDistance = gpu_1.proccessToFunc(self.linkDistance);\n                        self.edgeStrength = gpu_1.proccessToFunc(self.edgeStrength);\n                        _a = gpu_1.buildTextureDataWithTwoEdgeAttr(nodes, edges, self.linkDistance, self.edgeStrength), maxEdgePerVetex = _a.maxEdgePerVetex, nodesEdgesArray = _a.array;\n                        // init degree for mass\n                        self.degrees = math_1.getDegree(nodes.length, self.nodeIdxMap, edges);\n                        masses = [];\n                        nodeStrengths = [];\n                        centerXs = [];\n                        centerYs = [];\n                        centerGravities = [];\n                        fxs = [];\n                        fys = [];\n                        if (!self.getMass) {\n                            self.getMass = function (d) {\n                                return self.degrees[self.nodeIdxMap[d.id]] || 1;\n                            };\n                        }\n                        gravity = self.gravity;\n                        center = self.center;\n                        nodes.forEach(function (node, i) {\n                            masses.push(self.getMass(node));\n                            nodeStrengths.push(self.nodeStrength(node));\n                            if (!self.degrees[i])\n                                self.degrees[i] = 0;\n                            var nodeGravity = [center[0], center[1], gravity];\n                            if (self.getCenter) {\n                                var customCenter = self.getCenter(node, self.degrees[i]);\n                                if (customCenter &&\n                                    util_1.isNumber(customCenter[0]) &&\n                                    util_1.isNumber(customCenter[1]) &&\n                                    util_1.isNumber(customCenter[2])) {\n                                    nodeGravity = customCenter;\n                                }\n                            }\n                            centerXs.push(nodeGravity[0]);\n                            centerYs.push(nodeGravity[1]);\n                            centerGravities.push(nodeGravity[2]);\n                            if (util_1.isNumber(node.fx) && util_1.isNumber(node.fy)) {\n                                fxs.push(node.fx || 0.001);\n                                fys.push(node.fy || 0.001);\n                            }\n                            else {\n                                fxs.push(0);\n                                fys.push(0);\n                            }\n                        });\n                        nodeAttributeArray1 = gpu_1.arrayToTextureData([\n                            masses,\n                            self.degrees,\n                            nodeStrengths,\n                            fxs\n                        ]);\n                        nodeAttributeArray2 = gpu_1.arrayToTextureData([\n                            centerXs,\n                            centerYs,\n                            centerGravities,\n                            fys\n                        ]);\n                        workerEnabled = self.workerEnabled;\n                        if (workerEnabled) {\n                            world = g_webgpu_1.World.create({\n                                canvas: canvas,\n                                engineOptions: {\n                                    supportCompute: true\n                                }\n                            });\n                        }\n                        else {\n                            world = g_webgpu_1.World.create({\n                                engineOptions: {\n                                    supportCompute: true\n                                }\n                            });\n                        }\n                        onLayoutEnd = self.onLayoutEnd;\n                        initPreviousData = [];\n                        nodesEdgesArray.forEach(function (value) {\n                            initPreviousData.push(value);\n                        });\n                        for (i = 0; i < 4; i++) {\n                            initPreviousData.push(0);\n                        }\n                        kernelGForce = world\n                            .createKernel(gForceShader_1.gForceBundle)\n                            .setDispatch([numParticles, 1, 1])\n                            .setBinding({\n                            u_Data: nodesEdgesArray,\n                            u_damping: self.damping,\n                            u_maxSpeed: self.maxSpeed,\n                            u_minMovement: self.minMovement,\n                            u_coulombDisScale: self.coulombDisScale,\n                            u_factor: self.factor,\n                            u_NodeAttributeArray1: nodeAttributeArray1,\n                            u_NodeAttributeArray2: nodeAttributeArray2,\n                            MAX_EDGE_PER_VERTEX: maxEdgePerVetex,\n                            VERTEX_COUNT: numParticles,\n                            u_AveMovement: initPreviousData,\n                            u_interval: self.interval // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新\n                        });\n                        kernelAveMovement = world\n                            .createKernel(gForceShader_1.aveMovementBundle)\n                            .setDispatch([1, 1, 1])\n                            .setBinding({\n                            u_Data: nodesEdgesArray,\n                            VERTEX_COUNT: numParticles,\n                            u_AveMovement: [0, 0, 0, 0]\n                        });\n                        execute = function () { return __awaiter(_this, void 0, void 0, function () {\n                            var i, stepInterval, finalParticleData;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        i = 0;\n                                        _a.label = 1;\n                                    case 1:\n                                        if (!(i < maxIteration)) return [3 /*break*/, 5];\n                                        // TODO: 似乎都来自 kernelGForce 是一个引用\n                                        // 当前坐标作为下一次迭代的 PreviousData\n                                        // if (i > 0) {\n                                        //   kernelAveMovement.setBinding({\n                                        //     u_PreviousData: kernelGForce\n                                        //   });\n                                        // }\n                                        // eslint-disable-next-line no-await-in-loop\n                                        return [4 /*yield*/, kernelGForce.execute()];\n                                    case 2:\n                                        // TODO: 似乎都来自 kernelGForce 是一个引用\n                                        // 当前坐标作为下一次迭代的 PreviousData\n                                        // if (i > 0) {\n                                        //   kernelAveMovement.setBinding({\n                                        //     u_PreviousData: kernelGForce\n                                        //   });\n                                        // }\n                                        // eslint-disable-next-line no-await-in-loop\n                                        _a.sent();\n                                        // midRes = await kernelGForce.getOutput();\n                                        // 每次迭代完成后\n                                        // 计算平均位移，用于提前终止迭代\n                                        kernelAveMovement.setBinding({\n                                            u_Data: kernelGForce\n                                        });\n                                        // eslint-disable-next-line no-await-in-loop\n                                        return [4 /*yield*/, kernelAveMovement.execute()];\n                                    case 3:\n                                        // eslint-disable-next-line no-await-in-loop\n                                        _a.sent();\n                                        stepInterval = Math.max(0.02, self.interval - i * 0.002);\n                                        kernelGForce.setBinding({\n                                            u_interval: stepInterval,\n                                            u_AveMovement: kernelAveMovement\n                                        });\n                                        _a.label = 4;\n                                    case 4:\n                                        i++;\n                                        return [3 /*break*/, 1];\n                                    case 5: return [4 /*yield*/, kernelGForce.getOutput()];\n                                    case 6:\n                                        finalParticleData = _a.sent();\n                                        // 所有迭代完成后\n                                        if (canvas) {\n                                            // 传递数据给主线程\n                                            ctx.postMessage({\n                                                type: constants_1.LAYOUT_MESSAGE.GPUEND,\n                                                vertexEdgeData: finalParticleData\n                                                // edgeIndexBufferData,\n                                            });\n                                        }\n                                        else {\n                                            nodes.forEach(function (node, i) {\n                                                var x = finalParticleData[4 * i];\n                                                var y = finalParticleData[4 * i + 1];\n                                                node.x = x;\n                                                node.y = y;\n                                            });\n                                        }\n                                        if (onLayoutEnd)\n                                            onLayoutEnd();\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); };\n                        return [4 /*yield*/, execute()];\n                    case 1:\n                        _b.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    GForceGPULayout.prototype.getType = function () {\n        return \"gForce-gpu\";\n    };\n    return GForceGPULayout;\n}(base_1.Base));\nexports.GForceGPULayout = GForceGPULayout;\n//# sourceMappingURL=gForce.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.aveMovementBundle = exports.aveMovementCode = exports.gForceBundle = exports.gForceCode = void 0;\nexports.gForceCode = \"\\nimport { globalInvocationID } from 'g-webgpu';\\n\\nconst MAX_EDGE_PER_VERTEX;\\nconst VERTEX_COUNT;\\nconst SHIFT_20 = 1048576;\\n\\n@numthreads(1, 1, 1)\\nclass GGForce {\\n  @in @out\\n  u_Data: vec4[];\\n\\n  @in\\n  u_damping: float;\\n  \\n  @in\\n  u_maxSpeed: float;\\n\\n  @in\\n  u_minMovement: float;\\n\\n  @in\\n  u_AveMovement: vec4[];\\n\\n  @in\\n  u_coulombDisScale: float;\\n\\n  @in\\n  u_factor: float;\\n\\n  @in\\n  u_NodeAttributeArray1: vec4[];\\n\\n  @in\\n  u_NodeAttributeArray2: vec4[];\\n\\n  @in\\n  u_interval: float;\\n\\n  unpack_float(packedValue: float): ivec2 {\\n    const packedIntValue = int(packedValue);\\n    const v0 = packedIntValue / SHIFT_20;\\n    return [v0, packedIntValue - v0 * SHIFT_20];\\n  }\\n\\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\\n    let ax = 0, ay = 0;\\n    for (let j: int = 0; j < VERTEX_COUNT; j++) {\\n      if (i != j) {\\n        const nextNode = this.u_Data[j];\\n        const vx = currentNode[0] - nextNode[0];\\n        const vy = currentNode[1] - nextNode[1];\\n        const dist = sqrt(vx * vx + vy * vy) + 0.01;\\n        const n_dist = (dist + 0.1) * this.u_coulombDisScale;\\n        const direx = vx / dist;\\n        const direy = vy / dist;\\n        const attributesi = this.u_NodeAttributeArray1[i];\\n        const attributesj = this.u_NodeAttributeArray1[j];\\n        const massi = attributesi[0];\\n        const nodeStrengthi = attributesi[2];\\n        const nodeStrengthj = attributesj[2];\\n        const nodeStrength = (nodeStrengthi + nodeStrengthj) / 2;\\n        // const param = nodeStrength * this.u_factor / (n_dist * n_dist * massi);\\n        const param = nodeStrength * this.u_factor / (n_dist * n_dist);\\n        ax += direx * param;\\n        ay += direy * param;\\n      }\\n    }\\n    return [ax, ay];\\n  }\\n\\n  calcGravity(i: int, currentNode: vec4, attributes2: vec4): vec2 {\\n    // note: attributes2 = [centerX, centerY, gravity, 0]\\n\\n    const vx = currentNode[0] - attributes2[0];\\n    const vy = currentNode[1] - attributes2[1];\\n    \\n    const ax = vx * attributes2[2];\\n    const ay = vy * attributes2[2];\\n    \\n    return [ax, ay];\\n  }\\n\\n  calcAttractive(i: int, currentNode: vec4, attributes1: vec4): vec2 {\\n    // note: attributes1 = [mass, degree, nodeSterngth, 0]\\n\\n    const mass = attributes1[0];\\n    let ax = 0, ay = 0;\\n    // const arr_offset = int(floor(currentNode[2] + 0.5));\\n    // const length = int(floor(currentNode[3] + 0.5));\\n\\n    const compressed = this.unpack_float(currentNode[2]);\\n    const length = compressed[0];\\n    const arr_offset = compressed[1];\\n\\n    const node_buffer: vec4;\\n    for (let p: int = 0; p < MAX_EDGE_PER_VERTEX; p++) {\\n      if (p >= length) break;\\n      const arr_idx = arr_offset + 4 * p; // i \\u8282\\u70B9\\u7684\\u7B2C p \\u6761\\u8FB9\\u5F00\\u59CB\\u7684\\u5C0F\\u683C\\u5B50\\u4F4D\\u7F6E\\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\\n      if (p == 0 || buf_offset == 0) {\\n        node_buffer = this.u_Data[int(arr_idx / 4)]; // \\u5927\\u683C\\u5B50\\uFF0C\\u5927\\u683C\\u5B50\\u4F4D\\u7F6E=\\u5C0F\\u4E2A\\u5B50\\u4F4D\\u7F6E / 4\\uFF0C\\n      }\\n\\n      let float_j: float = node_buffer[0];\\n\\n      const nextNode = this.u_Data[int(float_j)];\\n      const vx = nextNode[0] - currentNode[0];\\n      const vy = nextNode[1] - currentNode[1];\\n      const dist = sqrt(vx * vx + vy * vy) + 0.01;\\n      const direx = vx / dist;\\n      const direy = vy / dist;\\n      const edgeLength = node_buffer[1];\\n      const edgeStrength = node_buffer[2];\\n      const diff: float = edgeLength - dist;//edgeLength\\n      // const param = diff * this.u_stiffness / mass; //\\n      const param = diff * edgeStrength / mass; // \\n      ax -= direx * param;\\n      ay -= direy * param;\\n    }\\n    return [ax, ay];\\n  }\\n\\n  @main\\n  compute() {\\n    const i = globalInvocationID.x;\\n    const currentNode = this.u_Data[i];\\n    const movement = u_AveMovement[0];\\n    let ax = 0, ay = 0;\\n\\n    if (i >= VERTEX_COUNT || movement.x < u_minMovement) {\\n      this.u_Data[i] = currentNode;\\n      return;\\n    }\\n\\n    // \\u6BCF\\u4E2A\\u8282\\u70B9\\u5C5E\\u6027\\u5360\\u4E24\\u4E2A\\u6570\\u7EC4\\u4E2D\\u5404\\u4E00\\u683C\\n    // [mass, degree, nodeStrength, fx]\\n    const nodeAttributes1 = this.u_NodeAttributeArray1[i];\\n    // [centerX, centerY, centerGravity, fy]\\n    const nodeAttributes2 = this.u_NodeAttributeArray2[i];\\n\\n    // repulsive\\n    const repulsive = this.calcRepulsive(i, currentNode);\\n    ax += repulsive[0];\\n    ay += repulsive[1];\\n\\n    // attractive\\n    const attractive = this.calcAttractive(i, currentNode, nodeAttributes1);\\n    ax += attractive[0];\\n    ay += attractive[1];\\n\\n    // gravity\\n    const gravity = this.calcGravity(i, currentNode, nodeAttributes2);\\n    ax -= gravity[0];\\n    ay -= gravity[1];\\n\\n    // speed\\n    const param = this.u_interval * this.u_damping;\\n    let vx = ax * param;\\n    let vy = ay * param;\\n    const vlength = sqrt(vx * vx + vy * vy) + 0.0001;\\n    if (vlength > this.u_maxSpeed) {\\n      const param2 = this.u_maxSpeed / vlength;\\n      vx = param2 * vx;\\n      vy = param2 * vy;\\n    }\\n\\n    // move\\n    if (nodeAttributes1[3] != 0 && nodeAttributes2[3] != 0) {\\n      this.u_Data[i] = [\\n        nodeAttributes1[3],\\n        nodeAttributes2[3],\\n        currentNode[2],\\n        0\\n      ];\\n    } else {\\n      const distx = vx * this.u_interval;\\n      const disty = vy * this.u_interval;\\n      const distLength = sqrt(distx * distx + disty * disty);\\n      this.u_Data[i] = [\\n        currentNode[0] + distx,\\n        currentNode[1] + disty,\\n        currentNode[2],\\n        distLength\\n      ];\\n    }\\n    \\n    // the avarage move distance\\n    // need to share memory\\n    \\n  }\\n}\\n\";\nexports.gForceBundle = \"{\\\"shaders\\\":{\\\"WGSL\\\":\\\"import \\\\\\\"GLSL.std.450\\\\\\\" as std;\\\\n\\\\n\\\\n# var gWebGPUDebug : bool = false;\\\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\\\n\\\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\\\n[[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\\\n[[builtin local_invocation_idx]] var<in> localInvocationIndex : u32;\\\\n\\\\ntype GWebGPUParams = [[block]] struct {\\\\n  [[offset 0]] u_damping : f32;\\\\n  [[offset 4]] u_maxSpeed : f32;\\\\n  [[offset 8]] u_minMovement : f32;\\\\n  \\\\n  [[offset 12]] u_coulombDisScale : f32;\\\\n  [[offset 16]] u_factor : f32;\\\\n  \\\\n  \\\\n  [[offset 20]] u_interval : f32;\\\\n};\\\\n[[binding 0, set 0]] var<uniform> gWebGPUUniformParams : GWebGPUParams;\\\\ntype GWebGPUBuffer0 = [[block]] struct {\\\\n  [[offset 0]] u_Data : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\\\ntype GWebGPUBuffer1 = [[block]] struct {\\\\n  [[offset 0]] u_AveMovement : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 2, set 0]] var<storage_buffer> gWebGPUBuffer1 : GWebGPUBuffer1;\\\\ntype GWebGPUBuffer2 = [[block]] struct {\\\\n  [[offset 0]] u_NodeAttributeArray1 : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 3, set 0]] var<storage_buffer> gWebGPUBuffer2 : GWebGPUBuffer2;\\\\ntype GWebGPUBuffer3 = [[block]] struct {\\\\n  [[offset 0]] u_NodeAttributeArray2 : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 4, set 0]] var<storage_buffer> gWebGPUBuffer3 : GWebGPUBuffer3;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nfn unpack_float(packedValue : f32) -> vec2<i32> {var packedIntValue : i32 = i32(packedValue);\\\\nvar v0 : i32 = packedIntValue / 1048576;\\\\nreturn vec2<i32>(v0, packedIntValue - (v0 * 1048576));}\\\\nfn calcRepulsive(i : i32, currentNode : vec4<f32>) -> vec2<f32> {var ax : f32 = 0.0;\\\\nvar ay : f32 = 0.0;\\\\nfor (var j : i32 = 0; j < __DefineValuePlaceholder__VERTEX_COUNT; j = j + 1) {if (i != j) {var nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[j];\\\\nvar vx : f32 = currentNode.x - nextNode.x;\\\\nvar vy : f32 = currentNode.y - nextNode.y;\\\\nvar dist : f32 = std::sqrt((vx * vx) + (vy * vy)) + 0.01;\\\\nvar n_dist : f32 = (dist + 0.1) * gWebGPUUniformParams.u_coulombDisScale;\\\\nvar direx : f32 = vx / dist;\\\\nvar direy : f32 = vy / dist;\\\\nvar attributesi : vec4<f32> = gWebGPUBuffer2.u_NodeAttributeArray1[i];\\\\nvar attributesj : vec4<f32> = gWebGPUBuffer2.u_NodeAttributeArray1[j];\\\\nvar massi : f32 = attributesi.x;\\\\nvar nodeStrengthi : f32 = attributesi.z;\\\\nvar nodeStrengthj : f32 = attributesj.z;\\\\nvar nodeStrength : f32 = (nodeStrengthi + nodeStrengthj) / 2.0;\\\\nvar param : f32 = (nodeStrength * gWebGPUUniformParams.u_factor) / (n_dist * n_dist);\\\\nax = ax + direx * param;\\\\nay = ay + direy * param;}}\\\\nreturn vec2<f32>(ax, ay);}\\\\nfn calcGravity(i : i32, currentNode : vec4<f32>, attributes2 : vec4<f32>) -> vec2<f32> {var vx : f32 = currentNode.x - attributes2.x;\\\\nvar vy : f32 = currentNode.y - attributes2.y;\\\\nvar ax : f32 = vx * attributes2.z;\\\\nvar ay : f32 = vy * attributes2.z;\\\\nreturn vec2<f32>(ax, ay);}\\\\nfn calcAttractive(i : i32, currentNode : vec4<f32>, attributes1 : vec4<f32>) -> vec2<f32> {var mass : f32 = attributes1.x;\\\\nvar ax : f32 = 0.0;\\\\nvar ay : f32 = 0.0;\\\\nvar compressed : vec2<i32> = unpack_float(currentNode.z);\\\\nvar length : i32 = compressed.x;\\\\nvar arr_offset : i32 = compressed.y;\\\\nvar node_buffer : vec4<f32>;\\\\nfor (var p : i32 = 0; p < __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX; p = p + 1) {if (p >= length) {break;}\\\\nvar arr_idx : i32 = arr_offset + (4 * p);\\\\nvar buf_offset : i32 = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[i32(arr_idx / 4)];}\\\\nvar float_j : f32 = node_buffer.x;\\\\nvar nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[i32(float_j)];\\\\nvar vx : f32 = nextNode.x - currentNode.x;\\\\nvar vy : f32 = nextNode.y - currentNode.y;\\\\nvar dist : f32 = std::sqrt((vx * vx) + (vy * vy)) + 0.01;\\\\nvar direx : f32 = vx / dist;\\\\nvar direy : f32 = vy / dist;\\\\nvar edgeLength : f32 = node_buffer.y;\\\\nvar edgeStrength : f32 = node_buffer.z;\\\\nvar diff : f32 = edgeLength - dist;\\\\nvar param : f32 = (diff * edgeStrength) / mass;\\\\nax = ax - direx * param;\\\\nay = ay - direy * param;}\\\\nreturn vec2<f32>(ax, ay);}\\\\nfn main() -> void {var i : i32 = globalInvocationID.x;\\\\nvar currentNode : vec4<f32> = gWebGPUBuffer0.u_Data[i];\\\\nvar movement : vec4<f32> = gWebGPUBuffer1.u_AveMovement[0];\\\\nvar ax : f32 = 0.0;\\\\nvar ay : f32 = 0.0;\\\\nif ((i >= __DefineValuePlaceholder__VERTEX_COUNT) || (movement.x < gWebGPUUniformParams.u_minMovement)) {gWebGPUBuffer0.u_Data[i] = currentNode;\\\\nreturn ;}\\\\nvar nodeAttributes1 : vec4<f32> = gWebGPUBuffer2.u_NodeAttributeArray1[i];\\\\nvar nodeAttributes2 : vec4<f32> = gWebGPUBuffer3.u_NodeAttributeArray2[i];\\\\nvar repulsive : vec2<f32> = calcRepulsive(i, currentNode);\\\\nax = ax + repulsive.x;\\\\nay = ay + repulsive.y;\\\\nvar attractive : vec2<f32> = calcAttractive(i, currentNode, nodeAttributes1);\\\\nax = ax + attractive.x;\\\\nay = ay + attractive.y;\\\\nvar gravity : vec2<f32> = calcGravity(i, currentNode, nodeAttributes2);\\\\nax = ax - gravity.x;\\\\nay = ay - gravity.y;\\\\nvar param : f32 = gWebGPUUniformParams.u_interval * gWebGPUUniformParams.u_damping;\\\\nvar vx : f32 = ax * param;\\\\nvar vy : f32 = ay * param;\\\\nvar vlength : f32 = std::sqrt((vx * vx) + (vy * vy)) + 0.0001;\\\\nif (vlength > gWebGPUUniformParams.u_maxSpeed) {var param2 : f32 = gWebGPUUniformParams.u_maxSpeed / vlength;\\\\nvx = param2 * vx;\\\\nvy = param2 * vy;}\\\\nvar distx : f32 = vx * gWebGPUUniformParams.u_interval;\\\\nvar disty : f32 = vy * gWebGPUUniformParams.u_interval;\\\\nvar distLength : f32 = std::sqrt((distx * distx) + (disty * disty));\\\\nif ((nodeAttributes1.w != 0.0) && (nodeAttributes2.w != 0.0)) {gWebGPUBuffer0.u_Data[i] = vec4<f32>(nodeAttributes1.w, nodeAttributes2.w, currentNode.z, 0.0);}else {gWebGPUBuffer0.u_Data[i] = vec4<f32>(currentNode.x + distx, currentNode.y + disty, currentNode.z, distLength);}\\\\nreturn;}\\\\n\\\\nentry_point compute as \\\\\\\"main\\\\\\\" = main;\\\\n\\\",\\\"GLSL450\\\":\\\"\\\\n\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\\\nivec3 workGroupSize = ivec3(1,1,1);\\\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\\\n\\\\nlayout(std140, set = 0, binding = 0) uniform GWebGPUParams {\\\\n  float u_damping;\\\\n  float u_maxSpeed;\\\\n  float u_minMovement;\\\\n  \\\\n  float u_coulombDisScale;\\\\n  float u_factor;\\\\n  \\\\n  \\\\n  float u_interval;\\\\n} gWebGPUUniformParams;\\\\nlayout(std430, set = 0, binding = 1) buffer   GWebGPUBuffer0 {\\\\n  vec4 u_Data[];\\\\n} gWebGPUBuffer0;\\\\n\\\\nlayout(std430, set = 0, binding = 2) buffer readonly  GWebGPUBuffer1 {\\\\n  vec4 u_AveMovement[];\\\\n} gWebGPUBuffer1;\\\\n\\\\nlayout(std430, set = 0, binding = 3) buffer readonly  GWebGPUBuffer2 {\\\\n  vec4 u_NodeAttributeArray1[];\\\\n} gWebGPUBuffer2;\\\\n\\\\nlayout(std430, set = 0, binding = 4) buffer readonly  GWebGPUBuffer3 {\\\\n  vec4 u_NodeAttributeArray2[];\\\\n} gWebGPUBuffer3;\\\\n\\\\n\\\\n\\\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\n#define SHIFT_20 1048576.0\\\\nlayout (\\\\n  local_size_x = 1,\\\\n  local_size_y = 1,\\\\n  local_size_z = 1\\\\n) in;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nivec2 unpack_float(float packedValue) {int packedIntValue = int(packedValue);\\\\nint v0 = packedIntValue / int(SHIFT_20);\\\\nreturn ivec2(v0, packedIntValue - (v0 * int(SHIFT_20)));}\\\\nvec2 calcRepulsive(int i, vec4 currentNode) {float ax = 0.0;\\\\nfloat ay = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = gWebGPUBuffer0.u_Data[j];\\\\nfloat vx = currentNode.x - nextNode.x;\\\\nfloat vy = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\\\nfloat n_dist = (dist + 0.1) * gWebGPUUniformParams.u_coulombDisScale;\\\\nfloat direx = vx / dist;\\\\nfloat direy = vy / dist;\\\\nvec4 attributesi = gWebGPUBuffer2.u_NodeAttributeArray1[i];\\\\nvec4 attributesj = gWebGPUBuffer2.u_NodeAttributeArray1[j];\\\\nfloat massi = attributesi.x;\\\\nfloat nodeStrengthi = attributesi.z;\\\\nfloat nodeStrengthj = attributesj.z;\\\\nfloat nodeStrength = (nodeStrengthi + nodeStrengthj) / 2.0;\\\\nfloat param = (nodeStrength * gWebGPUUniformParams.u_factor) / (n_dist * n_dist);\\\\nax += direx * param;\\\\nay += direy * param;}}\\\\nreturn vec2(ax, ay);}\\\\nvec2 calcGravity(int i, vec4 currentNode, vec4 attributes2) {float vx = currentNode.x - attributes2.x;\\\\nfloat vy = currentNode.y - attributes2.y;\\\\nfloat ax = vx * attributes2.z;\\\\nfloat ay = vy * attributes2.z;\\\\nreturn vec2(ax, ay);}\\\\nvec2 calcAttractive(int i, vec4 currentNode, vec4 attributes1) {float mass = attributes1.x;\\\\nfloat ax = 0.0;\\\\nfloat ay = 0.0;\\\\nivec2 compressed = unpack_float(currentNode.z);\\\\nint length = compressed.x;\\\\nint arr_offset = compressed.y;\\\\nvec4 node_buffer;\\\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\\\nint arr_idx = arr_offset + (4 * p);\\\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[int(arr_idx / 4)];}\\\\nfloat float_j = node_buffer.x;\\\\nvec4 nextNode = gWebGPUBuffer0.u_Data[int(float_j)];\\\\nfloat vx = nextNode.x - currentNode.x;\\\\nfloat vy = nextNode.y - currentNode.y;\\\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\\\nfloat direx = vx / dist;\\\\nfloat direy = vy / dist;\\\\nfloat edgeLength = node_buffer.y;\\\\nfloat edgeStrength = node_buffer.z;\\\\nfloat diff = edgeLength - dist;\\\\nfloat param = (diff * edgeStrength) / mass;\\\\nax -= direx * param;\\\\nay -= direy * param;}\\\\nreturn vec2(ax, ay);}\\\\nvoid main() {int i = globalInvocationID.x;\\\\nvec4 currentNode = gWebGPUBuffer0.u_Data[i];\\\\nvec4 movement = gWebGPUBuffer1.u_AveMovement[0];\\\\nfloat ax = 0.0;\\\\nfloat ay = 0.0;\\\\nif ((i >= VERTEX_COUNT) || (movement.x < gWebGPUUniformParams.u_minMovement)) {gWebGPUBuffer0.u_Data[i] = currentNode;\\\\nreturn ;}\\\\nvec4 nodeAttributes1 = gWebGPUBuffer2.u_NodeAttributeArray1[i];\\\\nvec4 nodeAttributes2 = gWebGPUBuffer3.u_NodeAttributeArray2[i];\\\\nvec2 repulsive = calcRepulsive(i, currentNode);\\\\nax += repulsive.x;\\\\nay += repulsive.y;\\\\nvec2 attractive = calcAttractive(i, currentNode, nodeAttributes1);\\\\nax += attractive.x;\\\\nay += attractive.y;\\\\nvec2 gravity = calcGravity(i, currentNode, nodeAttributes2);\\\\nax -= gravity.x;\\\\nay -= gravity.y;\\\\nfloat param = gWebGPUUniformParams.u_interval * gWebGPUUniformParams.u_damping;\\\\nfloat vx = ax * param;\\\\nfloat vy = ay * param;\\\\nfloat vlength = sqrt((vx * vx) + (vy * vy)) + 0.0001;\\\\nif (vlength > gWebGPUUniformParams.u_maxSpeed) {float param2 = gWebGPUUniformParams.u_maxSpeed / vlength;\\\\nvx = param2 * vx;\\\\nvy = param2 * vy;}\\\\nfloat distx = vx * gWebGPUUniformParams.u_interval;\\\\nfloat disty = vy * gWebGPUUniformParams.u_interval;\\\\nfloat distLength = sqrt((distx * distx) + (disty * disty));\\\\nif ((nodeAttributes1.w != 0.0) && (nodeAttributes2.w != 0.0)) {gWebGPUBuffer0.u_Data[i] = vec4(nodeAttributes1.w, nodeAttributes2.w, currentNode.z, 0.0);}else {gWebGPUBuffer0.u_Data[i] = vec4(currentNode.x + distx, currentNode.y + disty, currentNode.z, distLength);}}\\\\n\\\",\\\"GLSL100\\\":\\\"\\\\n\\\\nfloat epsilon = 0.00001;\\\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\\\n  vec2 normAddr2D = float(address1D) * conv_const;\\\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\\\n}\\\\n\\\\nvoid barrier() {}\\\\n  \\\\n\\\\nuniform vec2 u_OutputTextureSize;\\\\nuniform int u_OutputTexelCount;\\\\nvarying vec2 v_TexCoord;\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\n#define SHIFT_20 1048576.0\\\\n\\\\nuniform sampler2D u_Data;\\\\nuniform vec2 u_DataSize;\\\\nvec4 getDatau_Data(vec2 address2D) {\\\\n  return vec4(texture2D(u_Data, address2D).rgba);\\\\n}\\\\nvec4 getDatau_Data(float address1D) {\\\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\\\n}\\\\nvec4 getDatau_Data(int address1D) {\\\\n  return getDatau_Data(float(address1D));\\\\n}\\\\nuniform float u_damping;\\\\nuniform float u_maxSpeed;\\\\nuniform float u_minMovement;\\\\nuniform sampler2D u_AveMovement;\\\\nuniform vec2 u_AveMovementSize;\\\\nvec4 getDatau_AveMovement(vec2 address2D) {\\\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\\\n}\\\\nvec4 getDatau_AveMovement(float address1D) {\\\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\\\n}\\\\nvec4 getDatau_AveMovement(int address1D) {\\\\n  return getDatau_AveMovement(float(address1D));\\\\n}\\\\nuniform float u_coulombDisScale;\\\\nuniform float u_factor;\\\\nuniform sampler2D u_NodeAttributeArray1;\\\\nuniform vec2 u_NodeAttributeArray1Size;\\\\nvec4 getDatau_NodeAttributeArray1(vec2 address2D) {\\\\n  return vec4(texture2D(u_NodeAttributeArray1, address2D).rgba);\\\\n}\\\\nvec4 getDatau_NodeAttributeArray1(float address1D) {\\\\n  return getDatau_NodeAttributeArray1(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray1Size));\\\\n}\\\\nvec4 getDatau_NodeAttributeArray1(int address1D) {\\\\n  return getDatau_NodeAttributeArray1(float(address1D));\\\\n}\\\\nuniform sampler2D u_NodeAttributeArray2;\\\\nuniform vec2 u_NodeAttributeArray2Size;\\\\nvec4 getDatau_NodeAttributeArray2(vec2 address2D) {\\\\n  return vec4(texture2D(u_NodeAttributeArray2, address2D).rgba);\\\\n}\\\\nvec4 getDatau_NodeAttributeArray2(float address1D) {\\\\n  return getDatau_NodeAttributeArray2(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray2Size));\\\\n}\\\\nvec4 getDatau_NodeAttributeArray2(int address1D) {\\\\n  return getDatau_NodeAttributeArray2(float(address1D));\\\\n}\\\\nuniform float u_interval;\\\\nivec2 unpack_float(float packedValue) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nint packedIntValue = int(packedValue);\\\\nint v0 = packedIntValue / int(SHIFT_20);\\\\nreturn ivec2(v0, packedIntValue - (v0 * int(SHIFT_20)));}\\\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat ax = 0.0;\\\\nfloat ay = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\\\nfloat vx = currentNode.x - nextNode.x;\\\\nfloat vy = currentNode.y - nextNode.y;\\\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\\\nfloat n_dist = (dist + 0.1) * u_coulombDisScale;\\\\nfloat direx = vx / dist;\\\\nfloat direy = vy / dist;\\\\nvec4 attributesi = getDatau_NodeAttributeArray1(i);\\\\nvec4 attributesj = getDatau_NodeAttributeArray1(j);\\\\nfloat massi = attributesi.x;\\\\nfloat nodeStrengthi = attributesi.z;\\\\nfloat nodeStrengthj = attributesj.z;\\\\nfloat nodeStrength = (nodeStrengthi + nodeStrengthj) / 2.0;\\\\nfloat param = (nodeStrength * u_factor) / (n_dist * n_dist);\\\\nax += direx * param;\\\\nay += direy * param;}}\\\\nreturn vec2(ax, ay);}\\\\nvec2 calcGravity(int i, vec4 currentNode, vec4 attributes2) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat vx = currentNode.x - attributes2.x;\\\\nfloat vy = currentNode.y - attributes2.y;\\\\nfloat ax = vx * attributes2.z;\\\\nfloat ay = vy * attributes2.z;\\\\nreturn vec2(ax, ay);}\\\\nvec2 calcAttractive(int i, vec4 currentNode, vec4 attributes1) {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat mass = attributes1.x;\\\\nfloat ax = 0.0;\\\\nfloat ay = 0.0;\\\\nivec2 compressed = unpack_float(currentNode.z);\\\\nint length = compressed.x;\\\\nint arr_offset = compressed.y;\\\\nvec4 node_buffer;\\\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\\\nint arr_idx = arr_offset + (4 * p);\\\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\\\nfloat float_j = node_buffer.x;\\\\nvec4 nextNode = getDatau_Data(int(float_j));\\\\nfloat vx = nextNode.x - currentNode.x;\\\\nfloat vy = nextNode.y - currentNode.y;\\\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\\\nfloat direx = vx / dist;\\\\nfloat direy = vy / dist;\\\\nfloat edgeLength = node_buffer.y;\\\\nfloat edgeStrength = node_buffer.z;\\\\nfloat diff = edgeLength - dist;\\\\nfloat param = (diff * edgeStrength) / mass;\\\\nax -= direx * param;\\\\nay -= direy * param;}\\\\nreturn vec2(ax, ay);}\\\\nvoid main() {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nint i = globalInvocationID.x;\\\\nvec4 currentNode = getDatau_Data(i);\\\\nvec4 movement = getDatau_AveMovement(0.0);\\\\nfloat ax = 0.0;\\\\nfloat ay = 0.0;\\\\nif ((i >= VERTEX_COUNT) || (movement.x < u_minMovement)) {gl_FragColor = vec4(currentNode);\\\\nreturn ;}\\\\nvec4 nodeAttributes1 = getDatau_NodeAttributeArray1(i);\\\\nvec4 nodeAttributes2 = getDatau_NodeAttributeArray2(i);\\\\nvec2 repulsive = calcRepulsive(i, currentNode);\\\\nax += repulsive.x;\\\\nay += repulsive.y;\\\\nvec2 attractive = calcAttractive(i, currentNode, nodeAttributes1);\\\\nax += attractive.x;\\\\nay += attractive.y;\\\\nvec2 gravity = calcGravity(i, currentNode, nodeAttributes2);\\\\nax -= gravity.x;\\\\nay -= gravity.y;\\\\nfloat param = u_interval * u_damping;\\\\nfloat vx = ax * param;\\\\nfloat vy = ay * param;\\\\nfloat vlength = sqrt((vx * vx) + (vy * vy)) + 0.0001;\\\\nif (vlength > u_maxSpeed) {float param2 = u_maxSpeed / vlength;\\\\nvx = param2 * vx;\\\\nvy = param2 * vy;}\\\\nfloat distx = vx * u_interval;\\\\nfloat disty = vy * u_interval;\\\\nfloat distLength = sqrt((distx * distx) + (disty * disty));\\\\nif ((nodeAttributes1.w != 0.0) && (nodeAttributes2.w != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes1.w, nodeAttributes2.w, currentNode.z, 0.0));}else {gl_FragColor = vec4(vec4(currentNode.x + distx, currentNode.y + disty, currentNode.z, distLength));}if (gWebGPUDebug) {\\\\n  gl_FragColor = gWebGPUDebugOutput;\\\\n}}\\\\n\\\"},\\\"context\\\":{\\\"name\\\":\\\"\\\",\\\"dispatch\\\":[1,1,1],\\\"threadGroupSize\\\":[1,1,1],\\\"maxIteration\\\":1,\\\"defines\\\":[{\\\"name\\\":\\\"MAX_EDGE_PER_VERTEX\\\",\\\"type\\\":\\\"Float\\\",\\\"runtime\\\":true},{\\\"name\\\":\\\"VERTEX_COUNT\\\",\\\"type\\\":\\\"Float\\\",\\\"runtime\\\":true},{\\\"name\\\":\\\"SHIFT_20\\\",\\\"type\\\":\\\"Float\\\",\\\"value\\\":1048576,\\\"runtime\\\":false}],\\\"uniforms\\\":[{\\\"name\\\":\\\"u_Data\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":false,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_damping\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_maxSpeed\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_minMovement\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_AveMovement\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_coulombDisScale\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_factor\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_NodeAttributeArray1\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_NodeAttributeArray2\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_interval\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]}],\\\"globalDeclarations\\\":[],\\\"output\\\":{\\\"name\\\":\\\"u_Data\\\",\\\"size\\\":[1,1],\\\"length\\\":1},\\\"needPingpong\\\":true}}\";\nexports.aveMovementCode = \"\\nconst VERTEX_COUNT;\\n@numthreads(1, 1, 1)\\nclass CalcAveMovement {\\n  @in\\n  u_Data: vec4[];\\n  @in\\n  u_iter: float;\\n  @in @out\\n  u_AveMovement: vec4[];\\n  @main\\n  compute() {\\n    let movement = 0;\\n    for (let j: int = 0; j < VERTEX_COUNT; j++) {\\n      const vertex = this.u_Data[j];\\n      movement += vertex[3];\\n    }\\n    movement = movement / float(VERTEX_COUNT);\\n    this.u_AveMovement[0] = [movement, 0, 0, 0];\\n  }\\n}\\n\";\nexports.aveMovementBundle = \"{\\\"shaders\\\":{\\\"WGSL\\\":\\\"import \\\\\\\"GLSL.std.450\\\\\\\" as std;\\\\n\\\\n\\\\n# var gWebGPUDebug : bool = false;\\\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\\\n\\\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\\\n[[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\\\n[[builtin local_invocation_idx]] var<in> localInvocationIndex : u32;\\\\n\\\\ntype GWebGPUParams = [[block]] struct {\\\\n  [[offset 0]] u_iter : f32;\\\\n};\\\\n[[binding 0, set 0]] var<uniform> gWebGPUUniformParams : GWebGPUParams;\\\\ntype GWebGPUBuffer0 = [[block]] struct {\\\\n  [[offset 0]] u_Data : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\\\ntype GWebGPUBuffer1 = [[block]] struct {\\\\n  [[offset 0]] u_AveMovement : [[stride 16]] array<vec4<f32>>;\\\\n};\\\\n[[binding 2, set 0]] var<storage_buffer> gWebGPUBuffer1 : GWebGPUBuffer1;\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nfn main() -> void {var movement : f32 = 0.0;\\\\nfor (var j : i32 = 0; j < __DefineValuePlaceholder__VERTEX_COUNT; j = j + 1) {var vertex : vec4<f32> = gWebGPUBuffer0.u_Data[j];\\\\nmovement = movement + vertex.w;}\\\\nmovement = movement / f32(__DefineValuePlaceholder__VERTEX_COUNT);\\\\ngWebGPUBuffer1.u_AveMovement[0] = vec4<f32>(movement, 0.0, 0.0, 0.0);\\\\nreturn;}\\\\n\\\\nentry_point compute as \\\\\\\"main\\\\\\\" = main;\\\\n\\\",\\\"GLSL450\\\":\\\"\\\\n\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\\\nivec3 workGroupSize = ivec3(1,1,1);\\\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\\\n\\\\nlayout(std140, set = 0, binding = 0) uniform GWebGPUParams {\\\\n  float u_iter;\\\\n} gWebGPUUniformParams;\\\\nlayout(std430, set = 0, binding = 1) buffer readonly  GWebGPUBuffer0 {\\\\n  vec4 u_Data[];\\\\n} gWebGPUBuffer0;\\\\n\\\\nlayout(std430, set = 0, binding = 2) buffer   GWebGPUBuffer1 {\\\\n  vec4 u_AveMovement[];\\\\n} gWebGPUBuffer1;\\\\n\\\\n\\\\n\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\nlayout (\\\\n  local_size_x = 1,\\\\n  local_size_y = 1,\\\\n  local_size_z = 1\\\\n) in;\\\\n\\\\n\\\\n\\\\nvoid main() {float movement = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 vertex = gWebGPUBuffer0.u_Data[j];\\\\nmovement += vertex.w;}\\\\nmovement = movement / float(VERTEX_COUNT);\\\\ngWebGPUBuffer1.u_AveMovement[0] = vec4(movement, 0.0, 0.0, 0.0);}\\\\n\\\",\\\"GLSL100\\\":\\\"\\\\n\\\\nfloat epsilon = 0.00001;\\\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\\\n  vec2 normAddr2D = float(address1D) * conv_const;\\\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\\\n}\\\\n\\\\nvoid barrier() {}\\\\n  \\\\n\\\\nuniform vec2 u_OutputTextureSize;\\\\nuniform int u_OutputTexelCount;\\\\nvarying vec2 v_TexCoord;\\\\n\\\\nbool gWebGPUDebug = false;\\\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\\\n\\\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\\\n\\\\nuniform sampler2D u_Data;\\\\nuniform vec2 u_DataSize;\\\\nvec4 getDatau_Data(vec2 address2D) {\\\\n  return vec4(texture2D(u_Data, address2D).rgba);\\\\n}\\\\nvec4 getDatau_Data(float address1D) {\\\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\\\n}\\\\nvec4 getDatau_Data(int address1D) {\\\\n  return getDatau_Data(float(address1D));\\\\n}\\\\nuniform float u_iter;\\\\nuniform sampler2D u_AveMovement;\\\\nuniform vec2 u_AveMovementSize;\\\\nvec4 getDatau_AveMovement(vec2 address2D) {\\\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\\\n}\\\\nvec4 getDatau_AveMovement(float address1D) {\\\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\\\n}\\\\nvec4 getDatau_AveMovement(int address1D) {\\\\n  return getDatau_AveMovement(float(address1D));\\\\n}\\\\nvoid main() {\\\\nivec3 workGroupSize = ivec3(1, 1, 1);\\\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\\\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\\\nfloat movement = 0.0;\\\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 vertex = getDatau_Data(j);\\\\nmovement += vertex.w;}\\\\nmovement = movement / float(VERTEX_COUNT);\\\\ngl_FragColor = vec4(vec4(movement, 0.0, 0.0, 0.0));if (gWebGPUDebug) {\\\\n  gl_FragColor = gWebGPUDebugOutput;\\\\n}}\\\\n\\\"},\\\"context\\\":{\\\"name\\\":\\\"\\\",\\\"dispatch\\\":[1,1,1],\\\"threadGroupSize\\\":[1,1,1],\\\"maxIteration\\\":1,\\\"defines\\\":[{\\\"name\\\":\\\"VERTEX_COUNT\\\",\\\"type\\\":\\\"Float\\\",\\\"runtime\\\":true}],\\\"uniforms\\\":[{\\\"name\\\":\\\"u_Data\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_iter\\\",\\\"type\\\":\\\"Float\\\",\\\"storageClass\\\":\\\"Uniform\\\",\\\"readonly\\\":true,\\\"writeonly\\\":false,\\\"size\\\":[1,1]},{\\\"name\\\":\\\"u_AveMovement\\\",\\\"type\\\":\\\"vec4<f32>[]\\\",\\\"storageClass\\\":\\\"StorageBuffer\\\",\\\"readonly\\\":false,\\\"writeonly\\\":false,\\\"size\\\":[1,1]}],\\\"globalDeclarations\\\":[],\\\"output\\\":{\\\"name\\\":\\\"u_AveMovement\\\",\\\"size\\\":[1,1],\\\"length\\\":1},\\\"needPingpong\\\":true}}\";\n//# sourceMappingURL=gForceShader.js.map","\n/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ComboForceLayout = void 0;\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util\");\n/**\n * force layout for graph with combos\n */\nvar ComboForceLayout = /** @class */ (function (_super) {\n    __extends(ComboForceLayout, _super);\n    function ComboForceLayout(options) {\n        var _this = _super.call(this) || this;\n        /** 布局中心 */\n        _this.center = [0, 0];\n        /** 停止迭代的最大迭代数 */\n        _this.maxIteration = 100;\n        /** 重力大小，影响图的紧凑程度 */\n        _this.gravity = 10;\n        /** 群组中心力大小 */\n        _this.comboGravity = 10;\n        /** 默认边长度 */\n        _this.linkDistance = 10;\n        /** 每次迭代位移的衰减相关参数 */\n        _this.alpha = 1;\n        _this.alphaMin = 0.001;\n        _this.alphaDecay = 1 - Math.pow(_this.alphaMin, (1 / 300));\n        _this.alphaTarget = 0;\n        /** 节点运动速度衰减参数 */\n        _this.velocityDecay = 0.6;\n        /** 边引力大小 */\n        _this.edgeStrength = 0.6;\n        /** 节点引力大小 */\n        _this.nodeStrength = 30;\n        /** 是否开启防止重叠 */\n        _this.preventOverlap = false;\n        /** 是否开启节点之间的防止重叠 */\n        _this.preventNodeOverlap = false;\n        /** 是否开启 Combo 之间的防止重叠 */\n        _this.preventComboOverlap = false;\n        /** 防止重叠的碰撞力大小 */\n        _this.collideStrength = undefined;\n        /** 防止重叠的碰撞力大小 */\n        _this.nodeCollideStrength = 0.5;\n        /** 防止重叠的碰撞力大小 */\n        _this.comboCollideStrength = 0.5;\n        /** Combo 最小间距，防止重叠时的间隙 */\n        _this.comboSpacing = 20;\n        /** Combo 内部的 padding */\n        _this.comboPadding = 10;\n        /** 优化计算斥力的速度，两节点间距超过 optimizeRangeFactor * width 则不再计算斥力和重叠斥力 */\n        _this.optimizeRangeFactor = 1;\n        /** 每次迭代的回调函数 */\n        _this.onTick = function () { };\n        /** 迭代结束的回调函数 */\n        _this.onLayoutEnd = function () { };\n        /** 根据边两端节点层级差距的调整引力系数的因子，取值范围 [0, 1]。层级差距越大，引力越小 */\n        _this.depthAttractiveForceScale = 1;\n        /** 根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大 */\n        _this.depthRepulsiveForceScale = 2;\n        /** 内部计算参数 */\n        _this.nodes = [];\n        _this.edges = [];\n        _this.combos = [];\n        _this.comboTrees = [];\n        _this.width = 300;\n        _this.height = 300;\n        _this.bias = [];\n        _this.nodeMap = {};\n        _this.oriComboMap = {};\n        _this.indexMap = {};\n        _this.comboMap = {};\n        _this.previousLayouted = false;\n        _this.updateCfg(options);\n        return _this;\n    }\n    ComboForceLayout.prototype.getDefaultCfg = function () {\n        return {\n            maxIteration: 100,\n            center: [0, 0],\n            gravity: 10,\n            speed: 1,\n            comboGravity: 30,\n            preventOverlap: false,\n            preventComboOverlap: true,\n            preventNodeOverlap: true,\n            nodeSpacing: undefined,\n            collideStrength: undefined,\n            nodeCollideStrength: 0.5,\n            comboCollideStrength: 0.5,\n            comboSpacing: 20,\n            comboPadding: 10,\n            edgeStrength: 0.6,\n            nodeStrength: 30,\n            linkDistance: 10\n        };\n    };\n    /**\n     * 执行布局\n     */\n    ComboForceLayout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var center = self.center;\n        self.comboTree = {\n            id: \"comboTreeRoot\",\n            depth: -1,\n            children: self.comboTrees\n        };\n        if (!nodes || nodes.length === 0) {\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        if (nodes.length === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            if (self.onLayoutEnd)\n                self.onLayoutEnd();\n            return;\n        }\n        self.initVals();\n        // layout\n        self.run();\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n    };\n    ComboForceLayout.prototype.run = function () {\n        var self = this;\n        var nodes = self.nodes;\n        var maxIteration = self.previousLayouted\n            ? self.maxIteration / 5\n            : self.maxIteration;\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        var center = self.center;\n        var velocityDecay = self.velocityDecay;\n        // init the positions to make the nodes with same combo gather around the combo\n        var comboMap = self.comboMap;\n        if (!self.previousLayouted)\n            self.initPos(comboMap);\n        var _loop_1 = function (i) {\n            var displacements = [];\n            nodes.forEach(function (_, j) {\n                displacements[j] = { x: 0, y: 0 };\n            });\n            self.applyCalculate(displacements);\n            // gravity for combos\n            self.applyComboCenterForce(displacements);\n            // move\n            nodes.forEach(function (n, j) {\n                if (!util_1.isNumber(n.x) || !util_1.isNumber(n.y))\n                    return;\n                n.x += displacements[j].x * velocityDecay;\n                n.y += displacements[j].y * velocityDecay;\n            });\n            self.alpha += (self.alphaTarget - self.alpha) * self.alphaDecay;\n            self.onTick();\n        };\n        // iterate\n        for (var i = 0; i < maxIteration; i++) {\n            _loop_1(i);\n        }\n        // move to center\n        var meanCenter = [0, 0];\n        nodes.forEach(function (n) {\n            if (!util_1.isNumber(n.x) || !util_1.isNumber(n.y))\n                return;\n            meanCenter[0] += n.x;\n            meanCenter[1] += n.y;\n        });\n        meanCenter[0] /= nodes.length;\n        meanCenter[1] /= nodes.length;\n        var centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];\n        nodes.forEach(function (n, j) {\n            if (!util_1.isNumber(n.x) || !util_1.isNumber(n.y))\n                return;\n            n.x += centerOffset[0];\n            n.y += centerOffset[1];\n        });\n        // arrange the empty combo\n        self.combos.forEach(function (combo) {\n            var mapped = comboMap[combo.id];\n            if (mapped && mapped.empty) {\n                combo.x = mapped.cx || combo.x;\n                combo.y = mapped.cy || combo.y;\n            }\n        });\n        self.previousLayouted = true;\n    };\n    ComboForceLayout.prototype.initVals = function () {\n        var self = this;\n        var edges = self.edges;\n        var nodes = self.nodes;\n        var combos = self.combos;\n        var count = {};\n        var nodeMap = {};\n        var indexMap = {};\n        nodes.forEach(function (node, i) {\n            nodeMap[node.id] = node;\n            indexMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        self.indexMap = indexMap;\n        var oriComboMap = {};\n        combos.forEach(function (combo) {\n            oriComboMap[combo.id] = combo;\n        });\n        self.oriComboMap = oriComboMap;\n        self.comboMap = self.getComboMap();\n        var preventOverlap = self.preventOverlap;\n        self.preventComboOverlap = self.preventComboOverlap || preventOverlap;\n        self.preventNodeOverlap = self.preventNodeOverlap || preventOverlap;\n        var collideStrength = self.collideStrength;\n        if (collideStrength) {\n            self.comboCollideStrength = collideStrength;\n            self.nodeCollideStrength = collideStrength;\n        }\n        self.comboCollideStrength = self.comboCollideStrength\n            ? self.comboCollideStrength\n            : 0;\n        self.nodeCollideStrength = self.nodeCollideStrength\n            ? self.nodeCollideStrength\n            : 0;\n        // get edge bias\n        for (var i = 0; i < edges.length; ++i) {\n            if (count[edges[i].source])\n                count[edges[i].source]++;\n            else\n                count[edges[i].source] = 1;\n            if (count[edges[i].target])\n                count[edges[i].target]++;\n            else\n                count[edges[i].target] = 1;\n        }\n        var bias = [];\n        for (var i = 0; i < edges.length; ++i) {\n            bias[i] =\n                count[edges[i].source] /\n                    (count[edges[i].source] + count[edges[i].target]);\n        }\n        this.bias = bias;\n        var nodeSize = self.nodeSize;\n        var nodeSpacing = self.nodeSpacing;\n        var nodeSizeFunc;\n        var nodeSpacingFunc;\n        // nodeSpacing to function\n        if (util_1.isNumber(nodeSpacing)) {\n            nodeSpacingFunc = function () { return nodeSpacing; };\n        }\n        else if (util_1.isFunction(nodeSpacing)) {\n            nodeSpacingFunc = nodeSpacing;\n        }\n        else {\n            nodeSpacingFunc = function () { return 0; };\n        }\n        this.nodeSpacing = nodeSpacingFunc;\n        // nodeSize to function\n        if (!nodeSize) {\n            nodeSizeFunc = function (d) {\n                if (d.size) {\n                    if (util_1.isArray(d.size)) {\n                        var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n                        return res / 2;\n                    }\n                    return d.size / 2;\n                }\n                return 10;\n            };\n        }\n        else if (util_1.isFunction(nodeSize)) {\n            nodeSizeFunc = function (d) {\n                return nodeSize(d);\n            };\n        }\n        else if (util_1.isArray(nodeSize)) {\n            var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n            var radius_1 = larger / 2;\n            nodeSizeFunc = function (d) { return radius_1; };\n        }\n        else {\n            // number type\n            var radius_2 = nodeSize / 2;\n            nodeSizeFunc = function (d) { return radius_2; };\n        }\n        this.nodeSize = nodeSizeFunc;\n        // comboSpacing to function\n        var comboSpacing = self.comboSpacing;\n        var comboSpacingFunc;\n        if (util_1.isNumber(comboSpacing)) {\n            comboSpacingFunc = function () { return comboSpacing; };\n        }\n        else if (util_1.isFunction(comboSpacing)) {\n            comboSpacingFunc = comboSpacing;\n        }\n        else {\n            // null type\n            comboSpacingFunc = function () { return 0; };\n        }\n        this.comboSpacing = comboSpacingFunc;\n        // comboPadding to function\n        var comboPadding = self.comboPadding;\n        var comboPaddingFunc;\n        if (util_1.isNumber(comboPadding)) {\n            comboPaddingFunc = function () { return comboPadding; };\n        }\n        else if (util_1.isArray(comboPadding)) {\n            comboPaddingFunc = function () { return Math.max.apply(null, comboPadding); };\n        }\n        else if (util_1.isFunction(comboPadding)) {\n            comboPaddingFunc = comboPadding;\n        }\n        else {\n            // null type\n            comboPaddingFunc = function () { return 0; };\n        }\n        this.comboPadding = comboPaddingFunc;\n        // linkDistance to function\n        var linkDistance = this.linkDistance;\n        var linkDistanceFunc;\n        if (!linkDistance) {\n            linkDistance = 10;\n        }\n        if (util_1.isNumber(linkDistance)) {\n            linkDistanceFunc = function (d) {\n                return linkDistance;\n            };\n        }\n        else {\n            linkDistanceFunc = linkDistance;\n        }\n        this.linkDistance = linkDistanceFunc;\n        // linkStrength to function\n        var edgeStrength = this.edgeStrength;\n        var edgeStrengthFunc;\n        if (!edgeStrength) {\n            edgeStrength = 1;\n        }\n        if (util_1.isNumber(edgeStrength)) {\n            edgeStrengthFunc = function (d) {\n                return edgeStrength;\n            };\n        }\n        else {\n            edgeStrengthFunc = edgeStrength;\n        }\n        this.edgeStrength = edgeStrengthFunc;\n        // nodeStrength to function\n        var nodeStrength = this.nodeStrength;\n        var nodeStrengthFunc;\n        if (!nodeStrength) {\n            nodeStrength = 30;\n        }\n        if (util_1.isNumber(nodeStrength)) {\n            nodeStrengthFunc = function (d) {\n                return nodeStrength;\n            };\n        }\n        else {\n            nodeStrengthFunc = nodeStrength;\n        }\n        this.nodeStrength = nodeStrengthFunc;\n    };\n    ComboForceLayout.prototype.initPos = function (comboMap) {\n        var self = this;\n        var nodes = self.nodes;\n        nodes.forEach(function (node, i) {\n            var comboId = node.comboId;\n            var combo = comboMap[comboId];\n            if (comboId && combo) {\n                node.x = combo.cx + 100 / (i + 1);\n                node.y = combo.cy + 100 / (i + 1);\n            }\n            else {\n                node.x = 100 / (i + 1);\n                node.y = 100 / (i + 1);\n            }\n        });\n    };\n    ComboForceLayout.prototype.getComboMap = function () {\n        var self = this;\n        var nodeMap = self.nodeMap;\n        var indexMap = self.indexMap;\n        var comboTrees = self.comboTrees;\n        var oriComboMap = self.oriComboMap;\n        var comboMap = {};\n        (comboTrees || []).forEach(function (ctree) {\n            var treeChildren = [];\n            util_1.traverseTreeUp(ctree, function (treeNode) {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                if (!oriComboMap[treeNode.id])\n                    return true; // means it is hidden, skip it\n                if (comboMap[treeNode.id] === undefined) {\n                    var combo = {\n                        id: treeNode.id,\n                        name: treeNode.id,\n                        cx: 0,\n                        cy: 0,\n                        count: 0,\n                        depth: self.oriComboMap[treeNode.id].depth,\n                        children: []\n                    };\n                    comboMap[treeNode.id] = combo;\n                }\n                var children = treeNode.children;\n                if (children) {\n                    children.forEach(function (child) {\n                        if (!comboMap[child.id] && !nodeMap[child.id])\n                            return true; // means it is hidden\n                        treeChildren.push(child);\n                    });\n                }\n                var c = comboMap[treeNode.id];\n                c.cx = 0;\n                c.cy = 0;\n                // In order to layout the empty combo, add a virtual node to it\n                if (treeChildren.length === 0) {\n                    c.empty = true;\n                    var oriCombo = oriComboMap[treeNode.id];\n                    var idx = Object.keys(nodeMap).length;\n                    var virtualNodeId = treeNode.id + \"-visual-child-\" + idx;\n                    var vnode = {\n                        id: virtualNodeId,\n                        x: oriCombo.x,\n                        y: oriCombo.y,\n                        depth: c.depth + 1,\n                        itemType: \"node\"\n                    };\n                    self.nodes.push(vnode);\n                    nodeMap[virtualNodeId] = vnode;\n                    indexMap[virtualNodeId] = idx;\n                    c.cx = oriCombo.x;\n                    c.cy = oriCombo.y;\n                    treeChildren.push(vnode);\n                }\n                treeChildren.forEach(function (child) {\n                    c.count++;\n                    if (child.itemType !== \"node\") {\n                        var childCombo = comboMap[child.id];\n                        if (util_1.isNumber(childCombo.cx))\n                            c.cx += childCombo.cx;\n                        if (util_1.isNumber(childCombo.cy))\n                            c.cy += childCombo.cy;\n                        return;\n                    }\n                    var node = nodeMap[child.id];\n                    // means the node is hidden, skip it\n                    if (!node)\n                        return;\n                    if (util_1.isNumber(node.x)) {\n                        c.cx += node.x;\n                    }\n                    if (util_1.isNumber(node.y)) {\n                        c.cy += node.y;\n                    }\n                });\n                c.cx /= c.count;\n                c.cy /= c.count;\n                c.children = treeChildren;\n                return true;\n            });\n        });\n        return comboMap;\n    };\n    ComboForceLayout.prototype.applyComboCenterForce = function (displacements) {\n        var self = this;\n        var gravity = self.gravity;\n        var comboGravity = self.comboGravity || gravity;\n        var alpha = this.alpha;\n        var comboTrees = self.comboTrees;\n        var indexMap = self.indexMap;\n        var nodeMap = self.nodeMap;\n        var comboMap = self.comboMap;\n        (comboTrees || []).forEach(function (ctree) {\n            util_1.traverseTreeUp(ctree, function (treeNode) {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                var combo = comboMap[treeNode.id];\n                // means the combo is hidden, skip it\n                if (!combo)\n                    return true;\n                var c = comboMap[treeNode.id];\n                // higher depth the combo, larger the gravity\n                var gravityScale = ((c.depth + 1) / 10) * 0.5;\n                // apply combo center force for all the descend nodes in this combo\n                // and update the center position and count for this combo\n                var comboX = c.cx;\n                var comboY = c.cy;\n                c.cx = 0;\n                c.cy = 0;\n                c.children.forEach(function (child) {\n                    if (child.itemType !== \"node\") {\n                        var childCombo = comboMap[child.id];\n                        if (childCombo && util_1.isNumber(childCombo.cx))\n                            c.cx += childCombo.cx;\n                        if (childCombo && util_1.isNumber(childCombo.cy))\n                            c.cy += childCombo.cy;\n                        return;\n                    }\n                    var node = nodeMap[child.id];\n                    var vecX = node.x - comboX || 0.005;\n                    var vecY = node.y - comboY || 0.005;\n                    var l = Math.sqrt(vecX * vecX + vecY * vecY);\n                    var childIdx = indexMap[node.id];\n                    var params = ((comboGravity * alpha) / l) * gravityScale;\n                    displacements[childIdx].x -= vecX * params;\n                    displacements[childIdx].y -= vecY * params;\n                    if (util_1.isNumber(node.x))\n                        c.cx += node.x;\n                    if (util_1.isNumber(node.y))\n                        c.cy += node.y;\n                });\n                c.cx /= c.count;\n                c.cy /= c.count;\n                return true;\n            });\n        });\n    };\n    ComboForceLayout.prototype.applyCalculate = function (displacements) {\n        var self = this;\n        var comboMap = self.comboMap;\n        var nodes = self.nodes;\n        // store the vx, vy, and distance to reduce dulplicate calculation\n        var vecMap = {};\n        nodes.forEach(function (v, i) {\n            nodes.forEach(function (u, j) {\n                if (i < j)\n                    return;\n                var vx = v.x - u.x || 0.005;\n                var vy = v.y - u.y || 0.005;\n                var vl2 = vx * vx + vy * vy;\n                var vl = Math.sqrt(vl2);\n                if (vl2 < 1)\n                    vl2 = vl;\n                vecMap[v.id + \"-\" + u.id] = { vx: vx, vy: vy, vl2: vl2, vl: vl };\n                vecMap[u.id + \"-\" + v.id] = { vl2: vl2, vl: vl, vx: -vx, vy: -vy };\n            });\n        });\n        // get the sizes of the combos\n        self.updateComboSizes(comboMap);\n        self.calRepulsive(displacements, vecMap);\n        self.calAttractive(displacements, vecMap);\n        var preventComboOverlap = self.preventComboOverlap;\n        if (preventComboOverlap)\n            self.comboNonOverlapping(displacements, comboMap);\n    };\n    /**\n     * Update the sizes of the combos according to their children\n     * Used for combos nonoverlap, but not re-render the combo shapes\n     */\n    ComboForceLayout.prototype.updateComboSizes = function (comboMap) {\n        var self = this;\n        var comboTrees = self.comboTrees;\n        var nodeMap = self.nodeMap;\n        var nodeSize = self.nodeSize;\n        var comboSpacing = self.comboSpacing;\n        var comboPadding = self.comboPadding;\n        (comboTrees || []).forEach(function (ctree) {\n            var treeChildren = [];\n            util_1.traverseTreeUp(ctree, function (treeNode) {\n                if (treeNode.itemType === \"node\")\n                    return true; // skip it\n                var c = comboMap[treeNode.id];\n                // means the combo is hidden, skip it\n                if (!c)\n                    return false;\n                var children = treeNode.children;\n                if (children) {\n                    children.forEach(function (child) {\n                        // means the combo is hidden.\n                        if (!comboMap[child.id] && !nodeMap[child.id])\n                            return;\n                        treeChildren.push(child);\n                    });\n                }\n                c.minX = Infinity;\n                c.minY = Infinity;\n                c.maxX = -Infinity;\n                c.maxY = -Infinity;\n                treeChildren.forEach(function (child) {\n                    if (child.itemType !== \"node\")\n                        return true; // skip it\n                    var node = nodeMap[child.id];\n                    if (!node)\n                        return true; // means it is hidden\n                    var r = nodeSize(node);\n                    var nodeMinX = node.x - r;\n                    var nodeMinY = node.y - r;\n                    var nodeMaxX = node.x + r;\n                    var nodeMaxY = node.y + r;\n                    if (c.minX > nodeMinX)\n                        c.minX = nodeMinX;\n                    if (c.minY > nodeMinY)\n                        c.minY = nodeMinY;\n                    if (c.maxX < nodeMaxX)\n                        c.maxX = nodeMaxX;\n                    if (c.maxY < nodeMaxY)\n                        c.maxY = nodeMaxY;\n                });\n                var minSize = self.oriComboMap[treeNode.id].size || 10;\n                if (util_1.isArray(minSize))\n                    minSize = minSize[0];\n                var maxLength = Math.max(c.maxX - c.minX, c.maxY - c.minY, minSize);\n                c.r = maxLength / 2 + comboSpacing(c) / 2 + comboPadding(c);\n                return true;\n            });\n        });\n    };\n    /**\n     * prevent the overlappings among combos\n     */\n    ComboForceLayout.prototype.comboNonOverlapping = function (displacements, comboMap) {\n        var self = this;\n        var comboTree = self.comboTree;\n        var comboCollideStrength = self.comboCollideStrength;\n        var indexMap = self.indexMap;\n        var nodeMap = self.nodeMap;\n        util_1.traverseTreeUp(comboTree, function (treeNode) {\n            if (!comboMap[treeNode.id] &&\n                !nodeMap[treeNode.id] &&\n                treeNode.id !== \"comboTreeRoot\") {\n                return false;\n            } // means it is hidden\n            var children = treeNode.children;\n            // 同个子树下的子 combo 间两两对比\n            if (children && children.length > 1) {\n                children.forEach(function (v, i) {\n                    if (v.itemType === \"node\")\n                        return false; // skip it\n                    var cv = comboMap[v.id];\n                    if (!cv)\n                        return; // means it is hidden, skip it\n                    children.forEach(function (u, j) {\n                        if (i <= j)\n                            return false;\n                        if (u.itemType === \"node\")\n                            return false; // skip it\n                        var cu = comboMap[u.id];\n                        if (!cu)\n                            return false; // means it is hidden, skip it\n                        var vx = cv.cx - cu.cx || 0.005;\n                        var vy = cv.cy - cu.cy || 0.005;\n                        var l = vx * vx + vy * vy;\n                        var rv = cv.r;\n                        var ru = cu.r;\n                        var r = rv + ru;\n                        var ru2 = ru * ru;\n                        var rv2 = rv * rv;\n                        // overlapping\n                        if (l < r * r) {\n                            var vnodes = v.children;\n                            if (!vnodes || vnodes.length === 0)\n                                return false; // skip it\n                            var unodes_1 = u.children;\n                            if (!unodes_1 || unodes_1.length === 0)\n                                return false; // skip it\n                            var sqrtl = Math.sqrt(l);\n                            var ll = ((r - sqrtl) / sqrtl) * comboCollideStrength;\n                            var xl_1 = vx * ll;\n                            var yl_1 = vy * ll;\n                            var rratio_1 = ru2 / (rv2 + ru2);\n                            var irratio_1 = 1 - rratio_1;\n                            // 两兄弟 combo 的子节点上施加斥力\n                            vnodes.forEach(function (vn) {\n                                if (vn.itemType !== \"node\")\n                                    return false; // skip it\n                                if (!nodeMap[vn.id])\n                                    return; // means it is hidden, skip it\n                                var vindex = indexMap[vn.id];\n                                unodes_1.forEach(function (un) {\n                                    if (un.itemType !== \"node\")\n                                        return false;\n                                    if (!nodeMap[un.id])\n                                        return false; // means it is hidden, skip it\n                                    var uindex = indexMap[un.id];\n                                    displacements[vindex].x += xl_1 * rratio_1;\n                                    displacements[vindex].y += yl_1 * rratio_1;\n                                    displacements[uindex].x -= xl_1 * irratio_1;\n                                    displacements[uindex].y -= yl_1 * irratio_1;\n                                });\n                            });\n                        }\n                    });\n                });\n            }\n            return true;\n        });\n    };\n    /**\n     * Calculate the repulsive force between each node pair\n     * @param displacements The array stores the displacements for nodes\n     * @param vecMap The map stores vector between each node pair\n     */\n    ComboForceLayout.prototype.calRepulsive = function (displacements, vecMap) {\n        var self = this;\n        var nodes = self.nodes;\n        var max = self.width * self.optimizeRangeFactor;\n        var nodeStrength = self.nodeStrength;\n        var alpha = self.alpha;\n        var nodeCollideStrength = self.nodeCollideStrength;\n        var preventNodeOverlap = self.preventNodeOverlap;\n        var nodeSizeFunc = self.nodeSize;\n        var nodeSpacingFunc = self.nodeSpacing;\n        var scale = self.depthRepulsiveForceScale;\n        var center = self.center;\n        nodes.forEach(function (v, i) {\n            if (!v.x || !v.y)\n                return;\n            // center gravity\n            if (center) {\n                var gravity = self.gravity;\n                var vecX = v.x - center[0] || 0.005;\n                var vecY = v.y - center[1] || 0.005;\n                var l = Math.sqrt(vecX * vecX + vecY * vecY);\n                displacements[i].x -= (vecX * gravity * alpha) / l;\n                displacements[i].y -= (vecY * gravity * alpha) / l;\n            }\n            nodes.forEach(function (u, j) {\n                if (i === j) {\n                    return;\n                }\n                if (!u.x || !u.y)\n                    return;\n                var _a = vecMap[v.id + \"-\" + u.id], vl2 = _a.vl2, vl = _a.vl;\n                if (vl > max)\n                    return;\n                var _b = vecMap[v.id + \"-\" + u.id], vx = _b.vx, vy = _b.vy;\n                var depthDiff = Math.log(Math.abs(u.depth - v.depth) / 10) + 1 || 1;\n                depthDiff = depthDiff < 1 ? 1 : depthDiff;\n                if (u.comboId !== v.comboId)\n                    depthDiff += 1;\n                var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n                var params = ((nodeStrength(u) * alpha) / vl2) * depthParam;\n                displacements[i].x += vx * params;\n                displacements[i].y += vy * params;\n                // prevent node overlappings\n                if (i < j && preventNodeOverlap) {\n                    var ri = nodeSizeFunc(v) + nodeSpacingFunc(v);\n                    var rj = nodeSizeFunc(u) + nodeSpacingFunc(u);\n                    var r = ri + rj;\n                    if (vl2 < r * r) {\n                        var ll = ((r - vl) / vl) * nodeCollideStrength;\n                        var rj2 = rj * rj;\n                        var rratio = rj2 / (ri * ri + rj2);\n                        var xl = vx * ll;\n                        var yl = vy * ll;\n                        displacements[i].x += xl * rratio;\n                        displacements[i].y += yl * rratio;\n                        rratio = 1 - rratio;\n                        displacements[j].x -= xl * rratio;\n                        displacements[j].y -= yl * rratio;\n                    }\n                }\n            });\n        });\n    };\n    /**\n     * Calculate the attractive force between the node pair with edge\n     * @param displacements The array stores the displacements for nodes\n     * @param vecMap The map stores vector between each node pair\n     */\n    ComboForceLayout.prototype.calAttractive = function (displacements, vecMap) {\n        var self = this;\n        var edges = self.edges;\n        var linkDistance = self.linkDistance;\n        var alpha = self.alpha;\n        var edgeStrength = self.edgeStrength;\n        var bias = self.bias;\n        var scale = self.depthAttractiveForceScale;\n        edges.forEach(function (e, i) {\n            if (!e.source || !e.target || e.source === e.target)\n                return;\n            var uIndex = self.indexMap[e.source];\n            var vIndex = self.indexMap[e.target];\n            var u = self.nodeMap[e.source];\n            var v = self.nodeMap[e.target];\n            if (!u || !v)\n                return;\n            var depthDiff = Math.log(Math.abs(u.depth - v.depth) / 10);\n            if (u.comboId === v.comboId) {\n                depthDiff = depthDiff / 2;\n            }\n            var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n            if (u.comboId !== v.comboId && depthParam === 1) {\n                depthParam = scale / 2;\n            }\n            else if (u.comboId === v.comboId) {\n                depthParam = 2;\n            }\n            if (!util_1.isNumber(v.x) || !util_1.isNumber(u.x) || !util_1.isNumber(v.y) || !util_1.isNumber(u.y))\n                return;\n            var _a = vecMap[e.target + \"-\" + e.source], vl = _a.vl, vx = _a.vx, vy = _a.vy;\n            var l = ((vl - linkDistance(e)) / vl) * alpha * edgeStrength(e) * depthParam;\n            var vecX = vx * l;\n            var vecY = vy * l;\n            var b = bias[i];\n            displacements[vIndex].x -= vecX * b;\n            displacements[vIndex].y -= vecY * b;\n            displacements[uIndex].x += vecX * (1 - b);\n            displacements[uIndex].y += vecY * (1 - b);\n        });\n    };\n    ComboForceLayout.prototype.getType = function () {\n        return \"comboForce\";\n    };\n    return ComboForceLayout;\n}(base_1.Base));\nexports.ComboForceLayout = ComboForceLayout;\n//# sourceMappingURL=comboForce.js.map","\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ForceAtlas2Layout = void 0;\nvar base_1 = require(\"../base\");\nvar util_1 = require(\"../../util\");\nvar body_1 = __importDefault(require(\"./body\"));\nvar quad_1 = __importDefault(require(\"./quad\"));\nvar quadTree_1 = __importDefault(require(\"./quadTree\"));\nvar ForceAtlas2Layout = /** @class */ (function (_super) {\n    __extends(ForceAtlas2Layout, _super);\n    function ForceAtlas2Layout(options) {\n        var _this = _super.call(this) || this;\n        /** 布局中心 */\n        _this.center = [0, 0];\n        /** 宽度 */\n        _this.width = 300;\n        /** 高度 */\n        _this.height = 300;\n        _this.nodes = [];\n        _this.edges = [];\n        /**\n         * the parameter for repulsive forces,\n         * it will scale the layout but won't change the layout\n         * larger the kr, looser the layout\n         * @type  {number}\n         */\n        _this.kr = 5;\n        /**\n         * the parameter for gravity forces\n         * @type  {number}\n         */\n        _this.kg = 1;\n        /**\n         * modes:\n         * 'normal' for normal using\n         * 'linlog' for compact clusters.\n         * @type  {string}\n         */\n        _this.mode = 'normal';\n        /**\n         * whether preventing the node overlapping\n         * @type  {boolean}\n         */\n        _this.preventOverlap = false;\n        /**\n         * whether active the dissuade hub mode\n         * true: grant authorities (nodes with a high indegree)\n         * a more central position than hubs (nodes with a high outdegree)\n         * @type  {boolean}\n         */\n        _this.dissuadeHubs = false;\n        /**\n         * whether active the barnes hut optimization on computing repulsive forces\n         * @type  {boolean}\n         */\n        _this.barnesHut = false;\n        /**\n         * the max iteration number\n         * @type  {number}\n         */\n        _this.maxIteration = 0;\n        /**\n         * control the global velocity\n         * defualt: 0.1(gephi)\n         * @type  {number}\n         */\n        _this.ks = 0.1;\n        /**\n         * the max global velocity\n         * @type  {number}\n         */\n        _this.ksmax = 10;\n        /**\n         * the tolerance for the global swinging\n         * @type  {number}\n         */\n        _this.tao = 0.1;\n        /**\n         * the function of layout complete listener, display the legend and minimap after layout\n         * @type  {function}\n         */\n        _this.onLayoutEnd = function () { };\n        /**\n         * activate prune or not.\n         * prune the leaves during most iterations, layout the leaves in the last 50 iteraitons.\n         * if prune === '', it will be activated when the nodes number > 100\n         * note that it will reduce the quality of the layout\n         * @type  {boolean}\n         */\n        _this.prune = false;\n        _this.updateCfg(options);\n        return _this;\n    }\n    ForceAtlas2Layout.prototype.getDefaultCfg = function () {\n        return {};\n    };\n    // execute the layout\n    ForceAtlas2Layout.prototype.execute = function () {\n        var self = this;\n        var nodes = self.nodes, maxIteration = self.maxIteration, onLayoutEnd = self.onLayoutEnd, prune = self.prune;\n        if (!self.width && typeof window !== \"undefined\") {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== \"undefined\") {\n            self.height = window.innerHeight;\n        }\n        // the whidth of each nodes\n        var sizes = [];\n        var nodeNum = nodes.length;\n        for (var i = 0; i < nodeNum; i += 1) {\n            var node = nodes[i];\n            var nodeWidth = 10;\n            var nodeHeight = 10;\n            if (util_1.isNumber(node.size)) {\n                nodeWidth = node.size;\n                nodeHeight = node.size;\n            }\n            if (util_1.isArray(node.size)) {\n                if (!isNaN(node.size[0]))\n                    nodeWidth = node.size[0];\n                if (!isNaN(node.size[1]))\n                    nodeHeight = node.size[1];\n            }\n            if (self.getWidth && !isNaN(self.getWidth(node)))\n                nodeHeight = self.getWidth(node);\n            if (self.getHeight && !isNaN(self.getHeight(node)))\n                nodeWidth = self.getHeight(node);\n            var maxSize = Math.max(nodeWidth, nodeHeight);\n            sizes.push(maxSize);\n        }\n        if (!self.barnesHut && nodeNum > 250)\n            self.barnesHut = true;\n        if (!self.prune && nodeNum > 100)\n            self.prune = true;\n        if (this.maxIteration === 0 && !self.prune) {\n            maxIteration = 250;\n            if (nodeNum <= 200 && nodeNum > 100)\n                maxIteration = 1000;\n            else if (nodeNum > 200)\n                maxIteration = 1200;\n            this.maxIteration = maxIteration;\n        }\n        else if (this.maxIteration === 0 && prune) {\n            maxIteration = 100;\n            if (nodeNum <= 200 && nodeNum > 100)\n                maxIteration = 500;\n            else if (nodeNum > 200)\n                maxIteration = 950;\n            this.maxIteration = maxIteration;\n        }\n        if (!self.kr) {\n            self.kr = 50;\n            if (nodeNum > 100 && nodeNum <= 500)\n                self.kr = 20;\n            else if (nodeNum > 500)\n                self.kr = 1;\n        }\n        if (!self.kg) {\n            self.kg = 20;\n            if (nodeNum > 100 && nodeNum <= 500)\n                self.kg = 10;\n            else if (nodeNum > 500)\n                self.kg = 1;\n        }\n        this.nodes = self.updateNodesByForces(sizes);\n        onLayoutEnd();\n    };\n    ForceAtlas2Layout.prototype.updateNodesByForces = function (sizes) {\n        var self = this;\n        var nodes = self.nodes, edges = self.edges, maxIteration = self.maxIteration;\n        var nonLoopEdges = edges.filter(function (edge) {\n            return edge.source !== edge.target;\n        });\n        var size = nodes.length;\n        var esize = nonLoopEdges.length;\n        var degrees = [];\n        var idMap = {};\n        var edgeEndsIdMap = {};\n        var Es = [];\n        for (var i = 0; i < size; i += 1) {\n            idMap[nodes[i].id] = i;\n            degrees[i] = 0;\n            if (nodes[i].x === undefined || isNaN(nodes[i].x)) {\n                nodes[i].x = Math.random() * 1000;\n            }\n            if (nodes[i].y === undefined || isNaN(nodes[i].y)) {\n                nodes[i].y = Math.random() * 1000;\n            }\n            Es.push({ x: nodes[i].x, y: nodes[i].y });\n        }\n        for (var i = 0; i < esize; i += 1) {\n            var node1 = void 0;\n            var node2 = void 0;\n            var sIdx = 0, tIdx = 0;\n            for (var j = 0; j < size; j += 1) {\n                if (nodes[j].id === nonLoopEdges[i].source) {\n                    node1 = nodes[j];\n                    sIdx = j;\n                }\n                else if (nodes[j].id === nonLoopEdges[i].target) {\n                    node2 = nodes[j];\n                    tIdx = j;\n                }\n                edgeEndsIdMap[i] = { sourceIdx: sIdx, targetIdx: tIdx };\n            }\n            if (node1)\n                degrees[idMap[node1.id]] += 1;\n            if (node2)\n                degrees[idMap[node2.id]] += 1;\n        }\n        var iteration = maxIteration;\n        nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n        // if prune, place the leaves around their parents, and then re-layout for several iterations.\n        if (self.prune) {\n            for (var j = 0; j < esize; j += 1) {\n                if (degrees[edgeEndsIdMap[j].sourceIdx] <= 1) {\n                    nodes[edgeEndsIdMap[j].sourceIdx].x = nodes[edgeEndsIdMap[j].targetIdx].x;\n                    nodes[edgeEndsIdMap[j].sourceIdx].y = nodes[edgeEndsIdMap[j].targetIdx].y;\n                }\n                else if (degrees[edgeEndsIdMap[j].targetIdx] <= 1) {\n                    nodes[edgeEndsIdMap[j].targetIdx].x = nodes[edgeEndsIdMap[j].sourceIdx].x;\n                    nodes[edgeEndsIdMap[j].targetIdx].y = nodes[edgeEndsIdMap[j].sourceIdx].y;\n                }\n            }\n            self.prune = false;\n            self.barnesHut = false;\n            iteration = 100;\n            nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees, sizes);\n        }\n        return nodes;\n    };\n    ForceAtlas2Layout.prototype.iterate = function (iteration, idMap, edgeEndsIdMap, esize, degrees, sizes) {\n        var self = this;\n        var nodes = self.nodes, kr = self.kr, preventOverlap = self.preventOverlap, barnesHut = self.barnesHut;\n        var nodeNum = nodes.length;\n        var sg = 0;\n        var krPrime = 100;\n        var iter = iteration;\n        var prevoIter = 50;\n        var forces = [];\n        var preForces = [];\n        var bodies = [];\n        for (var i = 0; i < nodeNum; i += 1) {\n            forces[2 * i] = 0;\n            forces[2 * i + 1] = 0;\n            if (barnesHut) {\n                var params = {\n                    id: i,\n                    rx: nodes[i].x,\n                    ry: nodes[i].y,\n                    mass: 1,\n                    g: kr,\n                    degree: degrees[i]\n                };\n                bodies[i] = new body_1.default(params);\n            }\n        }\n        while (iter > 0) {\n            for (var i = 0; i < nodeNum; i += 1) {\n                preForces[2 * i] = forces[2 * i];\n                preForces[2 * i + 1] = forces[2 * i + 1];\n                forces[2 * i] = 0;\n                forces[2 * i + 1] = 0;\n            }\n            // attractive forces, existing on every actual edge\n            forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces);\n            // repulsive forces and Gravity, existing on every node pair\n            // if preventOverlap, using the no-optimized method in the last prevoIter instead.\n            if (barnesHut && ((preventOverlap && iter > prevoIter) || !preventOverlap)) {\n                forces = this.getOptRepGraForces(forces, bodies, degrees);\n            }\n            else {\n                forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees);\n            }\n            // update the positions\n            var res = this.updatePos(forces, preForces, sg, degrees);\n            nodes = res.nodes;\n            sg = res.sg;\n            iter--;\n            if (self.tick)\n                self.tick();\n        }\n        ;\n        return nodes;\n    };\n    ForceAtlas2Layout.prototype.getAttrForces = function (iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees, sizes, forces) {\n        var self = this;\n        var nodes = self.nodes, preventOverlap = self.preventOverlap, dissuadeHubs = self.dissuadeHubs, mode = self.mode, prune = self.prune;\n        for (var i = 0; i < esize; i += 1) {\n            var sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];\n            var sourceIdx = edgeEndsIdMap[i].sourceIdx;\n            var targetNode = nodes[edgeEndsIdMap[i].targetIdx];\n            var targetIdx = edgeEndsIdMap[i].targetIdx;\n            if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1))\n                continue;\n            var dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];\n            var eucliDis = Math.hypot(dir[0], dir[1]);\n            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            if (preventOverlap && iter < prevoIter)\n                eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];\n            var Fa1 = eucliDis;\n            var Fa2 = Fa1;\n            if (mode === 'linlog') {\n                Fa1 = Math.log(1 + eucliDis);\n                Fa2 = Fa1;\n            }\n            if (dissuadeHubs) {\n                Fa1 = eucliDis / degrees[sourceIdx];\n                Fa2 = eucliDis / degrees[targetIdx];\n            }\n            if (preventOverlap && iter < prevoIter && eucliDis <= 0) {\n                Fa1 = 0;\n                Fa2 = 0;\n            }\n            else if (preventOverlap && iter < prevoIter && eucliDis > 0) {\n                Fa1 = eucliDis;\n                Fa2 = eucliDis;\n            }\n            forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];\n            forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];\n            forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];\n            forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];\n        }\n        return forces;\n    };\n    ForceAtlas2Layout.prototype.getRepGraForces = function (iter, prevoIter, forces, krPrime, sizes, degrees) {\n        var self = this;\n        var nodes = self.nodes, preventOverlap = self.preventOverlap, kr = self.kr, kg = self.kg, center = self.center, prune = self.prune;\n        var nodeNum = nodes.length;\n        for (var i = 0; i < nodeNum; i += 1) {\n            for (var j = i + 1; j < nodeNum; j += 1) {\n                if (prune && (degrees[i] <= 1 || degrees[j] <= 1))\n                    continue;\n                var dir_1 = [nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y];\n                var eucliDis_1 = Math.hypot(dir_1[0], dir_1[1]);\n                eucliDis_1 = eucliDis_1 < 0.0001 ? 0.0001 : eucliDis_1;\n                dir_1[0] = dir_1[0] / eucliDis_1;\n                dir_1[1] = dir_1[1] / eucliDis_1;\n                if (preventOverlap && iter < prevoIter)\n                    eucliDis_1 = eucliDis_1 - sizes[i] - sizes[j];\n                var Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis_1;\n                if (preventOverlap && iter < prevoIter && eucliDis_1 < 0) {\n                    Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);\n                }\n                else if (preventOverlap && iter < prevoIter && eucliDis_1 === 0) {\n                    Fr = 0;\n                }\n                else if (preventOverlap && iter < prevoIter && eucliDis_1 > 0) {\n                    Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / eucliDis_1;\n                }\n                forces[2 * i] -= Fr * dir_1[0];\n                forces[2 * j] += Fr * dir_1[0];\n                forces[2 * i + 1] -= Fr * dir_1[1];\n                forces[2 * j + 1] += Fr * dir_1[1];\n            }\n            // gravity\n            var dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n            var eucliDis = Math.hypot(dir[0], dir[1]);\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            var Fg = kg * (degrees[i] + 1);\n            forces[2 * i] -= Fg * dir[0];\n            forces[2 * i + 1] -= Fg * dir[1];\n        }\n        return forces;\n    };\n    ForceAtlas2Layout.prototype.getOptRepGraForces = function (forces, bodies, degrees) {\n        var self = this;\n        var nodes = self.nodes, kg = self.kg, center = self.center, prune = self.prune;\n        var nodeNum = nodes.length;\n        var minx = 9e10, maxx = -9e10, miny = 9e10, maxy = -9e10;\n        for (var i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            bodies[i].setPos(nodes[i].x, nodes[i].y);\n            if (nodes[i].x >= maxx)\n                maxx = nodes[i].x;\n            if (nodes[i].x <= minx)\n                minx = nodes[i].x;\n            if (nodes[i].y >= maxy)\n                maxy = nodes[i].y;\n            if (nodes[i].y <= miny)\n                miny = nodes[i].y;\n        }\n        var width = Math.max(maxx - minx, maxy - miny);\n        var quadParams = {\n            xmid: (maxx + minx) / 2,\n            ymid: (maxy + miny) / 2,\n            length: width,\n            massCenter: center,\n            mass: nodeNum\n        };\n        var quad = new quad_1.default(quadParams);\n        var quadTree = new quadTree_1.default(quad);\n        // build the tree, insert the nodes(quads) into the tree\n        for (var i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            if (bodies[i].in(quad))\n                quadTree.insert(bodies[i]);\n        }\n        // update the repulsive forces and the gravity.\n        for (var i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            bodies[i].resetForce();\n            quadTree.updateForce(bodies[i]);\n            forces[2 * i] -= bodies[i].fx;\n            forces[2 * i + 1] -= bodies[i].fy;\n            // gravity\n            var dir = [nodes[i].x - center[0], nodes[i].y - center[1]];\n            var eucliDis = Math.hypot(dir[0], dir[1]);\n            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n            dir[0] = dir[0] / eucliDis;\n            dir[1] = dir[1] / eucliDis;\n            var Fg = kg * (degrees[i] + 1);\n            forces[2 * i] -= Fg * dir[0];\n            forces[2 * i + 1] -= Fg * dir[1];\n        }\n        return forces;\n    };\n    ForceAtlas2Layout.prototype.updatePos = function (forces, preForces, sg, degrees) {\n        var self = this;\n        var nodes = self.nodes, ks = self.ks, tao = self.tao, prune = self.prune, ksmax = self.ksmax;\n        var nodeNum = nodes.length;\n        var swgns = [];\n        var trans = [];\n        // swg(G) and tra(G)\n        var swgG = 0;\n        var traG = 0;\n        for (var i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            var minus = [forces[2 * i] - preForces[2 * i],\n                forces[2 * i + 1] - preForces[2 * i + 1]\n            ];\n            var minusNorm = Math.hypot(minus[0], minus[1]);\n            var add = [forces[2 * i] + preForces[2 * i],\n                forces[2 * i + 1] + preForces[2 * i + 1]\n            ];\n            var addNorm = Math.hypot(add[0], add[1]);\n            swgns[i] = minusNorm;\n            trans[i] = addNorm / 2;\n            swgG += (degrees[i] + 1) * swgns[i];\n            traG += (degrees[i] + 1) * trans[i];\n        }\n        var preSG = sg;\n        sg = tao * traG / swgG;\n        if (preSG !== 0) {\n            sg = sg > (1.5 * preSG) ? (1.5 * preSG) : sg;\n        }\n        // update the node positions\n        for (var i = 0; i < nodeNum; i += 1) {\n            if (prune && (degrees[i] <= 1))\n                continue;\n            var sn = ks * sg / (1 + sg * Math.sqrt(swgns[i]));\n            var absForce = Math.hypot(forces[2 * i], forces[2 * i + 1]);\n            absForce = absForce < 0.0001 ? 0.0001 : absForce;\n            var max = ksmax / absForce;\n            sn = sn > max ? max : sn;\n            var dnx = sn * forces[2 * i];\n            var dny = sn * forces[2 * i + 1];\n            nodes[i].x += dnx;\n            nodes[i].y += dny;\n        }\n        return { nodes: nodes, sg: sg };\n    };\n    return ForceAtlas2Layout;\n}(base_1.Base));\nexports.ForceAtlas2Layout = ForceAtlas2Layout;\n//# sourceMappingURL=index.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// represents a body(a point mass) and its position\nvar Body = /** @class */ (function () {\n    function Body(params) {\n        /**\n         * the id of this body, the same with the node id\n         * @type  {number}\n         */\n        this.id = params.id || 0;\n        /**\n         * the position of this body\n         * @type  {number}\n         */\n        this.rx = params.rx;\n        /**\n         * the position of this body\n         * @type  {number}\n         */\n        this.ry = params.ry;\n        /**\n         * the force acting on this body\n         * @type  {number}\n         */\n        this.fx = 0;\n        /**\n         * the force acting on this body\n         * @type  {number}\n         */\n        this.fy = 0;\n        /**\n         * the mass of this body, =1 for a node\n         * @type  {number}\n         */\n        this.mass = params.mass;\n        /**\n         * the degree of the node represented by this body\n         * @type  {number}\n         */\n        this.degree = params.degree;\n        /**\n         * the parameter for repulsive force, = kr\n         * @type  {number}\n         */\n        this.g = params.g || 0;\n    }\n    // returns the euclidean distance\n    Body.prototype.distanceTo = function (bo) {\n        var dx = this.rx - bo.rx;\n        var dy = this.ry - bo.ry;\n        return Math.hypot(dx, dy);\n    };\n    Body.prototype.setPos = function (x, y) {\n        this.rx = x;\n        this.ry = y;\n    };\n    // resets the forces\n    Body.prototype.resetForce = function () {\n        this.fx = 0;\n        this.fy = 0;\n    };\n    Body.prototype.addForce = function (b) {\n        var dx = b.rx - this.rx;\n        var dy = b.ry - this.ry;\n        var dist = Math.hypot(dx, dy);\n        dist = dist < 0.0001 ? 0.0001 : dist;\n        // the repulsive defined by force atlas 2\n        var F = (this.g * (this.degree + 1) * (b.degree + 1)) / dist;\n        this.fx += F * dx / dist;\n        this.fy += F * dy / dist;\n    };\n    // if quad contains this body\n    Body.prototype.in = function (quad) {\n        return quad.contains(this.rx, this.ry);\n    };\n    // returns a new body\n    Body.prototype.add = function (bo) {\n        var nenwMass = this.mass + bo.mass;\n        var x = (this.rx * this.mass + bo.rx * bo.mass) / nenwMass;\n        var y = (this.ry * this.mass + bo.ry * bo.mass) / nenwMass;\n        var dg = this.degree + bo.degree;\n        var params = {\n            rx: x,\n            ry: y,\n            mass: nenwMass,\n            degree: dg\n        };\n        return new Body(params);\n    };\n    return Body;\n}());\nexports.default = Body;\n//# sourceMappingURL=body.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Quad = /** @class */ (function () {\n    function Quad(params) {\n        /**\n         * the center position of this quad\n         * @type  {number}\n         */\n        this.xmid = params.xmid;\n        /**\n         * the center position of this quad\n         * @type  {number}\n         */\n        this.ymid = params.ymid;\n        /**\n         * the length of this quad\n         * @type  {number}\n         */\n        this.length = params.length;\n        /**\n         * the mass center of this quad\n         * @type  {number}\n         */\n        this.massCenter = params.massCenter || [0, 0];\n        /**\n         * the mass of this quad\n         * @type  {number}\n         */\n        this.mass = params.mass || 1;\n    }\n    Quad.prototype.getLength = function () {\n        return this.length;\n    };\n    Quad.prototype.contains = function (x, y) {\n        var halfLen = this.length / 2;\n        return (x <= this.xmid + halfLen &&\n            x >= this.xmid - halfLen &&\n            y <= this.ymid + halfLen &&\n            y >= this.ymid - halfLen);\n    };\n    // northwest quadrant\n    Quad.prototype.NW = function () {\n        var x = this.xmid - this.length / 4;\n        var y = this.ymid + this.length / 4;\n        var len = this.length / 2;\n        var params = {\n            xmid: x,\n            ymid: y,\n            length: len\n        };\n        var NW = new Quad(params);\n        return NW;\n    };\n    // northeast\n    Quad.prototype.NE = function () {\n        var x = this.xmid + this.length / 4;\n        var y = this.ymid + this.length / 4;\n        var len = this.length / 2;\n        var params = {\n            xmid: x,\n            ymid: y,\n            length: len\n        };\n        var NE = new Quad(params);\n        return NE;\n    };\n    // southwest\n    Quad.prototype.SW = function () {\n        var x = this.xmid - this.length / 4;\n        var y = this.ymid - this.length / 4;\n        var len = this.length / 2;\n        var params = {\n            xmid: x,\n            ymid: y,\n            length: len\n        };\n        var SW = new Quad(params);\n        return SW;\n    };\n    // southeast\n    Quad.prototype.SE = function () {\n        var x = this.xmid + this.length / 4;\n        var y = this.ymid - this.length / 4;\n        var len = this.length / 2;\n        var params = {\n            xmid: x,\n            ymid: y,\n            length: len\n        };\n        var SE = new Quad(params);\n        return SE;\n    };\n    return Quad;\n}());\nexports.default = Quad;\n//# sourceMappingURL=quad.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @fileOverview quadTree\n * @author shiwu.wyy@antfin.com\n */\nvar QuadTree = /** @class */ (function () {\n    // each quadtree represents a quadrant and an aggregate body\n    // that represents all bodies inside the quadrant\n    function QuadTree(param) {\n        /**\n         * (aggregated) body in this quad\n         * @type  {object}\n         */\n        this.body = null;\n        /**\n         * tree representing the northwest quadrant\n         * @type  {object}\n         */\n        this.quad = null;\n        this.NW = null;\n        this.NE = null;\n        this.SW = null;\n        this.SE = null;\n        /**\n         * threshold\n         * @type  {number}\n         */\n        this.theta = 0.5;\n        if (param != null)\n            this.quad = param;\n    }\n    // insert a body(node) into the tree\n    QuadTree.prototype.insert = function (bo) {\n        // if this node does not contain a body, put the new body bo here\n        if (this.body == null) {\n            this.body = bo;\n            return;\n        }\n        // internal node\n        if (!this._isExternal()) {\n            // update mass info\n            this.body = this.body.add(bo);\n            // insert body into quadrant\n            this._putBody(bo);\n        }\n        else { // external node\n            // divide this region into four children\n            if (this.quad) {\n                this.NW = new QuadTree(this.quad.NW());\n                this.NE = new QuadTree(this.quad.NE());\n                this.SW = new QuadTree(this.quad.SW());\n                this.SE = new QuadTree(this.quad.SE());\n            }\n            // insert this body and bo\n            this._putBody(this.body);\n            this._putBody(bo);\n            // update the mass info\n            this.body = this.body.add(bo);\n        }\n    };\n    // inserts bo into a quad\n    QuadTree.prototype._putBody = function (bo) {\n        if (!this.quad)\n            return;\n        if (bo.in(this.quad.NW()) && this.NW)\n            this.NW.insert(bo);\n        else if (bo.in(this.quad.NE()) && this.NE)\n            this.NE.insert(bo);\n        else if (bo.in(this.quad.SW()) && this.SW)\n            this.SW.insert(bo);\n        else if (bo.in(this.quad.SE()) && this.SE)\n            this.SE.insert(bo);\n    };\n    QuadTree.prototype._isExternal = function () {\n        // four children are null\n        return (this.NW == null && this.NE == null && this.SW == null && this.SE == null);\n    };\n    // update the forces\n    QuadTree.prototype.updateForce = function (bo) {\n        if (this.body == null || bo === this.body) {\n            return;\n        }\n        // if the current node is external\n        if (this._isExternal())\n            bo.addForce(this.body);\n        // internal nodes\n        else {\n            var s = this.quad ? this.quad.getLength() : 0;\n            var d = this.body.distanceTo(bo);\n            // b is far enough\n            if ((s / d) < this.theta)\n                bo.addForce(this.body);\n            else {\n                this.NW && this.NW.updateForce(bo);\n                this.NE && this.NE.updateForce(bo);\n                this.SW && this.SW.updateForce(bo);\n                this.SE && this.SE.updateForce(bo);\n            }\n        }\n    };\n    return QuadTree;\n}());\nexports.default = QuadTree;\n//# sourceMappingURL=quadTree.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Layouts = exports.Layout = void 0;\nvar registy_1 = require(\"../registy\");\nvar Layout = /** @class */ (function () {\n    function Layout(options) {\n        var layoutClass = registy_1.getLayoutByName(options.type);\n        this.layoutInstance = new layoutClass(options);\n    }\n    Layout.prototype.layout = function (data) {\n        return this.layoutInstance.layout(data);\n    };\n    Layout.prototype.updateCfg = function (cfg) {\n        this.layoutInstance.updateCfg(cfg);\n    };\n    Layout.prototype.init = function (data) {\n        this.layoutInstance.init(data);\n    };\n    Layout.prototype.execute = function () {\n        this.layoutInstance.execute();\n    };\n    Layout.prototype.getDefaultCfg = function () {\n        return this.layoutInstance.getDefaultCfg();\n    };\n    Layout.prototype.destroy = function () {\n        return this.layoutInstance.destroy();\n    };\n    return Layout;\n}());\nexports.Layout = Layout;\n// FIXME\n// FOR G6\nexports.Layouts = new Proxy({}, {\n    // tslint:disable-line\n    get: function (target, propKey) {\n        return registy_1.getLayoutByName(propKey);\n    },\n    set: function (target, propKey, value) {\n        registy_1.registerLayout(propKey, value);\n        return true;\n    }\n});\n//# sourceMappingURL=layout.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map"]}