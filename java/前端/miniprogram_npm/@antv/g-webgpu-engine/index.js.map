{"version":3,"sources":["index.js","webgl/index.js","webgl/ReglAttribute.js","webgl/ReglBuffer.js","webgl/constants.js","webgl/ReglComputeModel.js","utils/is-typedarray.js","webgl/ReglElements.js","webgl/ReglFramebuffer.js","webgl/ReglModel.js","utils/uniform.js","utils/is-object.js","webgl/ReglTexture2D.js","webgpu/index.js","webgpu/glslang.js","utils/dom.js","webgpu/WebGPUAttribute.js","webgpu/WebGPUBuffer.js","webgpu/WebGPUComputeModel.js","utils/is-number.js","webgpu/WebGPUElements.js","webgpu/WebGPUFramebuffer.js","webgpu/WebGPUModel.js","webgpu/constants.js","webgpu/WebGPUTexture2D.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,ACHA,AHSA;ADIA,AENA,ACHA,ACHA,AHSA;ADIA,AENA,ACHA,ACHA,AHSA;ADIA,AENA,ACHA,AENA,ADGA,AHSA;ADIA,AENA,ACHA,AENA,ADGA,AHSA;ADIA,AENA,ACHA,AENA,ADGA,AHSA;ADIA,AMlBA,AJYA,ACHA,AENA,ADGA,AHSA;ADIA,AMlBA,AJYA,ACHA,AENA,ADGA,AHSA;ADIA,AMlBA,AJYA,ACHA,AENA,ADGA,AHSA;ADIA,AMlBA,AJYA,ACHA,AENA,AENA,AHSA,AHSA;AKdA,AJYA,ACHA,AENA,AENA,AHSA,AHSA;AKdA,AJYA,ACHA,AENA,AENA,AHSA,AHSA;AKdA,AJYA,ACHA,AENA,AENA,ACHA,AJYA,AHSA;AKdA,AJYA,ACHA,AENA,AENA,ACHA,AJYA,AHSA;AKdA,AJYA,ACHA,AENA,AENA,ACHA,AJYA,AHSA;AKdA,AJYA,ACHA,AENA,AENA,ACHA,ACHA,ALeA,AHSA;AKdA,AJYA,ACHA,AENA,AENA,ACHA,ACHA,ALeA,AHSA;AKdA,AJYA,ACHA,AENA,AENA,ACHA,ACHA,ALeA,AHSA;AKdA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,ALeA,AHSA;AKdA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,ALeA,AHSA;AKdA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,ALeA,AHSA;AU7BA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,ALeA,AHSA;AU7BA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,ALeA,AHSA;AU7BA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,ALeA,AHSA;AU7BA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA;AU7BA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA;AU7BA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA;AU7BA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,AYpCA;AFOA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,AYpCA;AFOA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,AYpCA;AFOA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,AavCA,ADGA;AFOA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,AavCA,ADGA;AFOA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,AavCA,ADGA;AELA,AJYA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,AavCA,ADGA;AELA,AJYA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,AavCA,ADGA;AELA,AJYA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,AavCA,ADGA;AELA,AJYA,ALeA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,Ae7CA,AFMA,ADGA;AELA,AT2BA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,Ae7CA,AFMA,ADGA;AELA,AT2BA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,Ae7CA,AFMA,ADGA;AELA,AT2BA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,Ae7CA,ACHA,AHSA,ADGA;AELA,AT2BA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,Ae7CA,ACHA,AHSA,ADGA;AELA,AT2BA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,Ae7CA,ACHA,AHSA,ADGA;AELA,AT2BA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,Ae7CA,ACHA,ACHA,AJYA,ADGA;AELA,AT2BA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,Ae7CA,ACHA,ACHA,AJYA,ADGA;AELA,AT2BA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,ARwBA,AHSA,Ae7CA,ACHA,ACHA,AJYA,ADGA;AELA,AIZA,AbuCA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AJYA,ADGA;AELA,AIZA,AbuCA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AJYA,ADGA;AELA,AIZA,AbuCA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AJYA,ADGA;AELA,AIZA,AbuCA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ANkBA,ADGA;AELA,AIZA,AbuCA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ANkBA,ADGA;AELA,AIZA,AbuCA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ANkBA,ADGA;AELA,AIZA,AbuCA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,APqBA,ADGA;AELA,AIZA,AbuCA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,APqBA,ADGA;AELA,AIZA,AbuCA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,APqBA,ADGA;AELA,AIZA,AbuCA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,ARwBA,ADGA;AELA,AIZA,AbuCA,AIZA,ARwBA,ACHA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,ARwBA,ADGA;AELA,AT2BA,AIZA,APqBA,AENA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,ARwBA,ADGA;AELA,AT2BA,AIZA,ALeA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AENA,ACHA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,AIZA,ALeA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,ADGA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,ADGA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,ADGA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,ADGA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,ADGA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,ADGA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,ADGA,AGTA,ACHA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AT2BA,ADGA;AELA,AT2BA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;AELA,AT2BA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;AELA,AT2BA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,Ae7CA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AENA,ACHA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;APsBA,ADGA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AgBhDA,ACHA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AiBnDA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AiBnDA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AiBnDA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AiBnDA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AiBnDA,AGTA,ACHA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,AGTA,AXiCA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,ADGA,AV8BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AENA,AXiCA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AIZA,ARwBA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AJYA,AiBnDA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;ARyBA,AavCA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AKdA,AIZA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AS1BA,AT2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"WebGLEngine\", {\n  enumerable: true,\n  get: function get() {\n    return _webgl.WebGLEngine;\n  }\n});\nObject.defineProperty(exports, \"WebGPUEngine\", {\n  enumerable: true,\n  get: function get() {\n    return _webgpu.WebGPUEngine;\n  }\n});\n\nvar _webgl = require(\"./webgl\");\n\nvar _webgpu = require(\"./webgpu\");\n//# sourceMappingURL=index.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebGLEngine = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar _inversify = require(\"inversify\");\n\nvar _regl = _interopRequireDefault(require(\"regl\"));\n\nvar _ReglAttribute = _interopRequireDefault(require(\"./ReglAttribute\"));\n\nvar _ReglBuffer = _interopRequireDefault(require(\"./ReglBuffer\"));\n\nvar _ReglComputeModel = _interopRequireDefault(require(\"./ReglComputeModel\"));\n\nvar _ReglElements = _interopRequireDefault(require(\"./ReglElements\"));\n\nvar _ReglFramebuffer = _interopRequireDefault(require(\"./ReglFramebuffer\"));\n\nvar _ReglModel = _interopRequireDefault(require(\"./ReglModel\"));\n\nvar _ReglTexture2D = _interopRequireDefault(require(\"./ReglTexture2D\"));\n\nvar _dec, _class, _temp;\n\n/**\n * regl renderer\n */\nvar WebGLEngine = (_dec = (0, _inversify.injectable)(), _dec(_class = (_temp = /*#__PURE__*/function () {\n  function WebGLEngine() {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, WebGLEngine);\n    this.supportWebGPU = false;\n    this.useWGSL = false;\n    this.$canvas = void 0;\n    this.gl = void 0;\n    this.inited = void 0;\n\n    this.createModel = /*#__PURE__*/function () {\n      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(options) {\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!options.uniforms) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                _context2.next = 3;\n                return Promise.all(Object.keys(options.uniforms).map( /*#__PURE__*/function () {\n                  var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(name) {\n                    var texture;\n                    return _regenerator.default.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            if (!(options.uniforms[name] && options.uniforms[name].load !== undefined)) {\n                              _context.next = 5;\n                              break;\n                            }\n\n                            _context.next = 3;\n                            return options.uniforms[name].load();\n\n                          case 3:\n                            texture = _context.sent;\n                            // @ts-ignore\n                            options.uniforms[name] = texture;\n\n                          case 5:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x2) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }()));\n\n              case 3:\n                return _context2.abrupt(\"return\", new _ReglModel.default(_this.gl, options));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.createAttribute = function (options) {\n      return new _ReglAttribute.default(_this.gl, options);\n    };\n\n    this.createBuffer = function (options) {\n      return new _ReglBuffer.default(_this.gl, options);\n    };\n\n    this.createElements = function (options) {\n      return new _ReglElements.default(_this.gl, options);\n    };\n\n    this.createTexture2D = function (options) {\n      return new _ReglTexture2D.default(_this.gl, options);\n    };\n\n    this.createFramebuffer = function (options) {\n      return new _ReglFramebuffer.default(_this.gl, options);\n    };\n\n    this.useFramebuffer = function (framebuffer, drawCommands) {\n      _this.gl({\n        framebuffer: framebuffer ? framebuffer.get() : null\n      })(drawCommands);\n    };\n\n    this.createComputeModel = /*#__PURE__*/function () {\n      var _ref3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(context) {\n        return _regenerator.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", new _ReglComputeModel.default(_this.gl, context));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function (_x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    this.clear = function (options) {\n      // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clear-the-draw-buffer\n      var color = options.color,\n          depth = options.depth,\n          stencil = options.stencil,\n          _options$framebuffer = options.framebuffer,\n          framebuffer = _options$framebuffer === void 0 ? null : _options$framebuffer;\n      var reglClearOptions = {\n        color: color,\n        depth: depth,\n        stencil: stencil\n      };\n      reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();\n\n      _this.gl.clear(reglClearOptions);\n    };\n\n    this.setScissor = function (scissor) {\n      if (_this.gl && _this.gl._gl) {\n        // https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/scissor\n        if (scissor.enable && scissor.box) {\n          // console.log(scissor.box);\n          _this.gl._gl.enable(_gWebgpuCore.gl.SCISSOR_TEST);\n\n          _this.gl._gl.scissor(scissor.box.x, scissor.box.y, scissor.box.width, scissor.box.height);\n        } else {\n          _this.gl._gl.disable(_gWebgpuCore.gl.SCISSOR_TEST);\n        }\n\n        _this.gl._refresh();\n      }\n    };\n\n    this.viewport = function (_ref4) {\n      var x = _ref4.x,\n          y = _ref4.y,\n          width = _ref4.width,\n          height = _ref4.height;\n\n      if (_this.gl && _this.gl._gl) {\n        // use WebGL context directly\n        // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#unsafe-escape-hatch\n        _this.gl._gl.viewport(x, y, width, height);\n\n        _this.gl._refresh();\n      }\n    };\n\n    this.readPixels = function (options) {\n      var framebuffer = options.framebuffer,\n          x = options.x,\n          y = options.y,\n          width = options.width,\n          height = options.height;\n      var readPixelsOptions = {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      };\n\n      if (framebuffer) {\n        readPixelsOptions.framebuffer = framebuffer.get();\n      }\n\n      return _this.gl.read(readPixelsOptions);\n    };\n\n    this.getCanvas = function () {\n      return _this.$canvas;\n    };\n\n    this.getGLContext = function () {\n      return _this.gl._gl;\n    };\n\n    this.destroy = function () {\n      if (_this.gl) {\n        // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clean-up\n        _this.gl.destroy();\n\n        _this.inited = false;\n      }\n    };\n  }\n\n  (0, _createClass2.default)(WebGLEngine, [{\n    key: \"init\",\n    value: function () {\n      var _init = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(cfg) {\n        return _regenerator.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!this.inited) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                this.$canvas = cfg.canvas; // tslint:disable-next-line:typedef\n\n                _context4.next = 5;\n                return new Promise(function (resolve, reject) {\n                  (0, _regl.default)({\n                    canvas: cfg.canvas,\n                    attributes: {\n                      alpha: true,\n                      // use TAA instead of MSAA\n                      // @see https://www.khronos.org/registry/webgl/specs/1.0/#5.2.1\n                      antialias: cfg.antialias,\n                      premultipliedAlpha: true // preserveDrawingBuffer: false,\n\n                    },\n                    pixelRatio: 1,\n                    // TODO: use extensions\n                    extensions: ['OES_element_index_uint', 'OES_texture_float', 'OES_standard_derivatives', // wireframe\n                    'angle_instanced_arrays' // VSM shadow map\n                    ],\n                    optionalExtensions: ['EXT_texture_filter_anisotropic', 'EXT_blend_minmax', 'WEBGL_depth_texture'],\n                    profile: true,\n                    onDone: function onDone(err, r) {\n                      if (err || !r) {\n                        reject(err);\n                      } // @ts-ignore\n\n\n                      resolve(r);\n                    }\n                  });\n                });\n\n              case 5:\n                this.gl = _context4.sent;\n                this.inited = true;\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function init(_x4) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"isFloatSupported\",\n    value: function isFloatSupported() {\n      // @see https://github.com/antvis/GWebGPUEngine/issues/26\n      // @ts-ignore\n      return this.gl.limits.readFloat;\n    }\n  }, {\n    key: \"beginFrame\",\n    value: function beginFrame() {//\n    }\n  }, {\n    key: \"endFrame\",\n    value: function endFrame() {//\n    }\n  }]);\n  return WebGLEngine;\n}(), _temp)) || _class);\nexports.WebGLEngine = WebGLEngine;\n//# sourceMappingURL=index.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\n/**\n * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#attributes\n */\nvar ReglAttribute = /*#__PURE__*/function () {\n  function ReglAttribute(gl, options) {\n    (0, _classCallCheck2.default)(this, ReglAttribute);\n    this.attribute = void 0;\n    this.buffer = void 0;\n    var buffer = options.buffer,\n        offset = options.offset,\n        stride = options.stride,\n        normalized = options.normalized,\n        size = options.size,\n        divisor = options.divisor;\n    this.buffer = buffer;\n    this.attribute = {\n      buffer: buffer.get(),\n      offset: offset || 0,\n      stride: stride || 0,\n      normalized: normalized || false,\n      divisor: divisor || 0\n    };\n\n    if (size) {\n      this.attribute.size = size;\n    }\n  }\n\n  (0, _createClass2.default)(ReglAttribute, [{\n    key: \"get\",\n    value: function get() {\n      return this.attribute;\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(options) {\n      this.buffer.subData(options);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.buffer.destroy();\n    }\n  }]);\n  return ReglAttribute;\n}();\n\nexports.default = ReglAttribute;\n//# sourceMappingURL=ReglAttribute.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar _constants = require(\"./constants\");\n\n/**\n * adaptor for regl.Buffer\n * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#buffers\n */\nvar ReglBuffer = /*#__PURE__*/function () {\n  function ReglBuffer(reGl, options) {\n    (0, _classCallCheck2.default)(this, ReglBuffer);\n    this.buffer = void 0;\n    var data = options.data,\n        usage = options.usage,\n        type = options.type; // @ts-ignore\n\n    this.buffer = reGl.buffer({\n      data: data,\n      usage: _constants.usageMap[usage || _gWebgpuCore.gl.STATIC_DRAW],\n      type: _constants.dataTypeMap[type || _gWebgpuCore.gl.UNSIGNED_BYTE] // length: 0,\n\n    });\n  }\n\n  (0, _createClass2.default)(ReglBuffer, [{\n    key: \"get\",\n    value: function get() {\n      return this.buffer;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {// this.buffer.destroy();\n    }\n  }, {\n    key: \"subData\",\n    value: function subData(_ref) {\n      var data = _ref.data,\n          offset = _ref.offset;\n      // @ts-ignore\n      this.buffer.subdata(data, offset);\n    }\n  }]);\n  return ReglBuffer;\n}();\n\nexports.default = ReglBuffer;\n//# sourceMappingURL=ReglBuffer.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cullFaceMap = exports.stencilOpMap = exports.stencilFuncMap = exports.blendFuncMap = exports.blendEquationMap = exports.depthFuncMap = exports.colorSpaceMap = exports.wrapModeMap = exports.filterMap = exports.mipmapMap = exports.formatMap = exports.dataTypeMap = exports.usageMap = exports.primitiveMap = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar _primitiveMap, _usageMap, _dataTypeMap, _formatMap, _mipmapMap, _filterMap, _wrapModeMap, _colorSpaceMap, _depthFuncMap, _blendEquationMap, _blendFuncMap, _stencilFuncMap, _stencilOpMap, _cullFaceMap;\n\n// @see https://github.com/regl-project/regl/blob/gh-pages/lib/constants/primitives.json\nvar primitiveMap = (_primitiveMap = {}, (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.POINTS, 'points'), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.LINES, 'lines'), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.LINE_LOOP, 'line loop'), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.LINE_STRIP, 'line strip'), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.TRIANGLES, 'triangles'), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.TRIANGLE_FAN, 'triangle fan'), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.TRIANGLE_STRIP, 'triangle strip'), _primitiveMap);\nexports.primitiveMap = primitiveMap;\nvar usageMap = (_usageMap = {}, (0, _defineProperty2.default)(_usageMap, _gWebgpuCore.gl.STATIC_DRAW, 'static'), (0, _defineProperty2.default)(_usageMap, _gWebgpuCore.gl.DYNAMIC_DRAW, 'dynamic'), (0, _defineProperty2.default)(_usageMap, _gWebgpuCore.gl.STREAM_DRAW, 'stream'), _usageMap);\nexports.usageMap = usageMap;\nvar dataTypeMap = (_dataTypeMap = {}, (0, _defineProperty2.default)(_dataTypeMap, _gWebgpuCore.gl.BYTE, 'int8'), (0, _defineProperty2.default)(_dataTypeMap, _gWebgpuCore.gl.UNSIGNED_INT, 'int16'), (0, _defineProperty2.default)(_dataTypeMap, _gWebgpuCore.gl.INT, 'int32'), (0, _defineProperty2.default)(_dataTypeMap, _gWebgpuCore.gl.UNSIGNED_BYTE, 'uint8'), (0, _defineProperty2.default)(_dataTypeMap, _gWebgpuCore.gl.UNSIGNED_SHORT, 'uint16'), (0, _defineProperty2.default)(_dataTypeMap, _gWebgpuCore.gl.UNSIGNED_INT, 'uint32'), (0, _defineProperty2.default)(_dataTypeMap, _gWebgpuCore.gl.FLOAT, 'float'), _dataTypeMap);\nexports.dataTypeMap = dataTypeMap;\nvar formatMap = (_formatMap = {}, (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.ALPHA, 'alpha'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.LUMINANCE, 'luminance'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.LUMINANCE_ALPHA, 'luminance alpha'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.RGB, 'rgb'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.RGBA, 'rgba'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.RGBA4, 'rgba4'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.RGB5_A1, 'rgb5 a1'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.RGB565, 'rgb565'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.DEPTH_COMPONENT, 'depth'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.DEPTH_STENCIL, 'depth stencil'), _formatMap);\nexports.formatMap = formatMap;\nvar mipmapMap = (_mipmapMap = {}, (0, _defineProperty2.default)(_mipmapMap, _gWebgpuCore.gl.DONT_CARE, 'dont care'), (0, _defineProperty2.default)(_mipmapMap, _gWebgpuCore.gl.NICEST, 'nice'), (0, _defineProperty2.default)(_mipmapMap, _gWebgpuCore.gl.FASTEST, 'fast'), _mipmapMap);\nexports.mipmapMap = mipmapMap;\nvar filterMap = (_filterMap = {}, (0, _defineProperty2.default)(_filterMap, _gWebgpuCore.gl.NEAREST, 'nearest'), (0, _defineProperty2.default)(_filterMap, _gWebgpuCore.gl.LINEAR, 'linear'), (0, _defineProperty2.default)(_filterMap, _gWebgpuCore.gl.LINEAR_MIPMAP_LINEAR, 'mipmap'), (0, _defineProperty2.default)(_filterMap, _gWebgpuCore.gl.NEAREST_MIPMAP_LINEAR, 'nearest mipmap linear'), (0, _defineProperty2.default)(_filterMap, _gWebgpuCore.gl.LINEAR_MIPMAP_NEAREST, 'linear mipmap nearest'), (0, _defineProperty2.default)(_filterMap, _gWebgpuCore.gl.NEAREST_MIPMAP_NEAREST, 'nearest mipmap nearest'), _filterMap);\nexports.filterMap = filterMap;\nvar wrapModeMap = (_wrapModeMap = {}, (0, _defineProperty2.default)(_wrapModeMap, _gWebgpuCore.gl.REPEAT, 'repeat'), (0, _defineProperty2.default)(_wrapModeMap, _gWebgpuCore.gl.CLAMP_TO_EDGE, 'clamp'), (0, _defineProperty2.default)(_wrapModeMap, _gWebgpuCore.gl.MIRRORED_REPEAT, 'mirror'), _wrapModeMap);\nexports.wrapModeMap = wrapModeMap;\nvar colorSpaceMap = (_colorSpaceMap = {}, (0, _defineProperty2.default)(_colorSpaceMap, _gWebgpuCore.gl.NONE, 'none'), (0, _defineProperty2.default)(_colorSpaceMap, _gWebgpuCore.gl.BROWSER_DEFAULT_WEBGL, 'browser'), _colorSpaceMap);\nexports.colorSpaceMap = colorSpaceMap;\nvar depthFuncMap = (_depthFuncMap = {}, (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.NEVER, 'never'), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.ALWAYS, 'always'), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.LESS, 'less'), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.LEQUAL, 'lequal'), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.GREATER, 'greater'), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.GEQUAL, 'gequal'), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.EQUAL, 'equal'), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.NOTEQUAL, 'notequal'), _depthFuncMap);\nexports.depthFuncMap = depthFuncMap;\nvar blendEquationMap = (_blendEquationMap = {}, (0, _defineProperty2.default)(_blendEquationMap, _gWebgpuCore.gl.FUNC_ADD, 'add'), (0, _defineProperty2.default)(_blendEquationMap, _gWebgpuCore.gl.MIN_EXT, 'min'), (0, _defineProperty2.default)(_blendEquationMap, _gWebgpuCore.gl.MAX_EXT, 'max'), (0, _defineProperty2.default)(_blendEquationMap, _gWebgpuCore.gl.FUNC_SUBTRACT, 'subtract'), (0, _defineProperty2.default)(_blendEquationMap, _gWebgpuCore.gl.FUNC_REVERSE_SUBTRACT, 'reverse subtract'), _blendEquationMap);\nexports.blendEquationMap = blendEquationMap;\nvar blendFuncMap = (_blendFuncMap = {}, (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ZERO, 'zero'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE, 'one'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.SRC_COLOR, 'src color'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE_MINUS_SRC_COLOR, 'one minus src color'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.SRC_ALPHA, 'src alpha'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE_MINUS_SRC_ALPHA, 'one minus src alpha'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.DST_COLOR, 'dst color'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE_MINUS_DST_COLOR, 'one minus dst color'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.DST_ALPHA, 'dst alpha'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE_MINUS_DST_ALPHA, 'one minus dst alpha'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.CONSTANT_COLOR, 'constant color'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE_MINUS_CONSTANT_COLOR, 'one minus constant color'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.CONSTANT_ALPHA, 'constant alpha'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE_MINUS_CONSTANT_ALPHA, 'one minus constant alpha'), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.SRC_ALPHA_SATURATE, 'src alpha saturate'), _blendFuncMap);\nexports.blendFuncMap = blendFuncMap;\nvar stencilFuncMap = (_stencilFuncMap = {}, (0, _defineProperty2.default)(_stencilFuncMap, _gWebgpuCore.gl.NEVER, 'never'), (0, _defineProperty2.default)(_stencilFuncMap, _gWebgpuCore.gl.ALWAYS, 'always'), (0, _defineProperty2.default)(_stencilFuncMap, _gWebgpuCore.gl.LESS, 'less'), (0, _defineProperty2.default)(_stencilFuncMap, _gWebgpuCore.gl.LEQUAL, 'lequal'), (0, _defineProperty2.default)(_stencilFuncMap, _gWebgpuCore.gl.GREATER, 'greater'), (0, _defineProperty2.default)(_stencilFuncMap, _gWebgpuCore.gl.GEQUAL, 'gequal'), (0, _defineProperty2.default)(_stencilFuncMap, _gWebgpuCore.gl.EQUAL, 'equal'), (0, _defineProperty2.default)(_stencilFuncMap, _gWebgpuCore.gl.NOTEQUAL, 'notequal'), _stencilFuncMap);\nexports.stencilFuncMap = stencilFuncMap;\nvar stencilOpMap = (_stencilOpMap = {}, (0, _defineProperty2.default)(_stencilOpMap, _gWebgpuCore.gl.ZERO, 'zero'), (0, _defineProperty2.default)(_stencilOpMap, _gWebgpuCore.gl.KEEP, 'keep'), (0, _defineProperty2.default)(_stencilOpMap, _gWebgpuCore.gl.REPLACE, 'replace'), (0, _defineProperty2.default)(_stencilOpMap, _gWebgpuCore.gl.INVERT, 'invert'), (0, _defineProperty2.default)(_stencilOpMap, _gWebgpuCore.gl.INCR, 'increment'), (0, _defineProperty2.default)(_stencilOpMap, _gWebgpuCore.gl.DECR, 'decrement'), (0, _defineProperty2.default)(_stencilOpMap, _gWebgpuCore.gl.INCR_WRAP, 'increment wrap'), (0, _defineProperty2.default)(_stencilOpMap, _gWebgpuCore.gl.DECR_WRAP, 'decrement wrap'), _stencilOpMap);\nexports.stencilOpMap = stencilOpMap;\nvar cullFaceMap = (_cullFaceMap = {}, (0, _defineProperty2.default)(_cullFaceMap, _gWebgpuCore.gl.FRONT, 'front'), (0, _defineProperty2.default)(_cullFaceMap, _gWebgpuCore.gl.BACK, 'back'), _cullFaceMap);\nexports.cullFaceMap = cullFaceMap;\n//# sourceMappingURL=constants.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar _isTypedarray = require(\"../utils/is-typedarray\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* babel-plugin-inline-import './shaders/quad.vert.glsl' */\nvar quadVert = \"attribute vec3 a_Position;\\nattribute vec2 a_TexCoord;\\n\\nvarying vec2 v_TexCoord;\\n\\nvoid main() {\\n  gl_Position = vec4(a_Position, 1.0);\\n  v_TexCoord = a_TexCoord;\\n}\";\nvar textureId = 0;\nvar debug = false;\n/**\n * adaptor for regl.DrawCommand\n */\n\nvar ReglComputeModel = /*#__PURE__*/function () {\n  function ReglComputeModel(reGl, context) {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, ReglComputeModel);\n    this.reGl = reGl;\n    this.context = context;\n    this.entity = (0, _gWebgpuCore.createEntity)();\n    this.texFBO = void 0;\n    this.computeCommand = void 0;\n    this.textureCache = {};\n    this.outputTextureName = void 0;\n    this.swapOutputTextureName = void 0;\n    this.compiledPingpong = void 0;\n    this.dynamicPingpong = void 0;\n    var uniforms = {};\n    this.context.uniforms.forEach(function (uniform) {\n      var name = uniform.name,\n          type = uniform.type,\n          data = uniform.data,\n          isReferer = uniform.isReferer,\n          storageClass = uniform.storageClass; // store data with a 2D texture\n\n      if (storageClass === _gWebgpuCore.STORAGE_CLASS.StorageBuffer) {\n        if (!isReferer) {\n          _this.textureCache[name] = _this.calcDataTexture(name, type, data);\n          var _this$textureCache$na = _this.textureCache[name],\n              width = _this$textureCache$na.textureWidth,\n              isOutput = _this$textureCache$na.isOutput;\n          uniforms[\"\".concat(name, \"Size\")] = [width, width];\n\n          if (isOutput) {\n            _this.outputTextureName = name;\n\n            if (_this.context.needPingpong) {\n              _this.outputTextureName = \"\".concat(name, \"Output\");\n              _this.textureCache[_this.outputTextureName] = _this.calcDataTexture(name, type, data);\n            }\n          }\n        } else {\n          // @ts-ignore\n          _this.textureCache[name] = {\n            data: undefined\n          }; // refer to another kernel's output,\n          // the referred kernel may not have been initialized, so we use dynamic way here\n\n          uniforms[\"\".concat(name, \"Size\")] = function () {\n            return (// @ts-ignore\n              data.compiledBundle.context.output.textureSize\n            );\n          };\n        }\n\n        uniforms[name] = function () {\n          if (debug) {\n            console.log(\"[\".concat(_this.entity, \"]: \").concat(name, \" \").concat(_this.textureCache[name].id));\n          }\n\n          return _this.textureCache[name].texture;\n        };\n      } else if (storageClass === _gWebgpuCore.STORAGE_CLASS.Uniform) {\n        if (data && (Array.isArray(data) || (0, _isTypedarray.isTypedArray)(data)) && data.length > 16) {\n          // up to mat4 which includes 16 elements\n          throw new Error(\"invalid data type \".concat(type));\n        } // get uniform dynamically\n\n\n        uniforms[name] = function () {\n          return uniform.data;\n        };\n      }\n    });\n\n    var _this$getOuputDataTex = this.getOuputDataTexture(),\n        textureWidth = _this$getOuputDataTex.textureWidth,\n        texelCount = _this$getOuputDataTex.texelCount; // 传入 output 纹理尺寸和数据长度，便于多余的 texel 提前退出\n\n\n    uniforms.u_OutputTextureSize = [textureWidth, textureWidth];\n    uniforms.u_OutputTexelCount = texelCount; // 保存在 Kernel 的上下文中，供其他 Kernel 引用\n\n    this.context.output.textureSize = [textureWidth, textureWidth];\n    var drawParams = {\n      attributes: {\n        a_Position: [[-1, 1, 0], [-1, -1, 0], [1, 1, 0], [1, -1, 0]],\n        a_TexCoord: [[0, 1], [0, 0], [1, 1], [1, 0]]\n      },\n      frag: \"#ifdef GL_FRAGMENT_PRECISION_HIGH\\n  precision highp float;\\n#else\\n  precision mediump float;\\n#endif\\n\".concat(this.context.shader),\n      uniforms: uniforms,\n      vert: quadVert,\n      // TODO: use a fullscreen triangle instead.\n      primitive: 'triangle strip',\n      count: 4\n    };\n    this.computeCommand = this.reGl(drawParams);\n  }\n\n  (0, _createClass2.default)(ReglComputeModel, [{\n    key: \"run\",\n    value: function run() {\n      var _this2 = this;\n\n      if (this.context.maxIteration > 1 && this.context.needPingpong) {\n        this.compiledPingpong = true;\n      } // need pingpong when (@in@out and execute(10)) or use `setBinding('out', self)`\n      // this.needPingpong =\n      //   !!(this.context.maxIteration > 1 && this.context.needPingpong);\n      // if (this.relativeOutputTextureNames.length) {\n      //   const { id, texture } = this.getOuputDataTexture();\n      //   this.relativeOutputTextureNames.forEach((name) => {\n      //     this.textureCache[name].id = id;\n      //     this.textureCache[name].texture = texture;\n      //   });\n      //   this.swap();\n      // }\n\n\n      if (this.compiledPingpong || this.dynamicPingpong) {\n        this.swap();\n      }\n\n      this.texFBO = this.reGl.framebuffer({\n        color: this.getOuputDataTexture().texture\n      });\n      this.texFBO.use(function () {\n        _this2.computeCommand();\n      });\n\n      if (debug) {\n        console.log(\"[\".concat(this.entity, \"]: output \").concat(this.getOuputDataTexture().id));\n      }\n    }\n  }, {\n    key: \"readData\",\n    value: function () {\n      var _readData = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n        var _this3 = this;\n\n        var pixels, _this$getOuputDataTex2, originalDataLength, elementsPerTexel, _this$getOuputDataTex3, typedArrayConstructor, formattedPixels, i;\n\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.reGl({\n                  framebuffer: this.texFBO\n                })(function () {\n                  pixels = _this3.reGl.read();\n                }); // @ts-ignore\n\n                if (!pixels) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _this$getOuputDataTex2 = this.getOuputDataTexture(), originalDataLength = _this$getOuputDataTex2.originalDataLength, elementsPerTexel = _this$getOuputDataTex2.elementsPerTexel, _this$getOuputDataTex3 = _this$getOuputDataTex2.typedArrayConstructor, typedArrayConstructor = _this$getOuputDataTex3 === void 0 ? Float32Array : _this$getOuputDataTex3;\n                formattedPixels = [];\n\n                if (elementsPerTexel !== 4) {\n                  for (i = 0; i < pixels.length; i += 4) {\n                    if (elementsPerTexel === 1) {\n                      formattedPixels.push(pixels[i]);\n                    } else if (elementsPerTexel === 2) {\n                      formattedPixels.push(pixels[i], pixels[i + 1]);\n                    } else {\n                      formattedPixels.push(pixels[i], pixels[i + 1], pixels[i + 2]);\n                    }\n                  }\n                } else {\n                  // @ts-ignore\n                  formattedPixels = pixels;\n                } // 截取多余的部分\n                // @ts-ignore\n\n\n                return _context.abrupt(\"return\", new typedArrayConstructor(formattedPixels.slice(0, originalDataLength)));\n\n              case 6:\n                return _context.abrupt(\"return\", new Float32Array());\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function readData() {\n        return _readData.apply(this, arguments);\n      }\n\n      return readData;\n    }()\n  }, {\n    key: \"confirmInput\",\n    value: function confirmInput(model, inputName) {\n      var inputModel; // refer to self, same as pingpong\n\n      if (this.entity === model.entity) {\n        this.dynamicPingpong = true;\n        inputModel = this;\n      } else {\n        inputModel = model;\n      }\n\n      this.textureCache[inputName].id = inputModel.getOuputDataTexture().id;\n      this.textureCache[inputName].texture = inputModel.getOuputDataTexture().texture;\n\n      if (debug) {\n        console.log(\"[\".concat(this.entity, \"]: confirm input \").concat(inputName, \" from model \").concat(inputModel.entity, \", \").concat(inputModel.getOuputDataTexture().id));\n      }\n    }\n  }, {\n    key: \"updateUniform\",\n    value: function updateUniform() {// already get uniform's data dynamically when created, do nothing here\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(bufferName, data) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      // regenerate data texture\n      var buffer = this.context.uniforms.find(function (_ref) {\n        var name = _ref.name;\n        return name === bufferName;\n      });\n\n      if (buffer) {\n        var _this$calcDataTexture = this.calcDataTexture(bufferName, buffer.type, data),\n            texture = _this$calcDataTexture.texture,\n            paddingData = _this$calcDataTexture.data; // TODO: destroy outdated texture\n\n\n        this.textureCache[bufferName].data = paddingData;\n        this.textureCache[bufferName].texture = texture;\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {// regl will destroy all resources\n    }\n  }, {\n    key: \"swap\",\n    value: function swap() {\n      if (!this.swapOutputTextureName) {\n        this.createSwapOutputDataTexture();\n      }\n\n      if (this.compiledPingpong) {\n        var outputTextureUniformName = this.context.output.name;\n        this.textureCache[outputTextureUniformName].id = this.getOuputDataTexture().id;\n        this.textureCache[outputTextureUniformName].texture = this.getOuputDataTexture().texture;\n      }\n\n      var tmp = this.outputTextureName;\n      this.outputTextureName = this.swapOutputTextureName;\n      this.swapOutputTextureName = tmp;\n\n      if (debug) {\n        console.log(\"[\".concat(this.entity, \"]: after swap, output \").concat(this.getOuputDataTexture().id));\n      }\n    }\n  }, {\n    key: \"getOuputDataTexture\",\n    value: function getOuputDataTexture() {\n      return this.textureCache[this.outputTextureName];\n    }\n  }, {\n    key: \"createSwapOutputDataTexture\",\n    value: function createSwapOutputDataTexture() {\n      var texture = this.cloneDataTexture(this.getOuputDataTexture());\n      this.swapOutputTextureName = \"\".concat(this.entity, \"-swap\");\n      this.textureCache[this.swapOutputTextureName] = texture;\n    }\n  }, {\n    key: \"cloneDataTexture\",\n    value: function cloneDataTexture(texture) {\n      var data = texture.data,\n          textureWidth = texture.textureWidth;\n      return _objectSpread(_objectSpread({}, texture), {}, {\n        id: textureId++,\n        // @ts-ignore\n        texture: this.reGl.texture({\n          width: textureWidth,\n          height: textureWidth,\n          data: data,\n          type: 'float'\n        })\n      });\n    }\n  }, {\n    key: \"calcDataTexture\",\n    value: function calcDataTexture(name, type, data) {\n      var elementsPerTexel = 1;\n\n      if (type === _gWebgpuCore.AST_TOKEN_TYPES.Vector4FloatArray) {\n        elementsPerTexel = 4;\n      } // 用 0 补全不足 vec4 的部分\n\n\n      var paddingData = [];\n\n      for (var i = 0; i < data.length; i += elementsPerTexel) {\n        if (elementsPerTexel === 1) {\n          paddingData.push(data[i], 0, 0, 0);\n        } else if (elementsPerTexel === 2) {\n          paddingData.push(data[i], data[i + 1], 0, 0);\n        } else if (elementsPerTexel === 3) {\n          paddingData.push(data[i], data[i + 1], data[i + 2], 0);\n        } else if (elementsPerTexel === 4) {\n          paddingData.push(data[i], data[i + 1], data[i + 2], data[i + 3]);\n        }\n      } // 使用纹理存储，例如 Array(8) 使用 3 * 3 纹理，末尾空白使用 0 填充\n\n\n      var originalDataLength = data.length;\n      var texelCount = Math.ceil(originalDataLength / elementsPerTexel);\n      var width = Math.ceil(Math.sqrt(texelCount));\n      var paddingTexelCount = width * width;\n\n      if (texelCount < paddingTexelCount) {\n        paddingData.push.apply(paddingData, (0, _toConsumableArray2.default)(new Array((paddingTexelCount - texelCount) * 4).fill(0)));\n      }\n\n      var texture = this.reGl.texture({\n        width: width,\n        height: width,\n        data: paddingData,\n        type: 'float'\n      });\n      return {\n        id: textureId++,\n        data: paddingData,\n        originalDataLength: originalDataLength,\n        typedArrayConstructor: (0, _isTypedarray.isTypedArray)(data) ? data.constructor : undefined,\n        textureWidth: width,\n        texture: texture,\n        texelCount: texelCount,\n        elementsPerTexel: elementsPerTexel,\n        isOutput: name === this.context.output.name\n      };\n    }\n  }]);\n  return ReglComputeModel;\n}();\n\nexports.default = ReglComputeModel;\n//# sourceMappingURL=ReglComputeModel.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTypedArray = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n/** `Object#toString` result references. */\n\nvar argsTag = '[object Arguments]';\nvar arrayTag = '[object Array]';\nvar boolTag = '[object Boolean]';\nvar dateTag = '[object Date]';\nvar errorTag = '[object Error]';\nvar funcTag = '[object Function]';\nvar mapTag = '[object Map]';\nvar numberTag = '[object Number]';\nvar objectTag = '[object Object]';\nvar regexpTag = '[object RegExp]';\nvar setTag = '[object Set]';\nvar stringTag = '[object String]';\nvar weakMapTag = '[object WeakMap]';\nvar arrayBufferTag = '[object ArrayBuffer]';\nvar dataViewTag = '[object DataView]';\nvar float32Tag = '[object Float32Array]';\nvar float64Tag = '[object Float64Array]';\nvar int8Tag = '[object Int8Array]';\nvar int16Tag = '[object Int16Array]';\nvar int32Tag = '[object Int32Array]';\nvar uint8Tag = '[object Uint8Array]';\nvar uint8ClampedTag = '[object Uint8ClampedArray]';\nvar uint16Tag = '[object Uint16Array]';\nvar uint32Tag = '[object Uint32Array]';\n/** Used to identify `toStringTag` values of typed arrays. */\n\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\n\nfunction baseUnary(func) {\n  return function (value) {\n    return func(value);\n  };\n}\n/** Used for built-in method references. */\n\n\nvar objectProto = Object.prototype;\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\n\nvar objectToString = objectProto.toString;\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\n\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\nfunction isLength(value) {\n  return typeof value === 'number' && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;\n}\n\nfunction isObjectLike(value) {\n  return !!value && (0, _typeof2.default)(value) === 'object';\n}\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\n\n\nvar isTypedArray = baseIsTypedArray;\nexports.isTypedArray = isTypedArray;\n//# sourceMappingURL=is-typedarray.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar _constants = require(\"./constants\");\n\n/**\n * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#elements\n */\nvar ReglElements = /*#__PURE__*/function () {\n  function ReglElements(reGl, options) {\n    (0, _classCallCheck2.default)(this, ReglElements);\n    this.elements = void 0;\n    var data = options.data,\n        usage = options.usage,\n        type = options.type,\n        count = options.count;\n    this.elements = reGl.elements({\n      data: data,\n      usage: _constants.usageMap[usage || _gWebgpuCore.gl.STATIC_DRAW],\n      type: _constants.dataTypeMap[type || _gWebgpuCore.gl.UNSIGNED_BYTE],\n      count: count\n    });\n  }\n\n  (0, _createClass2.default)(ReglElements, [{\n    key: \"get\",\n    value: function get() {\n      return this.elements;\n    }\n  }, {\n    key: \"subData\",\n    value: function subData(_ref) {\n      var data = _ref.data;\n      this.elements.subdata(data);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.elements.destroy();\n    }\n  }]);\n  return ReglElements;\n}();\n\nexports.default = ReglElements;\n//# sourceMappingURL=ReglElements.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\n/**\n * adaptor for regl.Framebuffer\n * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#framebuffers\n */\nvar ReglFramebuffer = /*#__PURE__*/function () {\n  function ReglFramebuffer(reGl, options) {\n    (0, _classCallCheck2.default)(this, ReglFramebuffer);\n    this.framebuffer = void 0;\n    var width = options.width,\n        height = options.height,\n        color = options.color,\n        colors = options.colors,\n        depth = options.depth,\n        stencil = options.stencil;\n    var framebufferOptions = {\n      width: width,\n      height: height\n    };\n\n    if (Array.isArray(colors)) {\n      framebufferOptions.colors = colors.map(function (c) {\n        return c.get();\n      });\n    }\n\n    if (color && typeof color !== 'boolean') {\n      framebufferOptions.color = color.get();\n    } // TODO: depth & stencil\n\n\n    this.framebuffer = reGl.framebuffer(framebufferOptions);\n  }\n\n  (0, _createClass2.default)(ReglFramebuffer, [{\n    key: \"get\",\n    value: function get() {\n      return this.framebuffer;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.framebuffer.destroy();\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(_ref) {\n      var width = _ref.width,\n          height = _ref.height;\n      this.framebuffer.resize(width, height);\n    }\n  }]);\n  return ReglFramebuffer;\n}();\n\nexports.default = ReglFramebuffer;\n//# sourceMappingURL=ReglFramebuffer.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar _uniform = require(\"../utils/uniform\");\n\nvar _constants = require(\"./constants\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n * adaptor for regl.DrawCommand\n */\nvar ReglModel = /*#__PURE__*/function () {\n  function ReglModel(reGl, options) {\n    (0, _classCallCheck2.default)(this, ReglModel);\n    this.reGl = void 0;\n    this.drawCommand = void 0;\n    this.uniforms = {};\n    this.reGl = reGl;\n    var vs = options.vs,\n        fs = options.fs,\n        defines = options.defines,\n        attributes = options.attributes,\n        uniforms = options.uniforms,\n        primitive = options.primitive,\n        count = options.count,\n        elements = options.elements,\n        depth = options.depth,\n        blend = options.blend,\n        stencil = options.stencil,\n        cull = options.cull,\n        instances = options.instances,\n        scissor = options.scissor,\n        viewport = options.viewport;\n    var reglUniforms = {};\n\n    if (uniforms) {\n      this.uniforms = (0, _uniform.extractUniforms)(uniforms);\n      Object.keys(uniforms).forEach(function (uniformName) {\n        // use regl prop API\n        // @ts-ignore\n        reglUniforms[uniformName] = reGl.prop(uniformName);\n      });\n    }\n\n    var reglAttributes = {};\n    Object.keys(attributes).forEach(function (name) {\n      reglAttributes[name] = attributes[name].get();\n    });\n    var defineStmts = defines && this.generateDefines(defines) || '';\n    var drawParams = {\n      attributes: reglAttributes,\n      frag: \"#ifdef GL_FRAGMENT_PRECISION_HIGH\\n  precision highp float;\\n#else\\n  precision mediump float;\\n#endif\\n\".concat(defineStmts, \"\\n\").concat(fs),\n      uniforms: reglUniforms,\n      vert: \"\\n\".concat(defineStmts, \"\\n\").concat(vs),\n      primitive: _constants.primitiveMap[primitive === undefined ? _gWebgpuCore.gl.TRIANGLES : primitive]\n    };\n\n    if (instances) {\n      drawParams.instances = instances;\n    } // elements 中可能包含 count，此时不应传入\n\n\n    if (count) {\n      drawParams.count = count;\n    }\n\n    if (elements) {\n      drawParams.elements = elements.get();\n    }\n\n    if (scissor) {\n      drawParams.scissor = scissor;\n    }\n\n    if (viewport) {\n      drawParams.viewport = viewport;\n    }\n\n    this.initDepthDrawParams({\n      depth: depth\n    }, drawParams);\n    this.initBlendDrawParams({\n      blend: blend\n    }, drawParams);\n    this.initStencilDrawParams({\n      stencil: stencil\n    }, drawParams);\n    this.initCullDrawParams({\n      cull: cull\n    }, drawParams);\n    this.drawCommand = reGl(drawParams);\n  }\n\n  (0, _createClass2.default)(ReglModel, [{\n    key: \"addUniforms\",\n    value: function addUniforms(uniforms) {\n      this.uniforms = _objectSpread(_objectSpread({}, this.uniforms), (0, _uniform.extractUniforms)(uniforms));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(options) {\n      var uniforms = _objectSpread(_objectSpread({}, this.uniforms), (0, _uniform.extractUniforms)(options.uniforms || {}));\n\n      var reglDrawProps = {};\n      Object.keys(uniforms).forEach(function (uniformName) {\n        var type = (0, _typeof2.default)(uniforms[uniformName]);\n\n        if (type === 'boolean' || type === 'number' || Array.isArray(uniforms[uniformName]) || // @ts-ignore\n        uniforms[uniformName].BYTES_PER_ELEMENT) {\n          reglDrawProps[uniformName] = uniforms[uniformName];\n        } else if (type === 'string') {// TODO: image url\n        } else {\n          reglDrawProps[uniformName] = uniforms[uniformName].get();\n        }\n      });\n      this.drawCommand(reglDrawProps);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {// don't need do anything since we will call `rendererService.cleanup()`\n    }\n    /**\n     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#depth-buffer\n     */\n\n  }, {\n    key: \"initDepthDrawParams\",\n    value: function initDepthDrawParams(_ref, drawParams) {\n      var depth = _ref.depth;\n\n      if (depth) {\n        drawParams.depth = {\n          enable: depth.enable === undefined ? true : !!depth.enable,\n          mask: depth.mask === undefined ? true : !!depth.mask,\n          func: _constants.depthFuncMap[depth.func || _gWebgpuCore.gl.LESS],\n          range: depth.range || [0, 1]\n        };\n      }\n    }\n    /**\n     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#blending\n     */\n\n  }, {\n    key: \"initBlendDrawParams\",\n    value: function initBlendDrawParams(_ref2, drawParams) {\n      var blend = _ref2.blend;\n\n      if (blend) {\n        var enable = blend.enable,\n            func = blend.func,\n            equation = blend.equation,\n            _blend$color = blend.color,\n            color = _blend$color === void 0 ? [0, 0, 0, 0] : _blend$color; // @ts-ignore\n\n        drawParams.blend = {\n          enable: !!enable,\n          func: {\n            srcRGB: _constants.blendFuncMap[func && func.srcRGB || _gWebgpuCore.gl.SRC_ALPHA],\n            srcAlpha: _constants.blendFuncMap[func && func.srcAlpha || _gWebgpuCore.gl.SRC_ALPHA],\n            dstRGB: _constants.blendFuncMap[func && func.dstRGB || _gWebgpuCore.gl.ONE_MINUS_SRC_ALPHA],\n            dstAlpha: _constants.blendFuncMap[func && func.dstAlpha || _gWebgpuCore.gl.ONE_MINUS_SRC_ALPHA]\n          },\n          equation: {\n            rgb: _constants.blendEquationMap[equation && equation.rgb || _gWebgpuCore.gl.FUNC_ADD],\n            alpha: _constants.blendEquationMap[equation && equation.alpha || _gWebgpuCore.gl.FUNC_ADD]\n          },\n          color: color\n        };\n      }\n    }\n    /**\n     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil\n     */\n\n  }, {\n    key: \"initStencilDrawParams\",\n    value: function initStencilDrawParams(_ref3, drawParams) {\n      var stencil = _ref3.stencil;\n\n      if (stencil) {\n        var enable = stencil.enable,\n            _stencil$mask = stencil.mask,\n            mask = _stencil$mask === void 0 ? -1 : _stencil$mask,\n            _stencil$func = stencil.func,\n            func = _stencil$func === void 0 ? {\n          cmp: _gWebgpuCore.gl.ALWAYS,\n          ref: 0,\n          mask: -1\n        } : _stencil$func,\n            _stencil$opFront = stencil.opFront,\n            opFront = _stencil$opFront === void 0 ? {\n          fail: _gWebgpuCore.gl.KEEP,\n          zfail: _gWebgpuCore.gl.KEEP,\n          zpass: _gWebgpuCore.gl.KEEP\n        } : _stencil$opFront,\n            _stencil$opBack = stencil.opBack,\n            opBack = _stencil$opBack === void 0 ? {\n          fail: _gWebgpuCore.gl.KEEP,\n          zfail: _gWebgpuCore.gl.KEEP,\n          zpass: _gWebgpuCore.gl.KEEP\n        } : _stencil$opBack;\n        drawParams.stencil = {\n          enable: !!enable,\n          mask: mask,\n          func: _objectSpread(_objectSpread({}, func), {}, {\n            cmp: _constants.stencilFuncMap[func.cmp]\n          }),\n          opFront: {\n            fail: _constants.stencilOpMap[opFront.fail],\n            zfail: _constants.stencilOpMap[opFront.zfail],\n            zpass: _constants.stencilOpMap[opFront.zpass]\n          },\n          opBack: {\n            fail: _constants.stencilOpMap[opBack.fail],\n            zfail: _constants.stencilOpMap[opBack.zfail],\n            zpass: _constants.stencilOpMap[opBack.zpass]\n          }\n        };\n      }\n    }\n    /**\n     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling\n     */\n\n  }, {\n    key: \"initCullDrawParams\",\n    value: function initCullDrawParams(_ref4, drawParams) {\n      var cull = _ref4.cull;\n\n      if (cull) {\n        var enable = cull.enable,\n            _cull$face = cull.face,\n            face = _cull$face === void 0 ? _gWebgpuCore.gl.BACK : _cull$face;\n        drawParams.cull = {\n          enable: !!enable,\n          face: _constants.cullFaceMap[face]\n        };\n      }\n    }\n  }, {\n    key: \"generateDefines\",\n    value: function generateDefines(defines) {\n      return Object.keys(defines).map(function (name) {\n        return \"#define \".concat(name, \" \").concat(Number(defines[name]));\n      }).join('\\n');\n    }\n  }]);\n  return ReglModel;\n}();\n\nexports.default = ReglModel;\n//# sourceMappingURL=ReglModel.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractUniforms = extractUniforms;\n\nvar _isObject = require(\"./is-object\");\n\nvar _isTypedarray = require(\"./is-typedarray\");\n\n/**\n * 考虑结构体命名, eg:\n * a: { b: 1 }  ->  'a.b'\n * a: [ { b: 1 } ] -> 'a[0].b'\n */\nfunction extractUniforms(uniforms) {\n  var extractedUniforms = {};\n  Object.keys(uniforms).forEach(function (uniformName) {\n    extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, '');\n  });\n  return extractedUniforms;\n}\n\nfunction extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {\n  if (uniformValue === null || typeof uniformValue === 'number' || // u_A: 1\n  typeof uniformValue === 'boolean' || // u_A: false\n  Array.isArray(uniformValue) && typeof uniformValue[0] === 'number' || // u_A: [1, 2, 3]\n  (0, _isTypedarray.isTypedArray)(uniformValue) || // u_A: Float32Array\n  // @ts-ignore\n  uniformValue === '' || // @ts-ignore\n  uniformValue.resize !== undefined) {\n    uniforms[\"\".concat(prefix && prefix + '.').concat(uniformName)] = uniformValue;\n    return;\n  } // u_Struct.a.b.c\n\n\n  if ((0, _isObject.isObject)(uniformValue)) {\n    Object.keys(uniformValue).forEach(function (childName) {\n      extractUniformsRecursively(childName, // @ts-ignore\n      uniformValue[childName], uniforms, \"\".concat(prefix && prefix + '.').concat(uniformName));\n    });\n  } // u_Struct[0].a\n\n\n  if (Array.isArray(uniformValue)) {\n    // @ts-ignore\n    uniformValue.forEach(function (child, idx) {\n      Object.keys(child).forEach(function (childName) {\n        extractUniformsRecursively(childName, // @ts-ignore\n        child[childName], uniforms, \"\".concat(prefix && prefix + '.').concat(uniformName, \"[\").concat(idx, \"]\"));\n      });\n    });\n  }\n}\n//# sourceMappingURL=uniform.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isObject = isObject;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nfunction isObject(value) {\n  var type = (0, _typeof2.default)(value);\n  return value != null && (type === 'object' || type === 'function');\n}\n//# sourceMappingURL=is-object.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar _constants = require(\"./constants\");\n\n/**\n * adaptor for regl.Buffer\n * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#buffers\n */\nvar ReglTexture2D = /*#__PURE__*/function () {\n  function ReglTexture2D(reGl, options) {\n    (0, _classCallCheck2.default)(this, ReglTexture2D);\n    this.texture = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    var data = options.data,\n        _options$type = options.type,\n        type = _options$type === void 0 ? _gWebgpuCore.gl.UNSIGNED_BYTE : _options$type,\n        width = options.width,\n        height = options.height,\n        _options$flipY = options.flipY,\n        flipY = _options$flipY === void 0 ? false : _options$flipY,\n        _options$format = options.format,\n        format = _options$format === void 0 ? _gWebgpuCore.gl.RGBA : _options$format,\n        _options$mipmap = options.mipmap,\n        mipmap = _options$mipmap === void 0 ? false : _options$mipmap,\n        _options$wrapS = options.wrapS,\n        wrapS = _options$wrapS === void 0 ? _gWebgpuCore.gl.CLAMP_TO_EDGE : _options$wrapS,\n        _options$wrapT = options.wrapT,\n        wrapT = _options$wrapT === void 0 ? _gWebgpuCore.gl.CLAMP_TO_EDGE : _options$wrapT,\n        _options$aniso = options.aniso,\n        aniso = _options$aniso === void 0 ? 0 : _options$aniso,\n        _options$alignment = options.alignment,\n        alignment = _options$alignment === void 0 ? 1 : _options$alignment,\n        _options$premultiplyA = options.premultiplyAlpha,\n        premultiplyAlpha = _options$premultiplyA === void 0 ? false : _options$premultiplyA,\n        _options$mag = options.mag,\n        mag = _options$mag === void 0 ? _gWebgpuCore.gl.NEAREST : _options$mag,\n        _options$min = options.min,\n        min = _options$min === void 0 ? _gWebgpuCore.gl.NEAREST : _options$min,\n        _options$colorSpace = options.colorSpace,\n        colorSpace = _options$colorSpace === void 0 ? _gWebgpuCore.gl.BROWSER_DEFAULT_WEBGL : _options$colorSpace;\n    this.width = width;\n    this.height = height;\n    var textureOptions = {\n      width: width,\n      height: height,\n      // @ts-ignore\n      type: _constants.dataTypeMap[type],\n      format: _constants.formatMap[format],\n      wrapS: _constants.wrapModeMap[wrapS],\n      wrapT: _constants.wrapModeMap[wrapT],\n      // @ts-ignore\n      mag: _constants.filterMap[mag],\n      min: _constants.filterMap[min],\n      alignment: alignment,\n      flipY: flipY,\n      colorSpace: _constants.colorSpaceMap[colorSpace],\n      premultiplyAlpha: premultiplyAlpha,\n      aniso: aniso\n    };\n\n    if (data) {\n      textureOptions.data = data;\n    }\n\n    if (typeof mipmap === 'number') {\n      textureOptions.mipmap = _constants.mipmapMap[mipmap];\n    } else if (typeof mipmap === 'boolean') {\n      textureOptions.mipmap = mipmap;\n    }\n\n    this.texture = reGl.texture(textureOptions);\n  }\n\n  (0, _createClass2.default)(ReglTexture2D, [{\n    key: \"get\",\n    value: function get() {\n      return this.texture;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      // @ts-ignore\n      this.texture._texture.bind();\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(_ref) {\n      var width = _ref.width,\n          height = _ref.height;\n      this.texture.resize(width, height);\n      this.width = width;\n      this.height = height;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.texture.destroy();\n    }\n  }]);\n  return ReglTexture2D;\n}();\n\nexports.default = ReglTexture2D;\n//# sourceMappingURL=ReglTexture2D.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebGPUEngine = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar WebGPUConstants = _interopRequireWildcard(require(\"@webgpu/types/dist/constants\"));\n\nvar _inversify = require(\"inversify\");\n\nvar _glslang = _interopRequireDefault(require(\"./glslang\"));\n\nvar _WebGPUAttribute = _interopRequireDefault(require(\"./WebGPUAttribute\"));\n\nvar _WebGPUBuffer = _interopRequireDefault(require(\"./WebGPUBuffer\"));\n\nvar _WebGPUComputeModel = _interopRequireDefault(require(\"./WebGPUComputeModel\"));\n\nvar _WebGPUElements = _interopRequireDefault(require(\"./WebGPUElements\"));\n\nvar _WebGPUFramebuffer = _interopRequireDefault(require(\"./WebGPUFramebuffer\"));\n\nvar _WebGPUModel = _interopRequireDefault(require(\"./WebGPUModel\"));\n\nvar _WebGPUTexture2D = _interopRequireDefault(require(\"./WebGPUTexture2D\"));\n\nvar _dec, _class, _temp;\n\n/**\n * regl renderer\n */\nvar WebGPUEngine = (_dec = (0, _inversify.injectable)(), _dec(_class = (_temp = /*#__PURE__*/function () {\n  function WebGPUEngine() {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, WebGPUEngine);\n    this.supportWebGPU = true;\n    this.useWGSL = false;\n    this.options = void 0;\n    this.canvas = void 0;\n    this.context = void 0;\n    this.glslang = void 0;\n    this.adapter = void 0;\n    this.device = void 0;\n    this.swapChain = void 0;\n    this.mainPassSampleCount = void 0;\n    this.mainTexture = void 0;\n    this.depthTexture = void 0;\n    this.mainColorAttachments = void 0;\n    this.mainTextureExtends = void 0;\n    this.mainDepthAttachment = void 0;\n    this.uploadEncoder = void 0;\n    this.renderEncoder = void 0;\n    this.computeEncoder = void 0;\n    this.renderTargetEncoder = void 0;\n    this.commandBuffers = new Array(4).fill(undefined);\n    this.currentRenderPass = null;\n    this.mainRenderPass = null;\n    this.currentRenderTargetViewDescriptor = void 0;\n    this.currentComputePass = null;\n    this.bundleEncoder = void 0;\n    this.tempBuffers = [];\n    this.currentRenderTarget = null;\n    this.uploadEncoderDescriptor = {\n      label: 'upload'\n    };\n    this.renderEncoderDescriptor = {\n      label: 'render'\n    };\n    this.renderTargetEncoderDescriptor = {\n      label: 'renderTarget'\n    };\n    this.computeEncoderDescriptor = {\n      label: 'compute'\n    };\n    this.pipelines = {};\n    this.computePipelines = {};\n    this.defaultSampleCount = 4;\n    this.clearDepthValue = 1;\n    this.clearStencilValue = 0;\n    this.transientViewport = {\n      x: Infinity,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    this.cachedViewport = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n\n    this.clear = function (options) {\n      var framebuffer = options.framebuffer,\n          color = options.color,\n          depth = options.depth,\n          stencil = options.stencil;\n\n      if (_this.options.supportCompute) {\n        _this.startComputePass();\n      } // We need to recreate the render pass so that the new parameters for clear color / depth / stencil are taken into account\n\n\n      if (_this.currentRenderTarget) {\n        if (_this.currentRenderPass) {\n          _this.endRenderTargetRenderPass();\n        }\n\n        _this.startRenderTargetRenderPass(_this.currentRenderTarget, color ? color : null, !!depth, !!stencil);\n      } else {\n        // if (this.useReverseDepthBuffer) {\n        //     this._depthCullingState.depthFunc = Constants.GREATER;\n        // }\n        _this.mainColorAttachments[0].loadValue = color ? color : WebGPUConstants.LoadOp.Load;\n        _this.mainDepthAttachment.depthLoadValue = depth ? depth : WebGPUConstants.LoadOp.Load;\n        _this.mainDepthAttachment.stencilLoadValue = stencil ? _this.clearStencilValue : WebGPUConstants.LoadOp.Load;\n\n        if (_this.mainRenderPass) {\n          _this.endMainRenderPass();\n        }\n\n        _this.startMainRenderPass();\n      }\n    };\n\n    this.createModel = /*#__PURE__*/function () {\n      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(options) {\n        var model;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                model = new _WebGPUModel.default(_this, options);\n                _context.next = 3;\n                return model.init();\n\n              case 3:\n                return _context.abrupt(\"return\", model);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.createAttribute = function (options) {\n      return new _WebGPUAttribute.default(_this, options);\n    };\n\n    this.createBuffer = function (options) {\n      return new _WebGPUBuffer.default(_this, options);\n    };\n\n    this.createElements = function (options) {\n      return new _WebGPUElements.default(_this, options);\n    };\n\n    this.createTexture2D = function (options) {\n      return new _WebGPUTexture2D.default(_this, options);\n    };\n\n    this.createFramebuffer = function (options) {\n      return new _WebGPUFramebuffer.default(_this, options);\n    };\n\n    this.useFramebuffer = function (framebuffer, drawCommands) {\n      // bind\n      if (_this.currentRenderTarget) {\n        _this.unbindFramebuffer(_this.currentRenderTarget);\n      }\n\n      _this.currentRenderTarget = framebuffer; // TODO: use mipmap options in framebuffer\n\n      _this.currentRenderTargetViewDescriptor = {\n        dimension: WebGPUConstants.TextureViewDimension.E2d,\n        // mipLevelCount: bindWithMipMaps ? WebGPUTextureHelper.computeNumMipmapLevels(texture.width, texture.height) - lodLevel : 1,\n        // baseArrayLayer: faceIndex,\n        // baseMipLevel: lodLevel,\n        arrayLayerCount: 1,\n        aspect: WebGPUConstants.TextureAspect.All\n      };\n      _this.currentRenderPass = null;\n      drawCommands();\n    };\n\n    this.createComputeModel = /*#__PURE__*/function () {\n      var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(context) {\n        var model;\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                model = new _WebGPUComputeModel.default(_this, context);\n                _context2.next = 3;\n                return model.init();\n\n              case 3:\n                return _context2.abrupt(\"return\", model);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    this.getCanvas = function () {\n      return _this.canvas;\n    };\n\n    this.getGLContext = function () {\n      throw new Error('Method not implemented.');\n    };\n\n    this.viewport = function (_ref3) {\n      var x = _ref3.x,\n          y = _ref3.y,\n          width = _ref3.width,\n          height = _ref3.height;\n\n      if (!_this.currentRenderPass) {\n        // call viewport() before current render pass created\n        _this.transientViewport = {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n      } else if (_this.transientViewport.x !== Infinity) {\n        var renderPass = _this.getCurrentRenderPass(); // @see https://gpuweb.github.io/gpuweb/#dom-gpurenderpassencoder-setviewport\n\n\n        renderPass.setViewport(_this.transientViewport.x, _this.transientViewport.y, _this.transientViewport.width, _this.transientViewport.height, 0, 1);\n      } else if (x !== _this.cachedViewport.x || y !== _this.cachedViewport.y || width !== _this.cachedViewport.width || height !== _this.cachedViewport.height) {\n        _this.cachedViewport = {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n\n        var _renderPass = _this.getCurrentRenderPass();\n\n        _renderPass.setViewport(x, y, width, height, 0, 1);\n      }\n    };\n\n    this.readPixels = function (options) {\n      throw new Error('Method not implemented.');\n    };\n  }\n\n  (0, _createClass2.default)(WebGPUEngine, [{\n    key: \"isFloatSupported\",\n    value: function isFloatSupported() {\n      return true;\n    }\n  }, {\n    key: \"init\",\n    value: function () {\n      var _init = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(config) {\n        return _regenerator.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.canvas = config.canvas;\n                this.options = config;\n                this.useWGSL = !!config.useWGSL;\n                this.mainPassSampleCount = config.antialiasing ? this.defaultSampleCount : 1;\n                _context3.next = 6;\n                return this.initGlslang();\n\n              case 6:\n                this.initContextAndSwapChain();\n                this.initMainAttachments();\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function init(_x3) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"setScissor\",\n    value: function setScissor(scissor) {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.mainTexture) {\n        this.mainTexture.destroy();\n      }\n\n      if (this.depthTexture) {\n        this.depthTexture.destroy();\n      }\n\n      this.tempBuffers.forEach(function (buffer) {\n        return buffer.destroy();\n      });\n      this.tempBuffers = [];\n    }\n  }, {\n    key: \"beginFrame\",\n    value: function beginFrame() {\n      this.uploadEncoder = this.device.createCommandEncoder(this.uploadEncoderDescriptor);\n      this.renderEncoder = this.device.createCommandEncoder(this.renderEncoderDescriptor);\n      this.renderTargetEncoder = this.device.createCommandEncoder(this.renderTargetEncoderDescriptor);\n\n      if (this.options.supportCompute) {\n        this.computeEncoder = this.device.createCommandEncoder(this.computeEncoderDescriptor);\n      }\n    }\n  }, {\n    key: \"endFrame\",\n    value: function endFrame() {\n      if (this.options.supportCompute) {\n        this.endComputePass();\n      }\n\n      this.endMainRenderPass();\n      this.commandBuffers[0] = this.uploadEncoder.finish();\n      this.commandBuffers[1] = this.renderEncoder.finish();\n\n      if (this.options.supportCompute) {\n        this.commandBuffers[2] = this.computeEncoder.finish();\n      }\n\n      this.commandBuffers[3] = this.renderTargetEncoder.finish();\n\n      if (_gWebgpuCore.isSafari) {\n        this.device // @ts-ignore\n        .getQueue().submit(this.commandBuffers.filter(function (buffer) {\n          return buffer;\n        }));\n      } else {\n        this.device.defaultQueue.submit(this.commandBuffers.filter(function (buffer) {\n          return buffer;\n        }));\n      }\n    }\n  }, {\n    key: \"getCurrentRenderPass\",\n    value: function getCurrentRenderPass() {\n      if (this.currentRenderTarget && !this.currentRenderPass) {\n        this.startRenderTargetRenderPass(this.currentRenderTarget, null, false, false);\n      } else if (!this.currentRenderPass) {\n        this.startMainRenderPass();\n      }\n\n      return this.currentRenderPass;\n    }\n  }, {\n    key: \"initGlslang\",\n    value: function () {\n      var _initGlslang = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {\n        var _navigator, _navigator$gpu;\n\n        return _regenerator.default.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return (0, _glslang.default)();\n\n              case 2:\n                this.glslang = _context4.sent;\n                _context4.next = 5;\n                return (_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator$gpu = _navigator.gpu) === null || _navigator$gpu === void 0 ? void 0 : _navigator$gpu.requestAdapter();\n\n              case 5:\n                this.adapter = _context4.sent;\n                _context4.next = 8;\n                return this.adapter.requestDevice();\n\n              case 8:\n                this.device = _context4.sent;\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function initGlslang() {\n        return _initGlslang.apply(this, arguments);\n      }\n\n      return initGlslang;\n    }()\n  }, {\n    key: \"initContextAndSwapChain\",\n    value: function initContextAndSwapChain() {\n      this.context = this.canvas.getContext(_gWebgpuCore.isSafari ? 'gpu' : 'gpupresent');\n      this.swapChain = this.context.configureSwapChain({\n        device: this.device,\n        format: this.options.swapChainFormat,\n        usage: WebGPUConstants.TextureUsage.OutputAttachment | WebGPUConstants.TextureUsage.CopySrc\n      });\n    }\n  }, {\n    key: \"initMainAttachments\",\n    value: function initMainAttachments() {\n      this.mainTextureExtends = {\n        width: this.canvas.width,\n        height: this.canvas.height,\n        depth: 1\n      };\n\n      if (this.options.antialiasing) {\n        var mainTextureDescriptor = {\n          size: this.mainTextureExtends,\n          // TODO: arrayLayerCount is deprecated: use size.depth\n          // arrayLayerCount: 1,\n          mipLevelCount: 1,\n          sampleCount: this.mainPassSampleCount,\n          dimension: WebGPUConstants.TextureDimension.E2d,\n          format: WebGPUConstants.TextureFormat.BGRA8Unorm,\n          usage: WebGPUConstants.TextureUsage.OutputAttachment\n        };\n\n        if (this.mainTexture) {\n          this.mainTexture.destroy();\n        }\n\n        this.mainTexture = this.device.createTexture(mainTextureDescriptor);\n        this.mainColorAttachments = [{\n          attachment: _gWebgpuCore.isSafari ? // @ts-ignore\n          this.mainTexture.createDefaultView() : this.mainTexture.createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store\n        }];\n      } else {\n        this.mainColorAttachments = [{\n          attachment: _gWebgpuCore.isSafari ? // @ts-ignore\n          this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView(),\n          loadValue: [0, 0, 0, 1],\n          storeOp: WebGPUConstants.StoreOp.Store\n        }];\n      }\n\n      var depthTextureDescriptor = {\n        size: this.mainTextureExtends,\n        // arrayLayerCount: 1,\n        mipLevelCount: 1,\n        sampleCount: this.mainPassSampleCount,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: _gWebgpuCore.isSafari ? 'depth32float-stencil8' : WebGPUConstants.TextureFormat.Depth24PlusStencil8,\n        usage: WebGPUConstants.TextureUsage.OutputAttachment\n      };\n\n      if (this.depthTexture) {\n        this.depthTexture.destroy();\n      }\n\n      this.depthTexture = this.device.createTexture( // @ts-ignore\n      depthTextureDescriptor);\n      this.mainDepthAttachment = {\n        attachment: _gWebgpuCore.isSafari ? // @ts-ignore\n        this.depthTexture.createDefaultView() : this.depthTexture.createView(),\n        depthLoadValue: this.clearDepthValue,\n        depthStoreOp: WebGPUConstants.StoreOp.Store,\n        stencilLoadValue: this.clearStencilValue,\n        stencilStoreOp: WebGPUConstants.StoreOp.Store\n      };\n    }\n  }, {\n    key: \"startComputePass\",\n    value: function startComputePass() {\n      if (this.currentComputePass) {\n        this.endComputePass();\n      }\n\n      this.currentComputePass = this.computeEncoder.beginComputePass();\n    }\n  }, {\n    key: \"startMainRenderPass\",\n    value: function startMainRenderPass() {\n      if (this.currentRenderPass && !this.currentRenderTarget) {\n        this.endMainRenderPass();\n      } // Resolve in case of MSAA\n\n\n      if (this.options.antialiasing) {\n        this.mainColorAttachments[0].resolveTarget = _gWebgpuCore.isSafari ? // @ts-ignore\n        this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView();\n      } else {\n        this.mainColorAttachments[0].attachment = _gWebgpuCore.isSafari ? // @ts-ignore\n        this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView();\n      }\n\n      this.currentRenderPass = this.renderEncoder.beginRenderPass({\n        colorAttachments: this.mainColorAttachments,\n        depthStencilAttachment: this.mainDepthAttachment // TODO: use framebuffer's depth & stencil\n\n      });\n      this.mainRenderPass = this.currentRenderPass;\n\n      if (this.cachedViewport) {\n        this.viewport(this.cachedViewport);\n      }\n    }\n  }, {\n    key: \"startRenderTargetRenderPass\",\n    value: function startRenderTargetRenderPass(renderTarget, clearColor, clearDepth) {\n      var _renderTarget$get$col, _renderTarget$get$dep;\n\n      var clearStencil = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var gpuTexture = (_renderTarget$get$col = renderTarget.get().color) === null || _renderTarget$get$col === void 0 ? void 0 : _renderTarget$get$col.texture;\n      var colorTextureView;\n\n      if (gpuTexture) {\n        colorTextureView = gpuTexture.createView(this.currentRenderTargetViewDescriptor);\n      }\n\n      var depthStencilTexture = (_renderTarget$get$dep = renderTarget.get().depth) === null || _renderTarget$get$dep === void 0 ? void 0 : _renderTarget$get$dep.texture;\n      var depthStencilTextureView;\n\n      if (depthStencilTexture) {\n        depthStencilTextureView = depthStencilTexture.createView();\n      }\n\n      var renderPass = this.renderTargetEncoder.beginRenderPass({\n        colorAttachments: [{\n          attachment: colorTextureView,\n          loadValue: clearColor !== null ? clearColor : WebGPUConstants.LoadOp.Load,\n          storeOp: WebGPUConstants.StoreOp.Store\n        }],\n        depthStencilAttachment: depthStencilTexture && depthStencilTextureView ? {\n          attachment: depthStencilTextureView,\n          depthLoadValue: clearDepth ? this.clearDepthValue : WebGPUConstants.LoadOp.Load,\n          depthStoreOp: WebGPUConstants.StoreOp.Store,\n          stencilLoadValue: clearStencil ? this.clearStencilValue : WebGPUConstants.LoadOp.Load,\n          stencilStoreOp: WebGPUConstants.StoreOp.Store\n        } : undefined\n      });\n      this.currentRenderPass = renderPass;\n\n      if (this.cachedViewport) {\n        this.viewport(this.cachedViewport);\n      } // TODO WEBGPU set the scissor rect and the stencil reference value\n\n    }\n  }, {\n    key: \"endMainRenderPass\",\n    value: function endMainRenderPass() {\n      if (this.currentRenderPass === this.mainRenderPass && this.currentRenderPass !== null) {\n        this.currentRenderPass.endPass();\n        this.resetCachedViewport();\n        this.currentRenderPass = null;\n        this.mainRenderPass = null;\n      }\n    }\n  }, {\n    key: \"endComputePass\",\n    value: function endComputePass() {\n      if (this.currentComputePass) {\n        this.currentComputePass.endPass();\n        this.currentComputePass = null;\n      }\n    }\n  }, {\n    key: \"endRenderTargetRenderPass\",\n    value: function endRenderTargetRenderPass() {\n      if (this.currentRenderPass) {\n        this.currentRenderPass.endPass();\n        this.resetCachedViewport();\n      }\n    }\n  }, {\n    key: \"resetCachedViewport\",\n    value: function resetCachedViewport() {\n      this.cachedViewport = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n    }\n  }, {\n    key: \"unbindFramebuffer\",\n    value: function unbindFramebuffer(framebuffer) {\n      // unbind\n      if (this.currentRenderPass && this.currentRenderPass !== this.mainRenderPass) {\n        this.endRenderTargetRenderPass();\n      }\n\n      this.transientViewport.x = Infinity;\n      this.currentRenderTarget = null; // if (texture.generateMipMaps && !disableGenerateMipMaps && !texture.isCube) {\n      //   this._generateMipmaps(texture);\n      // }\n\n      this.currentRenderPass = this.mainRenderPass;\n    }\n  }]);\n  return WebGPUEngine;\n}(), _temp)) || _class);\nexports.WebGPUEngine = WebGPUEngine;\n//# sourceMappingURL=index.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _dom = require(\"../utils/dom\");\n\nvar glslang;\n\nfunction _default() {\n  return _ref.apply(this, arguments);\n}\n\nfunction _ref() {\n  _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!glslang) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\", glslang);\n\n          case 2:\n            _context.next = 4;\n            return (0, _dom.loadScriptAsync)('https://preview.babylonjs.com/glslang/glslang.js');\n\n          case 4:\n            glslang = window.glslang('https://preview.babylonjs.com/glslang/glslang.wasm');\n            return _context.abrupt(\"return\", glslang);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _ref.apply(this, arguments);\n}\n//# sourceMappingURL=glslang.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isWindowObjectExist = isWindowObjectExist;\nexports.loadScript = loadScript;\nexports.loadScriptAsync = loadScriptAsync;\n\nfunction isWindowObjectExist() {\n  return typeof window !== 'undefined';\n}\n\nfunction loadScript(scriptUrl, onSuccess, onError, scriptId) {\n  if (!isWindowObjectExist()) {\n    return;\n  }\n\n  var head = document.getElementsByTagName('head')[0];\n  var script = document.createElement('script');\n  script.setAttribute('type', 'text/javascript');\n  script.setAttribute('src', scriptUrl);\n\n  if (scriptId) {\n    script.id = scriptId;\n  }\n\n  script.onload = function () {\n    if (onSuccess) {\n      onSuccess();\n    }\n  };\n\n  script.onerror = function (e) {\n    if (onError) {\n      onError(\"Unable to load script '\".concat(scriptUrl, \"'\"), e);\n    }\n  };\n\n  head.appendChild(script);\n}\n\nfunction loadScriptAsync(scriptUrl, scriptId) {\n  return new Promise(function (resolve, reject) {\n    loadScript(scriptUrl, function () {\n      resolve();\n    }, function (message, exception) {\n      reject(exception);\n    });\n  });\n}\n//# sourceMappingURL=dom.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar WebGPUAttribute = /*#__PURE__*/function () {\n  function WebGPUAttribute(engine, options) {\n    (0, _classCallCheck2.default)(this, WebGPUAttribute);\n    this.engine = engine;\n    this.options = options;\n    this.attribute = void 0;\n    this.buffer = void 0;\n    var _options = options,\n        buffer = _options.buffer,\n        offset = _options.offset,\n        stride = _options.stride,\n        normalized = _options.normalized,\n        size = _options.size,\n        divisor = _options.divisor,\n        arrayStride = _options.arrayStride,\n        attributes = _options.attributes,\n        stepMode = _options.stepMode;\n    this.buffer = buffer;\n    this.attribute = {\n      buffer: buffer.get(),\n      offset: offset || 0,\n      stride: stride || 0,\n      normalized: normalized || false,\n      divisor: divisor || 0,\n      arrayStride: arrayStride || 0,\n      // @ts-ignore\n      attributes: attributes,\n      stepMode: stepMode || 'vertex'\n    };\n\n    if (size) {\n      this.attribute.size = size;\n    }\n  }\n\n  (0, _createClass2.default)(WebGPUAttribute, [{\n    key: \"get\",\n    value: function get() {\n      return this.attribute;\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(options) {\n      this.buffer.subData(options);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.buffer.destroy();\n    }\n  }]);\n  return WebGPUAttribute;\n}();\n\nexports.default = WebGPUAttribute;\n//# sourceMappingURL=WebGPUAttribute.js.map","\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar WebGPUConstants = _interopRequireWildcard(require(\"@webgpu/types/dist/constants\"));\n\nvar WebGPUBuffer = /*#__PURE__*/function () {\n  function WebGPUBuffer(engine, options) {\n    (0, _classCallCheck2.default)(this, WebGPUBuffer);\n    this.engine = engine;\n    this.options = options;\n    this.buffer = void 0;\n    var _options = options,\n        data = _options.data,\n        usage = _options.usage,\n        type = _options.type;\n    this.buffer = this.createBuffer(data instanceof Array ? new Float32Array(data) : data, // TODO: WebGL 和 WebGPU buffer usage 映射关系\n    usage || WebGPUConstants.BufferUsage.Vertex | WebGPUConstants.BufferUsage.CopyDst);\n  }\n\n  (0, _createClass2.default)(WebGPUBuffer, [{\n    key: \"get\",\n    value: function get() {\n      return this.buffer;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.buffer.destroy();\n    }\n  }, {\n    key: \"subData\",\n    value: function subData(_ref) {\n      var data = _ref.data,\n          offset = _ref.offset;\n      this.setSubData(this.buffer, offset, data instanceof Array ? new Float32Array(data) : data);\n    }\n  }, {\n    key: \"createBuffer\",\n    value: function createBuffer(view, flags) {\n      // @ts-ignore\n      var padding = view.byteLength % 4;\n      var verticesBufferDescriptor = {\n        // @ts-ignore\n        size: view.byteLength + padding,\n        usage: flags\n      };\n      var buffer = this.engine.device.createBuffer(verticesBufferDescriptor);\n      this.setSubData(buffer, 0, view);\n      return buffer;\n    }\n    /**\n     * 不同于 Babylon.js 的版本，使用最新的 GPUQueue.writeBuffer 方法\n     * @see https://gpuweb.github.io/gpuweb/#dom-gpuqueue-writebuffer\n     * 已废弃创建一个临时的 mapped buffer 用于拷贝数据 @see https://gpuweb.github.io/gpuweb/#GPUDevice-createBufferMapped\n     * @see https://github.com/gpuweb/gpuweb/blob/master/design/BufferOperations.md#updating-data-to-an-existing-buffer-like-webgls-buffersubdata\n     */\n\n  }, {\n    key: \"setSubData\",\n    value: function setSubData(destBuffer, destOffset, srcArrayBuffer) {\n      // deprecated API setSubData\n      // destBuffer.setSubData(0, srcArrayBuffer);\n      // deprecated API createBufferMapped\n      // use createBuffer & getMappedRange instead\n      // const [srcBuffer, arrayBuffer] = this.engine.device.createBufferMapped({\n      //   size: byteCount,\n      //   usage: WebGPUConstants.BufferUsage.CopySrc,\n      // });\n      var queue = _gWebgpuCore.isSafari ? // @ts-ignore\n      this.engine.device.getQueue() : this.engine.device.defaultQueue; // @ts-ignore\n\n      queue.writeBuffer(destBuffer, destOffset, srcArrayBuffer);\n    }\n  }]);\n  return WebGPUBuffer;\n}();\n\nexports.default = WebGPUBuffer;\n//# sourceMappingURL=WebGPUBuffer.js.map","\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar WebGPUConstants = _interopRequireWildcard(require(\"@webgpu/types/dist/constants\"));\n\nvar _isNumber = require(\"../utils/is-number\");\n\nvar _WebGPUBuffer = _interopRequireDefault(require(\"./WebGPUBuffer\"));\n\nvar WebGPUComputeModel = /*#__PURE__*/function () {\n  /**\n   * 用于后续渲染时动态更新\n   */\n  function WebGPUComputeModel(engine, context) {\n    (0, _classCallCheck2.default)(this, WebGPUComputeModel);\n    this.engine = engine;\n    this.context = context;\n    this.entity = (0, _gWebgpuCore.createEntity)();\n    this.uniformGPUBufferLayout = [];\n    this.uniformBuffer = void 0;\n    this.vertexBuffers = {};\n    this.outputBuffer = void 0;\n    this.bindGroupEntries = void 0;\n    this.bindGroup = void 0;\n    this.computePipeline = void 0;\n  }\n\n  (0, _createClass2.default)(WebGPUComputeModel, [{\n    key: \"init\",\n    value: function () {\n      var _init = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n        var _this = this;\n\n        var _yield$this$compileCo, computeStage, buffers, uniforms, bufferBindingIndex, offset, mergedUniformData;\n\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.compileComputePipelineStageDescriptor(this.context.shader);\n\n              case 2:\n                _yield$this$compileCo = _context.sent;\n                computeStage = _yield$this$compileCo.computeStage;\n                buffers = this.context.uniforms.filter(function (uniform) {\n                  return uniform.storageClass === _gWebgpuCore.STORAGE_CLASS.StorageBuffer;\n                });\n                uniforms = this.context.uniforms.filter(function (uniform) {\n                  return uniform.storageClass === _gWebgpuCore.STORAGE_CLASS.Uniform;\n                });\n                bufferBindingIndex = uniforms.length ? 1 : 0;\n                this.bindGroupEntries = [];\n\n                if (bufferBindingIndex) {\n                  offset = 0; // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n                  // we use std140 layout @see https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)\n\n                  mergedUniformData = [];\n                  uniforms.forEach(function (uniform) {\n                    if ((0, _isNumber.isNumber)(uniform.data)) {\n                      _this.uniformGPUBufferLayout.push({\n                        name: uniform.name,\n                        offset: offset\n                      });\n\n                      offset += 4; // @ts-ignore\n\n                      mergedUniformData.push(uniform.data);\n                    } else {\n                      var _uniform$data;\n\n                      // @ts-ignore\n                      var originDataLength = ((_uniform$data = uniform.data) === null || _uniform$data === void 0 ? void 0 : _uniform$data.length) || 1;\n\n                      if (originDataLength === 3) {\n                        // vec3 -> vec4\n                        // @see http://ptgmedia.pearsoncmg.com/images/9780321552624/downloads/0321552628_AppL.pdf\n                        originDataLength = 4; // @ts-ignore\n\n                        uniform.data.push(0);\n                      } // 4 elements per block/line\n\n\n                      var padding = offset / 4 % 4;\n\n                      if (padding > 0) {\n                        var space = 4 - padding;\n\n                        if (originDataLength > 1 && originDataLength <= space) {\n                          if (originDataLength === 2) {\n                            if (space === 3) {\n                              offset += 4;\n                              mergedUniformData.push(0);\n                            } // @ts-ignore\n\n\n                            mergedUniformData.push.apply(mergedUniformData, (0, _toConsumableArray2.default)(uniform.data));\n\n                            _this.uniformGPUBufferLayout.push({\n                              name: uniform.name,\n                              offset: offset\n                            });\n                          }\n                        } else {\n                          for (var i = 0; i < space; i++) {\n                            offset += 4;\n                            mergedUniformData.push(0);\n                          } // @ts-ignore\n\n\n                          mergedUniformData.push.apply(mergedUniformData, (0, _toConsumableArray2.default)(uniform.data));\n\n                          _this.uniformGPUBufferLayout.push({\n                            name: uniform.name,\n                            offset: offset\n                          });\n                        }\n                      }\n\n                      offset += 4 * originDataLength;\n                    }\n                  });\n                  this.uniformBuffer = new _WebGPUBuffer.default(this.engine, {\n                    // TODO: 处理 Struct 和 boolean\n                    // @ts-ignore\n                    data: mergedUniformData instanceof Array ? // @ts-ignore\n                    new Float32Array(mergedUniformData) : mergedUniformData,\n                    usage: WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst\n                  });\n                  this.bindGroupEntries.push({\n                    binding: 0,\n                    resource: {\n                      buffer: this.uniformBuffer.get()\n                    }\n                  });\n                } // create GPUBuffers for storeage buffers\n\n\n                buffers.forEach(function (buffer) {\n                  if (buffer.data !== null) {\n                    if (buffer.type === _gWebgpuCore.AST_TOKEN_TYPES.Vector4FloatArray || buffer.type === _gWebgpuCore.AST_TOKEN_TYPES.FloatArray) {\n                      var gpuBuffer;\n\n                      if (buffer.name === _this.context.output.name) {\n                        gpuBuffer = new _WebGPUBuffer.default(_this.engine, {\n                          // @ts-ignore\n                          data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n                          usage: WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.CopySrc\n                        });\n                        _this.outputBuffer = gpuBuffer;\n                        _this.context.output = {\n                          name: buffer.name,\n                          // @ts-ignore\n                          length: isFinite(Number(buffer.data)) ? 1 : buffer.data.length,\n                          typedArrayConstructor: Float32Array,\n                          gpuBuffer: gpuBuffer.get()\n                        };\n                      } else {\n                        if (buffer.isReferer) {\n                          // @ts-ignore\n                          if (buffer.data.model && buffer.data.model.outputBuffer) {\n                            // @ts-ignore\n                            gpuBuffer = buffer.data.model.outputBuffer;\n                          } else {// referred kernel haven't been executed\n                          }\n                        } else {\n                          gpuBuffer = new _WebGPUBuffer.default(_this.engine, {\n                            // @ts-ignore\n                            data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n                            usage: WebGPUConstants.BufferUsage.Storage | WebGPUConstants.BufferUsage.CopyDst | WebGPUConstants.BufferUsage.CopySrc\n                          });\n                        }\n                      } // @ts-ignore\n\n\n                      _this.vertexBuffers[buffer.name] = gpuBuffer;\n\n                      _this.bindGroupEntries.push({\n                        binding: bufferBindingIndex,\n                        resource: {\n                          name: buffer.name,\n                          refer: gpuBuffer ? undefined : buffer.data,\n                          // @ts-ignore\n                          buffer: gpuBuffer ? gpuBuffer.get() : undefined\n                        }\n                      });\n\n                      bufferBindingIndex++;\n                    }\n                  }\n                }); // create compute pipeline layout\n\n                this.computePipeline = this.engine.device.createComputePipeline({\n                  computeStage: computeStage\n                });\n                console.log(this.bindGroupEntries);\n                this.bindGroup = this.engine.device.createBindGroup({\n                  layout: this.computePipeline.getBindGroupLayout(0),\n                  entries: this.bindGroupEntries\n                });\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n\n      if (this.uniformBuffer) {\n        this.uniformBuffer.destroy();\n      }\n\n      Object.keys(this.vertexBuffers).forEach(function (bufferName) {\n        return _this2.vertexBuffers[bufferName].destroy();\n      });\n    }\n  }, {\n    key: \"readData\",\n    value: function () {\n      var _readData = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {\n        var output, length, typedArrayConstructor, gpuBuffer, byteCount, gpuReadBuffer, encoder, queue, arraybuffer, typedArray;\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                output = this.context.output;\n\n                if (!output) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                length = output.length, typedArrayConstructor = output.typedArrayConstructor, gpuBuffer = output.gpuBuffer;\n\n                if (!gpuBuffer) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                // await gpuBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n                // const arraybuffer = gpuBuffer.getMappedRange();\n                // let arraybuffer;\n                // if (isSafari) {\n                //   arraybuffer = await gpuBuffer.mapReadAsync();\n                // } else {\n                byteCount = length * typedArrayConstructor.BYTES_PER_ELEMENT; // @see https://developers.google.com/web/updates/2019/08/get-started-with-gpu-compute-on-the-web\n\n                gpuReadBuffer = this.engine.device.createBuffer({\n                  size: byteCount,\n                  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n                });\n                encoder = this.engine.device.createCommandEncoder();\n                encoder.copyBufferToBuffer(gpuBuffer, 0, gpuReadBuffer, 0, byteCount);\n                queue = _gWebgpuCore.isSafari ? // @ts-ignore\n                this.engine.device.getQueue() : this.engine.device.defaultQueue;\n                queue.submit([encoder.finish()]);\n                _context2.next = 12;\n                return gpuReadBuffer.mapAsync(WebGPUConstants.MapMode.Read);\n\n              case 12:\n                arraybuffer = gpuReadBuffer.getMappedRange();\n                typedArray = new typedArrayConstructor(arraybuffer.slice(0));\n                gpuReadBuffer.unmap();\n                return _context2.abrupt(\"return\", typedArray);\n\n              case 16:\n                return _context2.abrupt(\"return\", new Float32Array());\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function readData() {\n        return _readData.apply(this, arguments);\n      }\n\n      return readData;\n    }()\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (this.engine.currentComputePass) {\n        var _this$engine$currentC;\n\n        this.engine.currentComputePass.setPipeline(this.computePipeline); // this.bindGroupEntries.forEach((entry) => {\n        //   if (!entry.resource.buffer) {\n        //     // get referred kernel's output\n        //     const gpuBuffer = (entry.resource.refer.model as WebGPUComputeModel)\n        //       .outputBuffer;\n        //     this.vertexBuffers[entry.resource.name] = gpuBuffer;\n        //     entry.resource.buffer = gpuBuffer.get();\n        //   }\n        // });\n        // const bindGroup = this.engine.device.createBindGroup({\n        //   layout: this.computePipeline.getBindGroupLayout(0),\n        //   entries: this.bindGroupEntries,\n        // });\n\n        this.engine.currentComputePass.setBindGroup(0, this.bindGroup);\n\n        (_this$engine$currentC = this.engine.currentComputePass).dispatch.apply(_this$engine$currentC, (0, _toConsumableArray2.default)(this.context.dispatch));\n      }\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(bufferName, data) {\n      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var buffer = this.vertexBuffers[bufferName];\n\n      if (buffer) {\n        buffer.subData({\n          data: data,\n          offset: offset\n        });\n      }\n    }\n  }, {\n    key: \"updateUniform\",\n    value: function updateUniform(uniformName, data) {\n      var layout = this.uniformGPUBufferLayout.find(function (l) {\n        return l.name === uniformName;\n      });\n\n      if (layout) {\n        this.uniformBuffer.subData({\n          data: Number.isFinite(data) ? new Float32Array([data]) : new Float32Array(data),\n          offset: layout.offset\n        });\n      }\n    }\n  }, {\n    key: \"confirmInput\",\n    value: function confirmInput(model, inputName) {\n      // copy output GPUBuffer of kernel\n      var inputBuffer = this.vertexBuffers[inputName];\n      var outputBuffer = model.outputBuffer;\n\n      if (inputBuffer && outputBuffer && inputBuffer !== outputBuffer) {\n        var encoder = this.engine.device.createCommandEncoder();\n        var _context$output = model.context.output,\n            length = _context$output.length,\n            typedArrayConstructor = _context$output.typedArrayConstructor;\n        var byteCount = length * typedArrayConstructor.BYTES_PER_ELEMENT;\n        encoder.copyBufferToBuffer(outputBuffer.get(), 0, inputBuffer.get(), 0, byteCount);\n        var queue = _gWebgpuCore.isSafari ? // @ts-ignore\n        this.engine.device.getQueue() : this.engine.device.defaultQueue;\n        queue.submit([encoder.finish()]);\n      }\n    }\n  }, {\n    key: \"compileShaderToSpirV\",\n    value: function compileShaderToSpirV(source, type, shaderVersion) {\n      return this.compileRawShaderToSpirV(shaderVersion + source, type);\n    }\n  }, {\n    key: \"compileRawShaderToSpirV\",\n    value: function compileRawShaderToSpirV(source, type) {\n      return this.engine.glslang.compileGLSL(source, type);\n    }\n  }, {\n    key: \"compileComputePipelineStageDescriptor\",\n    value: function () {\n      var _compileComputePipelineStageDescriptor = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(computeCode) {\n        var computeShader, shaderVersion;\n        return _regenerator.default.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                computeShader = computeCode;\n                shaderVersion = '#version 450\\n';\n\n                if (this.engine.options.useWGSL) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                _context3.next = 5;\n                return this.compileShaderToSpirV(computeCode, 'compute', shaderVersion);\n\n              case 5:\n                computeShader = _context3.sent;\n\n              case 6:\n                return _context3.abrupt(\"return\", {\n                  computeStage: {\n                    module: this.engine.device.createShaderModule({\n                      code: computeShader,\n                      // @ts-ignore\n                      isWHLSL: _gWebgpuCore.isSafari\n                    }),\n                    entryPoint: 'main'\n                  }\n                });\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function compileComputePipelineStageDescriptor(_x) {\n        return _compileComputePipelineStageDescriptor.apply(this, arguments);\n      }\n\n      return compileComputePipelineStageDescriptor;\n    }()\n  }]);\n  return WebGPUComputeModel;\n}();\n\nexports.default = WebGPUComputeModel;\n//# sourceMappingURL=WebGPUComputeModel.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNumber = isNumber;\n\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\n//# sourceMappingURL=is-number.js.map","\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar WebGPUConstants = _interopRequireWildcard(require(\"@webgpu/types/dist/constants\"));\n\nvar _WebGPUBuffer = _interopRequireDefault(require(\"./WebGPUBuffer\"));\n\nvar WebGPUElements = /*#__PURE__*/function () {\n  function WebGPUElements(engine, options) {\n    (0, _classCallCheck2.default)(this, WebGPUElements);\n    this.engine = engine;\n    this.options = options;\n    this.indexCount = void 0;\n    this.buffer = void 0;\n    var _options = options,\n        data = _options.data,\n        usage = _options.usage,\n        type = _options.type,\n        count = _options.count;\n    this.indexCount = count || 0;\n    this.buffer = new _WebGPUBuffer.default(engine, {\n      // @ts-ignore\n      data: data instanceof Array ? new Uint16Array(data) : data,\n      usage: WebGPUConstants.BufferUsage.Index | WebGPUConstants.BufferUsage.CopyDst\n    });\n  }\n\n  (0, _createClass2.default)(WebGPUElements, [{\n    key: \"get\",\n    value: function get() {\n      return this.buffer;\n    }\n  }, {\n    key: \"subData\",\n    value: function subData(options) {\n      this.buffer.subData(options);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.buffer.destroy();\n    }\n  }]);\n  return WebGPUElements;\n}();\n\nexports.default = WebGPUElements;\n//# sourceMappingURL=WebGPUElements.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar WebGPUFramebuffer = /*#__PURE__*/function () {\n  function WebGPUFramebuffer(engine, options) {\n    (0, _classCallCheck2.default)(this, WebGPUFramebuffer);\n    this.engine = engine;\n    this.options = options;\n    this.colorTexture = void 0;\n    this.depthTexture = void 0;\n    this.width = 0;\n    this.height = 0;\n    var _options = options,\n        width = _options.width,\n        height = _options.height,\n        color = _options.color,\n        colors = _options.colors,\n        depth = _options.depth,\n        stencil = _options.stencil;\n\n    if (color) {\n      this.colorTexture = color;\n    }\n\n    if (depth) {\n      this.depthTexture = depth;\n    } // TODO: depth & stencil\n\n  }\n\n  (0, _createClass2.default)(WebGPUFramebuffer, [{\n    key: \"get\",\n    value: function get() {\n      var _this$colorTexture, _this$depthTexture;\n\n      return {\n        color: (_this$colorTexture = this.colorTexture) === null || _this$colorTexture === void 0 ? void 0 : _this$colorTexture.get(),\n        depth: (_this$depthTexture = this.depthTexture) === null || _this$depthTexture === void 0 ? void 0 : _this$depthTexture.get()\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this$colorTexture2, _this$depthTexture2;\n\n      (_this$colorTexture2 = this.colorTexture) === null || _this$colorTexture2 === void 0 ? void 0 : _this$colorTexture2.destroy();\n      (_this$depthTexture2 = this.depthTexture) === null || _this$depthTexture2 === void 0 ? void 0 : _this$depthTexture2.destroy();\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(_ref) {\n      var width = _ref.width,\n          height = _ref.height;\n\n      if (width !== this.width || height !== this.height) {\n        var _this$colorTexture3, _this$depthTexture3;\n\n        (_this$colorTexture3 = this.colorTexture) === null || _this$colorTexture3 === void 0 ? void 0 : _this$colorTexture3.resize({\n          width: width,\n          height: height\n        });\n        (_this$depthTexture3 = this.depthTexture) === null || _this$depthTexture3 === void 0 ? void 0 : _this$depthTexture3.resize({\n          width: width,\n          height: height\n        });\n      }\n\n      this.width = width;\n      this.height = height;\n    }\n  }]);\n  return WebGPUFramebuffer;\n}();\n\nexports.default = WebGPUFramebuffer;\n//# sourceMappingURL=WebGPUFramebuffer.js.map","\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar WebGPUConstants = _interopRequireWildcard(require(\"@webgpu/types/dist/constants\"));\n\nvar _uniform = require(\"../utils/uniform\");\n\nvar _constants2 = require(\"./constants\");\n\nvar _WebGPUBuffer = _interopRequireDefault(require(\"./WebGPUBuffer\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// @ts-ignore\nfunction concatenate(resultConstructor) {\n  var totalLength = 0;\n\n  for (var _len = arguments.length, arrays = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    arrays[_key - 1] = arguments[_key];\n  }\n\n  for (var _i = 0, _arrays = arrays; _i < _arrays.length; _i++) {\n    var arr = _arrays[_i];\n    totalLength += arr.length;\n  }\n\n  var result = new resultConstructor(totalLength);\n  var offset = 0;\n\n  for (var _i2 = 0, _arrays2 = arrays; _i2 < _arrays2.length; _i2++) {\n    var _arr = _arrays2[_i2];\n    result.set(_arr, offset);\n    offset += _arr.length;\n  }\n\n  return result;\n}\n\nvar WebGPUModel = /*#__PURE__*/function () {\n  /**\n   * 用于后续渲染时动态更新\n   */\n\n  /**\n   * vertex\n   */\n\n  /**\n   * indices's buffer\n   */\n  function WebGPUModel(engine, options) {\n    (0, _classCallCheck2.default)(this, WebGPUModel);\n    this.engine = engine;\n    this.options = options;\n    this.pipelineLayout = void 0;\n    this.renderPipeline = void 0;\n    this.uniformsBindGroupLayout = void 0;\n    this.uniformBindGroup = void 0;\n    this.uniformBuffer = void 0;\n    this.uniforms = {};\n    this.uniformGPUBufferLayout = [];\n    this.attributeCache = {};\n    this.indexBuffer = void 0;\n    this.indexCount = void 0;\n  }\n\n  (0, _createClass2.default)(WebGPUModel, [{\n    key: \"init\",\n    value: function () {\n      var _init = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n        var _this = this;\n\n        var _this$options, vs, fs, attributes, uniforms, primitive, count, elements, depth, blend, stencil, cull, instances, _yield$this$compilePi, vertexStage, fragmentStage, vertexState, descriptor;\n\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$options = this.options, vs = _this$options.vs, fs = _this$options.fs, attributes = _this$options.attributes, uniforms = _this$options.uniforms, primitive = _this$options.primitive, count = _this$options.count, elements = _this$options.elements, depth = _this$options.depth, blend = _this$options.blend, stencil = _this$options.stencil, cull = _this$options.cull, instances = _this$options.instances; // build shaders first\n\n                _context.next = 3;\n                return this.compilePipelineStageDescriptor(vs, fs, null);\n\n              case 3:\n                _yield$this$compilePi = _context.sent;\n                vertexStage = _yield$this$compilePi.vertexStage;\n                fragmentStage = _yield$this$compilePi.fragmentStage;\n\n                if (uniforms) {\n                  // create uniform bind groups & layout\n                  this.buildUniformBindGroup(uniforms);\n                }\n\n                if (elements) {\n                  this.indexBuffer = elements.get();\n                  this.indexCount = elements.indexCount;\n                } // TODO: instanced array\n\n\n                vertexState = {\n                  vertexBuffers: Object.keys(attributes).map(function (attributeName, i) {\n                    var attribute = attributes[attributeName];\n\n                    var _attribute$get = attribute.get(),\n                        arrayStride = _attribute$get.arrayStride,\n                        stepMode = _attribute$get.stepMode,\n                        ats = _attribute$get.attributes;\n\n                    _this.attributeCache[attributeName] = attribute;\n                    return {\n                      arrayStride: arrayStride,\n                      stepMode: stepMode,\n                      attributes: ats\n                    };\n                  })\n                };\n                descriptor = {\n                  sampleCount: this.engine.mainPassSampleCount,\n                  primitiveTopology: _constants2.primitiveMap[primitive || _gWebgpuCore.gl.TRIANGLES],\n                  rasterizationState: _objectSpread(_objectSpread({}, this.getDefaultRasterizationStateDescriptor()), {}, {\n                    // TODO: support frontface\n                    cullMode: (0, _constants2.getCullMode)({\n                      cull: cull\n                    })\n                  }),\n                  depthStencilState: (0, _constants2.getDepthStencilStateDescriptor)({\n                    depth: depth,\n                    stencil: stencil\n                  }),\n                  colorStates: (0, _constants2.getColorStateDescriptors)({\n                    blend: blend\n                  }, this.engine.options.swapChainFormat),\n                  layout: this.pipelineLayout,\n                  vertexStage: vertexStage,\n                  fragmentStage: fragmentStage,\n                  vertexState: vertexState\n                }; // create pipeline\n\n                this.renderPipeline = this.engine.device.createRenderPipeline(descriptor);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"addUniforms\",\n    value: function addUniforms(uniforms) {\n      this.uniforms = _objectSpread(_objectSpread({}, this.uniforms), (0, _uniform.extractUniforms)(uniforms));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(options) {\n      var _this2 = this;\n\n      var renderPass = this.engine.getCurrentRenderPass();\n\n      var uniforms = _objectSpread(_objectSpread({}, this.uniforms), (0, _uniform.extractUniforms)(options.uniforms || {}));\n\n      var bindGroupBindings = []; // TODO: uniform 发生修改\n\n      Object.keys(uniforms).forEach(function (uniformName) {\n        var type = (0, _typeof2.default)(uniforms[uniformName]);\n\n        if (type === 'boolean' || type === 'number' || Array.isArray(uniforms[uniformName]) || // @ts-ignore\n        uniforms[uniformName].BYTES_PER_ELEMENT) {\n          var _this2$uniformGPUBuff;\n\n          var offset = (_this2$uniformGPUBuff = _this2.uniformGPUBufferLayout.find(function (_ref) {\n            var name = _ref.name;\n            return name === uniformName;\n          })) === null || _this2$uniformGPUBuff === void 0 ? void 0 : _this2$uniformGPUBuff.offset;\n\n          if (offset !== null) {\n            _this2.uniformBuffer.subData({\n              // @ts-ignore\n              data: uniforms[uniformName],\n              // @ts-ignore\n              offset: offset\n            });\n          }\n        } else {\n          var _this2$uniformGPUBuff2;\n\n          var _offset = (_this2$uniformGPUBuff2 = _this2.uniformGPUBufferLayout.find(function (_ref2) {\n            var name = _ref2.name;\n            return name === uniformName;\n          })) === null || _this2$uniformGPUBuff2 === void 0 ? void 0 : _this2$uniformGPUBuff2.offset;\n\n          if (_offset !== null) {\n            var textureOrFramebuffer = uniforms[uniformName].get();\n\n            var _ref3 = // @ts-ignore\n            textureOrFramebuffer.color || textureOrFramebuffer,\n                texture = _ref3.texture,\n                sampler = _ref3.sampler;\n\n            if (sampler) {\n              bindGroupBindings.push({\n                // @ts-ignore\n                binding: _offset,\n                resource: sampler\n              }); // @ts-ignore\n\n              _offset++;\n            }\n\n            bindGroupBindings.push({\n              // @ts-ignore\n              binding: _offset,\n              resource: texture.createView()\n            });\n          }\n        }\n      });\n\n      if (this.uniformBuffer) {\n        bindGroupBindings[0] = {\n          binding: 0,\n          resource: {\n            buffer: this.uniformBuffer.get() // 返回 GPUBuffer 原生对象\n\n          }\n        };\n      }\n\n      this.uniformBindGroup = this.engine.device.createBindGroup({\n        layout: this.uniformsBindGroupLayout,\n        entries: bindGroupBindings\n      });\n\n      if (this.renderPipeline) {\n        renderPass.setPipeline(this.renderPipeline);\n      }\n\n      renderPass.setBindGroup(0, this.uniformBindGroup);\n\n      if (this.indexBuffer) {\n        renderPass.setIndexBuffer(this.indexBuffer.get(), WebGPUConstants.IndexFormat.Uint32, 0);\n      }\n\n      Object.keys(this.attributeCache).forEach(function (attributeName, i) {\n        renderPass.setVertexBuffer(0 + i, _this2.attributeCache[attributeName].get().buffer, 0);\n      }); // renderPass.draw(verticesCount, instancesCount, verticesStart, 0);\n\n      if (this.indexBuffer) {\n        renderPass.drawIndexed(this.indexCount, this.options.instances || 1, 0, 0, 0);\n      } else {\n        renderPass.draw(this.options.count || 0, this.options.instances || 0, 0, 0);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"compilePipelineStageDescriptor\",\n    value: function () {\n      var _compilePipelineStageDescriptor = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(vertexCode, fragmentCode, defines) {\n        var shaderVersion, vertexShader, fragmentShader;\n        return _regenerator.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                shaderVersion = '#version 450\\n';\n                vertexShader = vertexCode;\n                fragmentShader = fragmentCode;\n\n                if (this.engine.options.useWGSL) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                _context2.next = 6;\n                return this.compileShaderToSpirV(vertexCode, 'vertex', shaderVersion);\n\n              case 6:\n                vertexShader = _context2.sent;\n                _context2.next = 9;\n                return this.compileShaderToSpirV(fragmentCode, 'fragment', shaderVersion);\n\n              case 9:\n                fragmentShader = _context2.sent;\n\n              case 10:\n                return _context2.abrupt(\"return\", this.createPipelineStageDescriptor(vertexShader, fragmentShader));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function compilePipelineStageDescriptor(_x, _x2, _x3) {\n        return _compilePipelineStageDescriptor.apply(this, arguments);\n      }\n\n      return compilePipelineStageDescriptor;\n    }()\n  }, {\n    key: \"compileShaderToSpirV\",\n    value: function compileShaderToSpirV(source, type, shaderVersion) {\n      return this.compileRawShaderToSpirV(shaderVersion + source, type);\n    }\n  }, {\n    key: \"compileRawShaderToSpirV\",\n    value: function compileRawShaderToSpirV(source, type) {\n      return this.engine.glslang.compileGLSL(source, type);\n    }\n  }, {\n    key: \"createPipelineStageDescriptor\",\n    value: function createPipelineStageDescriptor(vertexShader, fragmentShader) {\n      return {\n        vertexStage: {\n          module: this.engine.device.createShaderModule({\n            code: vertexShader,\n            // @ts-ignore\n            isWHLSL: _gWebgpuCore.isSafari\n          }),\n          entryPoint: 'main'\n        },\n        fragmentStage: {\n          module: this.engine.device.createShaderModule({\n            code: fragmentShader,\n            // @ts-ignore\n            isWHLSL: _gWebgpuCore.isSafari\n          }),\n          entryPoint: 'main'\n        }\n      };\n    }\n    /**\n     * @see https://gpuweb.github.io/gpuweb/#rasterization-state\n     */\n\n  }, {\n    key: \"getDefaultRasterizationStateDescriptor\",\n    value: function getDefaultRasterizationStateDescriptor() {\n      return {\n        frontFace: WebGPUConstants.FrontFace.CCW,\n        cullMode: WebGPUConstants.CullMode.None,\n        depthBias: 0,\n        depthBiasSlopeScale: 0,\n        depthBiasClamp: 0\n      };\n    }\n  }, {\n    key: \"buildUniformBindGroup\",\n    value: function buildUniformBindGroup(uniforms) {\n      var _this3 = this;\n\n      var offset = 0; // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n\n      var mergedUniformData = concatenate.apply(void 0, [Float32Array].concat((0, _toConsumableArray2.default)(Object.keys(uniforms).map(function (uniformName) {\n        if (uniforms[uniformName]) {\n          _this3.uniformGPUBufferLayout.push({\n            name: uniformName,\n            offset: offset\n          }); // @ts-ignore\n\n\n          offset += (uniforms[uniformName].length || 1) * 4;\n          return uniforms[uniformName];\n        } else {\n          // texture & framebuffer\n          return [];\n        }\n      }))));\n      var entries = [];\n      var hasUniform = false;\n\n      if (mergedUniformData.length) {\n        hasUniform = true; // TODO: 所有 uniform 绑定到 slot 0，通过解析 Shader 代码判定可见性\n\n        entries.push({\n          // TODO: 暂时都绑定到 slot 0\n          binding: 0,\n          visibility: WebGPUConstants.ShaderStage.Fragment | WebGPUConstants.ShaderStage.Vertex,\n          // TODO: 暂时 VS 和 FS 都可见\n          type: WebGPUConstants.BindingType.UniformBuffer\n        });\n      } // 声明 texture & sampler\n\n\n      Object.keys(uniforms).filter(function (uniformName) {\n        return uniforms[uniformName] === null;\n      }).forEach(function (uniformName, i) {\n        _this3.uniformGPUBufferLayout.push({\n          name: uniformName,\n          offset: i * 2 + (hasUniform ? 1 : 0)\n        });\n\n        entries.push({\n          // Sampler\n          binding: i * 2 + (hasUniform ? 1 : 0),\n          visibility: WebGPUConstants.ShaderStage.Fragment,\n          type: WebGPUConstants.BindingType.Sampler\n        }, {\n          // Texture view\n          binding: i * 2 + (hasUniform ? 1 : 0) + 1,\n          visibility: WebGPUConstants.ShaderStage.Fragment,\n          type: WebGPUConstants.BindingType.SampledTexture\n        });\n      });\n      this.uniformsBindGroupLayout = this.engine.device.createBindGroupLayout({\n        // 最新 API 0.0.22 版本使用 entries。Chrome Canary 84.0.4110.0 已实现。\n        // 使用 bindings 会报 Warning: GPUBindGroupLayoutDescriptor.bindings is deprecated: renamed to entries\n        // @see https://github.com/antvis/GWebGPUEngine/issues/5\n        entries: entries\n      });\n      this.pipelineLayout = this.engine.device.createPipelineLayout({\n        bindGroupLayouts: [this.uniformsBindGroupLayout]\n      });\n\n      if (hasUniform) {\n        this.uniformBuffer = new _WebGPUBuffer.default(this.engine, {\n          // TODO: 处理 Struct 和 boolean\n          // @ts-ignore\n          data: mergedUniformData instanceof Array ? // @ts-ignore\n          new Float32Array(mergedUniformData) : mergedUniformData,\n          usage: WebGPUConstants.BufferUsage.Uniform | WebGPUConstants.BufferUsage.CopyDst\n        });\n      }\n    }\n  }]);\n  return WebGPUModel;\n}();\n\nexports.default = WebGPUModel;\n//# sourceMappingURL=WebGPUModel.js.map","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCullMode = getCullMode;\nexports.getDepthStencilStateDescriptor = getDepthStencilStateDescriptor;\nexports.getColorStateDescriptors = getColorStateDescriptors;\nexports.wrapModeMap = exports.filterMap = exports.formatMap = exports.blendFuncMap = exports.blendEquationMap = exports.depthFuncMap = exports.primitiveMap = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar WebGPUConstants = _interopRequireWildcard(require(\"@webgpu/types/dist/constants\"));\n\nvar _primitiveMap, _depthFuncMap, _blendEquationMap, _blendFuncMap, _formatMap, _filterMap, _wrapModeMap;\n\n// WebGPU 不支持 LINE_LOOP & TRIANGLE_FAN\nvar primitiveMap = (_primitiveMap = {}, (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.POINTS, WebGPUConstants.PrimitiveTopology.PointList), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.LINES, WebGPUConstants.PrimitiveTopology.LineList), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.LINE_LOOP, WebGPUConstants.PrimitiveTopology.LineList), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.LINE_STRIP, WebGPUConstants.PrimitiveTopology.LineStrip), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.TRIANGLES, WebGPUConstants.PrimitiveTopology.TriangleList), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.TRIANGLE_FAN, WebGPUConstants.PrimitiveTopology.TriangleList), (0, _defineProperty2.default)(_primitiveMap, _gWebgpuCore.gl.TRIANGLE_STRIP, WebGPUConstants.PrimitiveTopology.TriangleStrip), _primitiveMap);\nexports.primitiveMap = primitiveMap;\nvar depthFuncMap = (_depthFuncMap = {}, (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.NEVER, WebGPUConstants.CompareFunction.Never), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.ALWAYS, WebGPUConstants.CompareFunction.Always), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.LESS, WebGPUConstants.CompareFunction.Less), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.LEQUAL, WebGPUConstants.CompareFunction.LessEqual), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.GREATER, WebGPUConstants.CompareFunction.Greater), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.GEQUAL, WebGPUConstants.CompareFunction.GreaterEqual), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.EQUAL, WebGPUConstants.CompareFunction.Equal), (0, _defineProperty2.default)(_depthFuncMap, _gWebgpuCore.gl.NOTEQUAL, WebGPUConstants.CompareFunction.NotEqual), _depthFuncMap);\nexports.depthFuncMap = depthFuncMap;\nvar blendEquationMap = (_blendEquationMap = {}, (0, _defineProperty2.default)(_blendEquationMap, _gWebgpuCore.gl.FUNC_ADD, WebGPUConstants.BlendOperation.Add), (0, _defineProperty2.default)(_blendEquationMap, _gWebgpuCore.gl.MIN_EXT, WebGPUConstants.BlendOperation.Min), (0, _defineProperty2.default)(_blendEquationMap, _gWebgpuCore.gl.MAX_EXT, WebGPUConstants.BlendOperation.Max), (0, _defineProperty2.default)(_blendEquationMap, _gWebgpuCore.gl.FUNC_SUBTRACT, WebGPUConstants.BlendOperation.Subtract), (0, _defineProperty2.default)(_blendEquationMap, _gWebgpuCore.gl.FUNC_REVERSE_SUBTRACT, WebGPUConstants.BlendOperation.ReverseSubtract), _blendEquationMap); // @see https://gpuweb.github.io/gpuweb/#blend-state\n// 不支持 'constant alpha' 和 'one minus constant alpha'\n\nexports.blendEquationMap = blendEquationMap;\nvar blendFuncMap = (_blendFuncMap = {}, (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ZERO, WebGPUConstants.BlendFactor.Zero), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE, WebGPUConstants.BlendFactor.One), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.SRC_COLOR, WebGPUConstants.BlendFactor.SrcColor), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE_MINUS_SRC_COLOR, WebGPUConstants.BlendFactor.OneMinusSrcColor), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.SRC_ALPHA, WebGPUConstants.BlendFactor.SrcAlpha), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE_MINUS_SRC_ALPHA, WebGPUConstants.BlendFactor.OneMinusSrcAlpha), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.DST_COLOR, WebGPUConstants.BlendFactor.DstColor), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE_MINUS_DST_COLOR, WebGPUConstants.BlendFactor.OneMinusDstColor), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.DST_ALPHA, WebGPUConstants.BlendFactor.DstAlpha), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE_MINUS_DST_ALPHA, WebGPUConstants.BlendFactor.OneMinusDstAlpha), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.CONSTANT_COLOR, WebGPUConstants.BlendFactor.BlendColor), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.ONE_MINUS_CONSTANT_COLOR, WebGPUConstants.BlendFactor.OneMinusBlendColor), (0, _defineProperty2.default)(_blendFuncMap, _gWebgpuCore.gl.SRC_ALPHA_SATURATE, WebGPUConstants.BlendFactor.SrcAlphaSaturated), _blendFuncMap); // @see https://gpuweb.github.io/gpuweb/#texture-formats\n\nexports.blendFuncMap = blendFuncMap;\nvar formatMap = (_formatMap = {}, (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.ALPHA, 'r8unorm'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.RGBA, 'rgba8unorm'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.DEPTH_COMPONENT, 'depth32float'), (0, _defineProperty2.default)(_formatMap, _gWebgpuCore.gl.DEPTH_STENCIL, 'depth24plus-stencil8'), _formatMap); // @see https://gpuweb.github.io/gpuweb/#enumdef-gpufiltermode\n\nexports.formatMap = formatMap;\nvar filterMap = (_filterMap = {}, (0, _defineProperty2.default)(_filterMap, _gWebgpuCore.gl.NEAREST, 'nearest'), (0, _defineProperty2.default)(_filterMap, _gWebgpuCore.gl.LINEAR, 'linear'), _filterMap); // @see https://gpuweb.github.io/gpuweb/#enumdef-gpuaddressmode\n\nexports.filterMap = filterMap;\nvar wrapModeMap = (_wrapModeMap = {}, (0, _defineProperty2.default)(_wrapModeMap, _gWebgpuCore.gl.REPEAT, 'repeat'), (0, _defineProperty2.default)(_wrapModeMap, _gWebgpuCore.gl.CLAMP_TO_EDGE, 'clamp-to-edge'), (0, _defineProperty2.default)(_wrapModeMap, _gWebgpuCore.gl.MIRRORED_REPEAT, 'mirror-repeat'), _wrapModeMap);\nexports.wrapModeMap = wrapModeMap;\n\nfunction getCullMode(_ref) {\n  var cull = _ref.cull;\n\n  if (!cull || !cull.enable) {\n    return WebGPUConstants.CullMode.None;\n  }\n\n  if (cull.face) {\n    return cull.face === _gWebgpuCore.gl.FRONT ? WebGPUConstants.CullMode.Front : WebGPUConstants.CullMode.Back;\n  }\n}\n\nfunction getDepthStencilStateDescriptor(_ref2) {\n  var depth = _ref2.depth,\n      stencil = _ref2.stencil;\n  // TODO: stencil\n  var stencilFrontBack = {\n    compare: WebGPUConstants.CompareFunction.Always,\n    depthFailOp: WebGPUConstants.StencilOperation.Keep,\n    failOp: WebGPUConstants.StencilOperation.Keep,\n    passOp: WebGPUConstants.StencilOperation.Keep\n  };\n  return {\n    depthWriteEnabled: depth && depth.enable,\n    depthCompare: depthFuncMap[(depth === null || depth === void 0 ? void 0 : depth.func) || _gWebgpuCore.gl.ALWAYS],\n    format: WebGPUConstants.TextureFormat.Depth24PlusStencil8,\n    stencilFront: stencilFrontBack,\n    stencilBack: stencilFrontBack,\n    stencilReadMask: 0xffffffff,\n    stencilWriteMask: 0xffffffff\n  };\n}\n/**\n * @see https://gpuweb.github.io/gpuweb/#color-state\n */\n\n\nfunction getColorStateDescriptors(_ref3, swapChainFormat) {\n  var blend = _ref3.blend;\n  return [{\n    format: swapChainFormat,\n    // https://gpuweb.github.io/gpuweb/#blend-state\n    alphaBlend: {\n      srcFactor: blendFuncMap[blend && blend.func && blend.func.srcAlpha || _gWebgpuCore.gl.ONE],\n      dstFactor: blendFuncMap[blend && blend.func && blend.func.dstAlpha || _gWebgpuCore.gl.ZERO],\n      operation: blendEquationMap[blend && blend.equation && blend.equation.alpha || _gWebgpuCore.gl.FUNC_ADD]\n    },\n    colorBlend: {\n      srcFactor: blendFuncMap[blend && blend.func && blend.func.srcRGB || _gWebgpuCore.gl.ONE],\n      dstFactor: blendFuncMap[blend && blend.func && blend.func.dstRGB || _gWebgpuCore.gl.ZERO],\n      operation: blendEquationMap[blend && blend.equation && blend.equation.rgb || _gWebgpuCore.gl.FUNC_ADD]\n    },\n    writeMask: WebGPUConstants.ColorWrite.All\n  }];\n}\n//# sourceMappingURL=constants.js.map","\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _gWebgpuCore = require(\"@antv/g-webgpu-core\");\n\nvar WebGPUConstants = _interopRequireWildcard(require(\"@webgpu/types/dist/constants\"));\n\nvar _constants2 = require(\"./constants\");\n\n/**\n * adaptor for regl.Buffer\n * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#buffers\n */\nvar WebGPUTexture2D = /*#__PURE__*/function () {\n  function WebGPUTexture2D(engine, options) {\n    (0, _classCallCheck2.default)(this, WebGPUTexture2D);\n    this.engine = engine;\n    this.options = options;\n    this.texture = void 0;\n    this.sampler = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.createTexture();\n  }\n\n  (0, _createClass2.default)(WebGPUTexture2D, [{\n    key: \"get\",\n    value: function get() {\n      return {\n        texture: this.texture,\n        sampler: this.sampler\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update() {// TODO\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(_ref) {\n      var width = _ref.width,\n          height = _ref.height;\n\n      // TODO: it seems that Texture doesn't support `resize`\n      if (width !== this.width || height !== this.height) {\n        this.destroy();\n        this.createTexture();\n      }\n\n      this.width = width;\n      this.height = height;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.texture) {\n        this.texture.destroy();\n      }\n    }\n  }, {\n    key: \"createTexture\",\n    value: function createTexture() {\n      var _this$options = this.options,\n          data = _this$options.data,\n          _this$options$type = _this$options.type,\n          type = _this$options$type === void 0 ? _gWebgpuCore.gl.UNSIGNED_BYTE : _this$options$type,\n          width = _this$options.width,\n          height = _this$options.height,\n          _this$options$flipY = _this$options.flipY,\n          flipY = _this$options$flipY === void 0 ? false : _this$options$flipY,\n          _this$options$format = _this$options.format,\n          format = _this$options$format === void 0 ? _gWebgpuCore.gl.RGBA : _this$options$format,\n          _this$options$mipmap = _this$options.mipmap,\n          mipmap = _this$options$mipmap === void 0 ? false : _this$options$mipmap,\n          _this$options$wrapS = _this$options.wrapS,\n          wrapS = _this$options$wrapS === void 0 ? _gWebgpuCore.gl.CLAMP_TO_EDGE : _this$options$wrapS,\n          _this$options$wrapT = _this$options.wrapT,\n          wrapT = _this$options$wrapT === void 0 ? _gWebgpuCore.gl.CLAMP_TO_EDGE : _this$options$wrapT,\n          _this$options$aniso = _this$options.aniso,\n          aniso = _this$options$aniso === void 0 ? 0 : _this$options$aniso,\n          _this$options$alignme = _this$options.alignment,\n          alignment = _this$options$alignme === void 0 ? 1 : _this$options$alignme,\n          _this$options$premult = _this$options.premultiplyAlpha,\n          premultiplyAlpha = _this$options$premult === void 0 ? false : _this$options$premult,\n          _this$options$mag = _this$options.mag,\n          mag = _this$options$mag === void 0 ? _gWebgpuCore.gl.NEAREST : _this$options$mag,\n          _this$options$min = _this$options.min,\n          min = _this$options$min === void 0 ? _gWebgpuCore.gl.NEAREST : _this$options$min,\n          _this$options$colorSp = _this$options.colorSpace,\n          colorSpace = _this$options$colorSp === void 0 ? _gWebgpuCore.gl.BROWSER_DEFAULT_WEBGL : _this$options$colorSp,\n          usage = _this$options.usage;\n      this.width = width;\n      this.height = height;\n      this.texture = this.engine.device.createTexture({\n        size: [width, height, 1],\n        // TODO: arrayLayerCount is deprecated: use size.depth\n        // arrayLayerCount: 1,\n        mipLevelCount: 1,\n        // TODO: https://gpuweb.github.io/gpuweb/#dom-gputextureviewdescriptor-miplevelcount\n        sampleCount: 1,\n        dimension: WebGPUConstants.TextureDimension.E2d,\n        format: _constants2.formatMap[format],\n        // could throw texture binding usage mismatch\n        usage: usage || WebGPUConstants.TextureUsage.Sampled | WebGPUConstants.TextureUsage.CopyDst\n      });\n\n      if (!usage || usage & WebGPUConstants.TextureUsage.Sampled) {\n        this.sampler = this.engine.device.createSampler({\n          addressModeU: _constants2.wrapModeMap[wrapS],\n          addressModeV: _constants2.wrapModeMap[wrapT],\n          addressModeW: _constants2.wrapModeMap[wrapS],\n          // TODO: same as addressModeU\n          magFilter: _constants2.filterMap[mag],\n          minFilter: _constants2.filterMap[min],\n          maxAnisotropy: aniso // @see https://gpuweb.github.io/gpuweb/#dom-gpusamplerdescriptor-maxanisotropy\n\n        });\n      }\n    }\n  }]);\n  return WebGPUTexture2D;\n}();\n\nexports.default = WebGPUTexture2D;\n//# sourceMappingURL=WebGPUTexture2D.js.map"]}